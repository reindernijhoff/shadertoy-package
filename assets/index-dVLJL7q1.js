var Z=Object.defineProperty;var K=(s,e,n)=>e in s?Z(s,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):s[e]=n;var a=(s,e,n)=>K(s,typeof e!="symbol"?e+"":e,n);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))t(o);new MutationObserver(o=>{for(const r of o)if(r.type==="childList")for(const i of r.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&t(i)}).observe(document,{childList:!0,subtree:!0});function n(o){const r={};return o.integrity&&(r.integrity=o.integrity),o.referrerPolicy&&(r.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?r.credentials="include":o.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function t(o){if(o.ep)return;o.ep=!0;const r=n(o);fetch(o.href,r)}})();class M{constructor(e,n){a(this,"gl");a(this,"_program");a(this,"vs");a(this,"fs");a(this,"initialized",!1);a(this,"ext");a(this,"type",0);a(this,"vsSource","");a(this,"fsSource","");a(this,"uniformLocations",{});a(this,"uniformTypes",{});a(this,"attributeLocations",{});a(this,"_compiled",!1);this.gl=e;const t=e.context;this.ext=t.getExtension("KHR_parallel_shader_compile"),this._program=t.createProgram(),this.vs=t.createShader(t.VERTEX_SHADER),this.fs=t.createShader(t.FRAGMENT_SHADER),this.type=this.detectType(n),this.vsSource=this.getVertexShader(this.type),t.shaderSource(this.vs,this.vsSource),t.compileShader(this.vs),this.fsSource=`${this.getFragmentShader(this.type)}${n}`,t.shaderSource(this.fs,this.fsSource),t.compileShader(this.fs),t.attachShader(this._program,this.vs),t.attachShader(this._program,this.fs),t.linkProgram(this._program)}get program(){if(this.initialized)return this._program;this.initialized=!0;const e=this.gl.context;let n=e.getShaderParameter(this.vs,e.COMPILE_STATUS);if(!n)throw console.table(this.vsSource.split(`
`)),new Error(`ImageEffectRenderer: Vertex shader compilation failed: ${e.getShaderInfoLog(this.vs)}`);if(n=e.getShaderParameter(this.fs,e.COMPILE_STATUS),!n)throw console.table(this.fsSource.split(`
`)),new Error(`ImageEffectRenderer: Shader compilation failed: ${e.getShaderInfoLog(this.fs)}`);if(n=e.getProgramParameter(this._program,e.LINK_STATUS),!n)throw new Error(`ImageEffectRenderer: Program linking failed: ${e.getProgramInfoLog(this._program)}`);return this._program}get shaderCompiled(){return this._compiled=this._compiled||!this.ext||this.gl.context.getProgramParameter(this._program,this.ext.COMPLETION_STATUS_KHR),this._compiled}use(){this.gl.context.useProgram(this.program)}getUniformLocation(e){return this.uniformLocations[e]!==void 0?this.uniformLocations[e]:this.uniformLocations[e]=this.gl.context.getUniformLocation(this._program,e)}getAttributeLocation(e){return this.attributeLocations[e]!==void 0?this.attributeLocations[e]:(this.gl.context.useProgram(this.program),this.attributeLocations[e]=this.gl.context.getAttribLocation(this._program,e))}getUniformType(e){if(this.uniformTypes[e]!==void 0)return this.uniformTypes[e];const n=this.gl.context,t=n.getProgramParameter(this._program,n.ACTIVE_UNIFORMS);for(let o=0;o<t;o++){const r=n.getActiveUniform(this._program,o);if(r&&r.name===e)return this.uniformTypes[e]=r.type}return this.uniformTypes[e]=null}detectType(e){const n=/mainImage/gmi,t=/^#version[\s]+300[\s]+es[\s]+/gmi;return n.exec(e)?0:t.exec(e)?3:2}getFragmentShader(e){switch(e){case 0:return`#version 300 es
                        precision highp float;

                        ${this.getUniformShader()}

                        in vec2 vUV0;
                        out vec4 outFragColor;

                        void mainImage(out vec4, vec2);

                        vec4 texture2D(sampler2D tex, vec2 uv) {
                            return texture(tex, uv);
                        }

                        vec4 texture2DLod(sampler2D tex, vec2 uv, float lod) {
                            return textureLod(tex, uv, lod);
                        }

                        vec4 texture2DLodEXT(sampler2D tex, vec2 uv, float lod) {
                            return textureLod(tex, uv, lod);
                        }

                        
                        vec4 texture2DGrad(sampler2D tex, vec2 uv, vec2 dPdx, vec2 dPdy) {
                            return textureGrad(tex, uv, dPdx, dPdy);
                        }

                        vec4 texture2DGradEXT(sampler2D tex, vec2 uv, vec2 dPdx, vec2 dPdy) {
                            return textureGrad(tex, uv, dPdx, dPdy);
                        }

                        void main(void) {
                            outFragColor = vec4(0.0, 0.0, 0.0, 1.0);
                            mainImage(outFragColor, vUV0 * iResolution.xy);
                        }
                        `;default:return""}}getVertexShader(e){switch(e){case 0:return`#version 300 es
                    in vec2 aPos;
                    in vec2 aUV;

                    out vec2 vUV0;

                    void main(void) {
                        vUV0 = aUV;
                        gl_Position = vec4(aPos, 0.0, 1.0);
                    }
                `;case 2:return`attribute vec3 aPos;
                attribute vec2 aUV;

                uniform float iAspect;

                varying vec2 vScreen;
                varying vec2 vUV0;

                void main(void) {
                    vUV0 = aUV;
                    vScreen = aPos.xy;
                    vScreen.x *= iAspect;
                    gl_Position = vec4(aPos, 1.0);
                }`;case 3:default:return`#version 300 es
                in  vec3 aPos;
                in vec2 aUV;

                uniform float iAspect;

                out vec2 vScreen;
                out vec2 vUV0;

                void main(void) {
                    vUV0 = aUV;
                    vScreen = aPos.xy;
                    vScreen.x *= iAspect;
                    gl_Position = vec4(aPos, 1.0);
                }`}}getUniformShader(){return`
            #define HW_PERFORMANCE 1

            uniform vec3 iResolution;
            uniform float iTime;
            uniform float iTimeDelta;
            uniform int iFrame;
            uniform float iChannelTime[4];
            uniform vec4 iMouse;
            uniform vec4 iMouseNormalized;
            uniform vec4 iDate;
            uniform float iSampleRate;
            uniform vec3 iChannelResolution[4];

            uniform float iGlobalTime;
            uniform float iAspect;

            uniform highp sampler2D iChannel0;
            uniform highp sampler2D iChannel1;
            uniform highp sampler2D iChannel2;
            uniform highp sampler2D iChannel3;
            uniform highp sampler2D iChannel4;
            uniform highp sampler2D iChannel5;
            uniform highp sampler2D iChannel6;
            uniform highp sampler2D iChannel7;

            uniform highp samplerCube iChannelCube0;
            uniform highp samplerCube iChannelCube1;
            uniform highp samplerCube iChannelCube2;
            uniform highp samplerCube iChannelCube3;
            uniform highp samplerCube iChannelCube4;
            uniform highp samplerCube iChannelCube5;
            uniform highp samplerCube iChannelCube6;
            uniform highp samplerCube iChannelCube7;
            `}}const B=0,k=1,H=2,G=3,F=4,X=5;class Q{constructor(e,n){a(this,"type");a(this,"name");a(this,"x",0);a(this,"y",0);a(this,"z",0);a(this,"w",0);a(this,"matrix");this.type=e,this.name=n}}class I{constructor(e=void 0){a(this,"context");a(this,"canvas");a(this,"sharedPrograms",{});a(this,"sharedTextures",{});a(this,"quadVBO");a(this,"lastQuadVBO");this.canvas=e||document.createElement("canvas");const n={premultipliedAlpha:!0,alpha:!0,preserveDrawingBuffer:!1,antialias:!1,depth:!1,stencil:!1};if(this.context=this.canvas.getContext("webgl2",n),!this.context)throw new Error("Unable to create WebGL2 context.");this.context.getExtension("WEBGL_color_buffer_float"),this.context.getExtension("EXT_color_buffer_float"),this.context.getExtension("OES_texture_float"),this.context.getExtension("OES_texture_float_linear"),this.context.getExtension("KHR_parallel_shader_compile"),this.context.clearColor(0,0,0,0),this.context.clear(this.context.COLOR_BUFFER_BIT),this.context.enable(this.context.BLEND),this.context.blendFunc(this.context.ONE,this.context.ONE_MINUS_SRC_ALPHA),this.quadVBO=this.generateQuad()}drawQuad(e,n){const t=this.context;this.lastQuadVBO!==this.quadVBO&&(this.lastQuadVBO=this.quadVBO,t.bindBuffer(t.ARRAY_BUFFER,this.quadVBO),t.enableVertexAttribArray(e),t.vertexAttribPointer(e,2,t.FLOAT,!1,16,0),t.enableVertexAttribArray(n),t.vertexAttribPointer(n,2,t.FLOAT,!1,16,8)),t.drawArrays(t.TRIANGLE_STRIP,0,4)}getCachedTexture(e,n){const t=`${e}_${n.clampX}_${n.clampY}_${n.useMipmap}`;return this.sharedTextures[e]?this.sharedTextures[t]:this.sharedTextures[t]=this.context.createTexture()}compileShader(e){return this.sharedPrograms[e]?this.sharedPrograms[e]:this.sharedPrograms[e]=new M(this,e)}setTextureParameter(e,n){const t=this.context;t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,n.clampX?t.CLAMP_TO_EDGE:t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,n.clampY?t.CLAMP_TO_EDGE:t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,n.magFilterLinear?t.LINEAR:t.NEAREST),n.useMipmap?(t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.generateMipmap(t.TEXTURE_2D)):t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,n.minFilterLinear?t.LINEAR:t.NEAREST)}setCubeMapParameter(e,n){const t=this.context;t.bindTexture(t.TEXTURE_CUBE_MAP,e),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MAG_FILTER,n.magFilterLinear?t.LINEAR:t.NEAREST),n.useMipmap?(t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.generateMipmap(t.TEXTURE_CUBE_MAP)):t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,n.minFilterLinear?t.LINEAR:t.NEAREST)}bindTextures(e){const n=this.context;for(let t=0;t<8;t++){n.activeTexture(n.TEXTURE0+t);const o=e[t];o&&o.buffer?n.bindTexture(n.TEXTURE_2D,o.buffer.src.texture):o&&o.texture?o.isCubemap?n.bindTexture(n.TEXTURE_CUBE_MAP,o.texture):n.bindTexture(n.TEXTURE_2D,o.texture):n.bindTexture(n.TEXTURE_2D,null)}}setUniforms(e,n){const t=this.context;Object.values(e).forEach(o=>{const r=n.getUniformLocation(o.name);if(r!==null)switch(o.type){case B:t.uniform1i(r,o.x);break;case k:t.uniform1f(r,o.x);break;case H:t.uniform2f(r,o.x,o.y);break;case G:t.uniform3f(r,o.x,o.y,o.z);break;case F:t.uniform4f(r,o.x,o.y,o.z,o.w);break;case X:t.uniformMatrix4fv(r,!1,o.matrix);break}})}generateQuad(){const e=this.context,n=new Float32Array([-1,1,0,1,-1,-1,0,0,1,1,1,1,1,-1,1,0]),t=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),t}}const w={clampX:!0,clampY:!0,flipY:!1,useMipmap:!0,useCache:!0,minFilterLinear:!0,magFilterLinear:!0};class _{constructor(e){a(this,"width",0);a(this,"height",0);a(this,"program");a(this,"main");a(this,"gl");a(this,"frame",0);a(this,"lastTime",0);a(this,"mouse",[0,0,0,0]);a(this,"mouseNormalized",[0,0,0,0]);a(this,"uniforms",{});a(this,"textures",[]);this.gl=e}get shaderCompiled(){return this.program.shaderCompiled}get iMouseUsed(){return this.program.getUniformLocation("iMouse")!==null||this.program.getUniformLocation("iMouseNormalized")!==null}setImage(e,n,t={}){if(e>=8)throw new Error("ImageEffectRenderer: A maximum of 8 slots is available, slotIndex is out of bounds.");if(n instanceof HTMLImageElement){if(!n.complete||n.naturalWidth===0){n.addEventListener("load",()=>{this.setImage(e,n,t)},{once:!0});return}}else if(n instanceof HTMLVideoElement&&n.readyState<HTMLMediaElement.HAVE_CURRENT_DATA){n.addEventListener("loadeddata",()=>{this.setImage(e,n,t)},{once:!0});return}this.setUniformInt(`iChannel${e}`,e);let o,r;typeof VideoFrame<"u"&&n instanceof VideoFrame?(o=n.displayWidth,r=n.displayHeight):(o=n.width,r=n.height),this.setUniformVec3(`iChannelResolution[${e}]`,o,r,1);const i=this.gl.context,c=this.textures[e];if(n instanceof _){c&&c.texture&&!c.cached&&i.deleteTexture(c.texture);const l={...n.options,...t};this.textures[e]={texture:void 0,buffer:n,cached:!1,isCubemap:!1},this.gl.setTextureParameter(n.src.texture,l),this.gl.setTextureParameter(n.dest.texture,l)}else{const l={...w,...t};l.useCache=l.useCache&&n instanceof HTMLImageElement,l.useCache&&c&&c.texture&&!c.cached&&(i.deleteTexture(c.texture),c.texture=void 0);let d=c&&c.texture;l.useCache&&n instanceof HTMLImageElement&&(d=this.gl.getCachedTexture(n.src,l)),d||(d=i.createTexture()),this.textures[e]={texture:d,buffer:void 0,cached:l.useCache,isCubemap:!1},i.bindTexture(i.TEXTURE_2D,d),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,t.flipY?1:0),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,n),this.gl.setTextureParameter(d,l)}}setCubeMap(e,n,t={}){if(e>=8)throw new Error("ImageEffectRenderer: A maximum of 8 slots is available, slotIndex is out of bounds.");if(n.length!==6)throw new Error("ImageEffectRenderer: Cubemap requires exactly 6 face images.");for(let f=0;f<6;f++){const x=n[f];if(x instanceof HTMLImageElement&&(!x.complete||x.naturalWidth===0)){x.addEventListener("load",()=>{this.setCubeMap(e,n,t)},{once:!0});return}}this.setUniformInt(`iChannelCube${e}`,e);const o=n[0];let r,i;typeof VideoFrame<"u"&&o instanceof VideoFrame?(r=o.displayWidth,i=o.displayHeight):(r=o.width,i=o.height),this.setUniformVec3(`iChannelResolution[${e}]`,r,i,1);const c=this.gl.context,l=this.textures[e];l&&l.texture&&!l.cached&&c.deleteTexture(l.texture);const d={...w,...t},S=c.createTexture();this.textures[e]={texture:S,buffer:void 0,cached:!1,isCubemap:!0},c.bindTexture(c.TEXTURE_CUBE_MAP,S),c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL,0);const W=[c.TEXTURE_CUBE_MAP_POSITIVE_X,c.TEXTURE_CUBE_MAP_NEGATIVE_X,c.TEXTURE_CUBE_MAP_POSITIVE_Y,c.TEXTURE_CUBE_MAP_NEGATIVE_Y,c.TEXTURE_CUBE_MAP_POSITIVE_Z,c.TEXTURE_CUBE_MAP_NEGATIVE_Z];for(let f=0;f<6;f++)c.texImage2D(W[f],0,c.RGBA,c.RGBA,c.UNSIGNED_BYTE,n[f]);this.gl.setCubeMapParameter(S,d)}setUniformFloat(e,n){this.setUniform(e,k,n,0,0,0,void 0)}setUniformInt(e,n){this.setUniform(e,B,n,0,0,0,void 0)}setUniformVec2(e,n,t){this.setUniform(e,H,n,t,0,0,void 0)}setUniformVec3(e,n,t,o){this.setUniform(e,G,n,t,o,0,void 0)}setUniformVec4(e,n,t,o,r){this.setUniform(e,F,n,t,o,r,void 0)}setUniformMatrix(e,n){this.setUniform(e,X,0,0,0,0,n)}destruct(){this.textures.forEach(e=>e.texture&&!e.cached&&this.gl.context.deleteTexture(e.texture)),this.textures=[],this.uniforms={}}draw(e=0,n,t){this.width=n|0,this.height=t|0,this.program.use();const o=e-this.lastTime;this.lastTime=e,this.setUniformFloat("iTime",e),this.setUniformFloat("iTimeDelta",o),this.setUniformInt("iFrame",this.frame),this.program.getUniformType("iResolution")===this.gl.context.FLOAT_VEC2?this.setUniformVec2("iResolution",n,t):this.setUniformVec3("iResolution",n,t,1);const r=this.main.mouse;this.setUniformVec4("iMouse",r[0],r[1],r[2],r[3]);const i=this.main.mouseNormalized;this.setUniformVec4("iMouseNormalized",i[0],i[1],i[2],i[3]);const c=new Date;this.setUniformVec4("iDate",c.getFullYear(),c.getMonth(),c.getDate(),c.getHours()*3600+c.getMinutes()*60+c.getSeconds()+c.getMilliseconds()/1e3),this.setUniformFloat("iSampleRate",44100),this.setUniformFloat("iGlobalTime",e),this.setUniformFloat("iAspect",n/t),this.gl.setUniforms(this.uniforms,this.program),this.gl.bindTextures(this.textures),this.gl.drawQuad(this.program.getAttributeLocation("aPos"),this.program.getAttributeLocation("aUV")),this.frame++}setUniform(e,n,t,o,r,i,c){let l=this.uniforms[e];l||(l=this.uniforms[e]=new Q(n,e)),l.x=t,l.y=o,l.z=r,l.w=i,l.matrix=c}}const q={type:5121,pixelRatio:1,msaa:!1};class O{constructor(e,n={}){a(this,"width",0);a(this,"height",0);a(this,"texture");a(this,"frameBuffer");a(this,"options");a(this,"gl");a(this,"format",WebGLRenderingContext.RGBA);a(this,"internalFormat",WebGLRenderingContext.RGBA);switch(this.gl=e,this.options={...q,...n},this.options.type){case WebGLRenderingContext.UNSIGNED_BYTE:this.internalFormat=WebGL2RenderingContext.RGBA8;break;case WebGLRenderingContext.FLOAT:this.internalFormat=WebGL2RenderingContext.RGBA32F;break}const t=e.context;this.texture=t.createTexture(),this.resize(16,16),this.frameBuffer=t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this.frameBuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture,0),t.bindFramebuffer(t.FRAMEBUFFER,null)}resize(e,n){if(this.width===(e|0)&&this.height===(n|0))return;this.width=e|0,this.height=n|0;const t=this.gl.context;t.bindTexture(t.TEXTURE_2D,this.texture),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,0),t.texImage2D(t.TEXTURE_2D,0,this.internalFormat,this.width,this.height,0,this.format,this.options.type,null)}destruct(){const e=this.gl.context;this.frameBuffer&&e.deleteFramebuffer(this.frameBuffer),this.texture&&e.deleteTexture(this.texture)}}const $={...w,...q,useMipmap:!1,useCache:!1};class J extends _{constructor(n,t={}){super(n);a(this,"options");a(this,"frameBuffer0");a(this,"frameBuffer1");this.options={...$,...t},this.frameBuffer0=new O(n,this.options),this.frameBuffer1=new O(n,this.options)}get src(){return this.frame%2===0?this.frameBuffer0:this.frameBuffer1}get dest(){return this.frame%2===1?this.frameBuffer0:this.frameBuffer1}draw(n=0,t,o){if(t<=0||o<=0)return;const r=this.gl.context,i=this.dest;i.resize(t,o),r.bindFramebuffer(r.FRAMEBUFFER,i.frameBuffer),r.clear(r.COLOR_BUFFER_BIT),super.draw(n,t,o),r.bindFramebuffer(r.FRAMEBUFFER,null)}destruct(){super.destruct(),this.frameBuffer0.destruct(),this.frameBuffer1.destruct()}}let y=0,b=0,j=0,V=0,v=!1,A=!1,C=0,R=0,T=0,U=0,z=!1;function nn(s){z||(z=!0,s.addEventListener("mousemove",e=>{j=y,V=b,y=e.clientX,b=e.clientY,v&&(T=y,U=b)},{passive:!0}),s.addEventListener("mousedown",e=>{e.button===0&&(v=!0,A=!0,C=e.clientX,R=e.clientY,T=e.clientX,U=e.clientY)},{passive:!0}),s.addEventListener("mouseup",e=>{e.button===0&&(v=!1)},{passive:!0}))}function en(){A=!1}function tn(s){const e=(y-s.left)/s.width,n=1-(b-s.top)/s.height,t=(j-s.left)/s.width,o=1-(V-s.top)/s.height;return[e,n,t,o]}function on(s){const e=s.height,n=T-s.left,t=e-(U-s.top),o=C-s.left,r=e-(R-s.top),i=v||C>0?n:0,c=v||R>0?t:0,l=(v?1:-1)*(o>0?o:0),d=(A?1:-1)*(r>0?r:0);return[i,c,l,d]}class L extends _{constructor(n,t,o,r){super(n);a(this,"canvas");a(this,"buffers",[]);a(this,"options");a(this,"time",0);a(this,"tickFuncs",[]);a(this,"readyFuncs",[]);a(this,"startTime",-1);a(this,"drawOneFrame",!1);a(this,"container");a(this,"animationRequestId",0);a(this,"resizeObserver");a(this,"_ready",!1);if(this.options={...r},this.container=t,this.main=this,this.options.useSharedContext){this.canvas=document.createElement("canvas");const i=this.canvas.getContext("2d");i.fillStyle="#00000000",i.clearRect(0,0,this.canvas.width,this.canvas.height)}else this.canvas=this.gl.canvas;Object.assign(this.canvas.style,{inset:"0",width:"100%",height:"100%",margin:"0",display:"block"}),this.container.appendChild(this.canvas),this.program=new M(this.gl,o),this.resizeObserver=new ResizeObserver(()=>{this.options.autoResize&&this.updateSize()}),this.resizeObserver.observe(t),this.options.useSharedContext||this.drawingLoop(0)}get drawThisFrame(){return(this.options.loop||this.drawOneFrame)&&this.width>0&&this.height>0&&(!this.options.asyncCompile||this.allShadersCompiled)}get iMouseUsed(){return super.iMouseUsed||this.buffers.some(n=>n&&n.iMouseUsed)}get allShadersCompiled(){return this.shaderCompiled&&this.buffers.every(n=>n&&n.shaderCompiled)}play(){this.options.loop=!0}stop(){this.options.loop=!1}createBuffer(n,t,o={}){const r=this.buffers[n];r&&r.destruct();const i=new J(this.gl,o);return i.program=this.gl.compileShader(t),i.main=this,this.buffers[n]=i}tick(n){this.tickFuncs.push(n)}ready(n){this.readyFuncs.push(n)}drawFrame(n=0){this.time=n/1e3,this.drawOneFrame=!0}setData(n){n.buffers&&this.setBuffersData(n.buffers),n.images&&this.setImagesData(n.images),n.cubemaps&&this.setCubeMapsData(n.cubemaps)}setImagesData(n,t=this){n.forEach(o=>{o.image.bufferIndex!==void 0?t==null||t.setImage(o.slotIndex,this.buffers[o.image.bufferIndex],o.options):t==null||t.setImage(o.slotIndex,o.image,o.options)})}setBuffersData(n){n.forEach(t=>{this.createBuffer(t.index,t.shader,t.options)}),n.forEach(t=>{t.images&&this.setImagesData(t.images,this.buffers[t.index]),t.cubemaps&&this.setCubeMapsData(t.cubemaps,this.buffers[t.index])})}setCubeMapsData(n,t=this){n.forEach(o=>{t==null||t.setCubeMap(o.slotIndex,o.faces,o.options)})}drawInstance(n){const t=this.gl.context;if(this.drawOneFrame||(this.time+=n),this.tickFuncs.forEach(o=>o(n)),this.iMouseUsed){const o=this.container.getBoundingClientRect();this.mouse=on(o),this.mouseNormalized=tn(o),en()}this.buffers.forEach(o=>{o&&(t.viewport(0,0,this.width,this.height),o.draw(this.time,this.canvas.width,this.canvas.height))}),t.viewport(0,0,this.width,this.height),t.clear(t.COLOR_BUFFER_BIT),this.draw(this.time,this.canvas.width,this.canvas.height),this.drawOneFrame=!1}update(n){this.allShadersCompiled&&(this._ready||(this._ready=!0,this.readyFuncs.forEach(t=>t()),this.readyFuncs=[],this.iMouseUsed&&nn(document.body)))}destruct(){cancelAnimationFrame(this.animationRequestId),super.destruct(),this.resizeObserver.disconnect(),this.container.removeChild(this.canvas),this.canvas.replaceWith(this.canvas.cloneNode(!0)),this.buffers.forEach(n=>{n.destruct()}),this.buffers=[],this.tickFuncs=[]}copyCanvas(){const n=this.gl.canvas,t=this.canvas.getContext("2d");t.clearRect(0,0,this.width,this.height),t.drawImage(n,0,n.height-this.height,this.width,this.height,0,0,this.width,this.height)}updateSize(){this.width=this.container.offsetWidth*this.options.pixelRatio|0,this.height=this.container.offsetHeight*this.options.pixelRatio|0,(this.width!==this.canvas.width||this.height!==this.canvas.height)&&(this.canvas.width=this.width,this.canvas.height=this.height,this.drawOneFrame=!0)}drawingLoop(n=0){this.animationRequestId=window.requestAnimationFrame(o=>this.drawingLoop(o)),n/=1e3;const t=this.startTime<0?1/60:n-this.startTime;this.startTime=n>0?n:-1,this.update(t),this.drawThisFrame&&this.drawInstance(t)}}const rn={loop:!1,autoResize:!0,pixelRatio:typeof window<"u"?window.devicePixelRatio:1,useSharedContext:!1,asyncCompile:!0},h=[],D=[];let p,E=-1;class N{constructor(){throw new Error("Use ImageEffectRenderer.createTemporary to create an ImageEffectRenderer")}static createTemporary(e,n,t={}){const o={...rn,...t};if(o.useSharedContext){p||(p=new I,this.drawInstances(0));const r=new L(p,e,n,o);return h.push(r),r}else{const r=D.pop()||new I;return new L(r,e,n,o)}}static releaseTemporary(e){e.options.useSharedContext||D.push(e.gl),e.stop(),e.destruct();const n=h.indexOf(e);n>-1&&h.splice(n,1)}static drawInstances(e=0){window.requestAnimationFrame(l=>this.drawInstances(l)),e/=1e3;const n=E<0?1/60:e-E;E=e;const t=p.canvas,o=p.context,r=h;let i=0,c=0;r.forEach(l=>{l.update(n)}),r.forEach(l=>{l.drawThisFrame&&(i=Math.max(i,l.width),c=Math.max(c,l.height))}),(i>t.width||c>t.height)&&(t.width=i,t.height=c),o.clear(o.COLOR_BUFFER_BIT),r.forEach(l=>{l.drawThisFrame&&(l.drawInstance(n),l.copyCanvas())})}}class an{constructor(){a(this,"canvas");a(this,"ctx");a(this,"imageData");a(this,"keyStates");a(this,"keyPressed");a(this,"keyToggle");a(this,"bound",!1);this.canvas=document.createElement("canvas"),this.canvas.width=256,this.canvas.height=3,this.ctx=this.canvas.getContext("2d"),this.imageData=this.ctx.createImageData(256,3),this.keyStates=new Uint8Array(256),this.keyPressed=new Uint8Array(256),this.keyToggle=new Uint8Array(256),this.handleKeyDown=this.handleKeyDown.bind(this),this.handleKeyUp=this.handleKeyUp.bind(this)}bind(){this.bound||(this.bound=!0,document.addEventListener("keydown",this.handleKeyDown),document.addEventListener("keyup",this.handleKeyUp))}unbind(){this.bound&&(this.bound=!1,document.removeEventListener("keydown",this.handleKeyDown),document.removeEventListener("keyup",this.handleKeyUp))}handleKeyDown(e){const n=e.keyCode;n<256&&(this.keyStates[n]===0&&(this.keyPressed[n]=255,this.keyToggle[n]=this.keyToggle[n]===0?255:0),this.keyStates[n]=255)}handleKeyUp(e){const n=e.keyCode;n<256&&(this.keyStates[n]=0)}update(){const e=this.imageData.data;for(let n=0;n<256;n++){const t=n*4;e[t]=this.keyStates[n],e[t+1]=this.keyStates[n],e[t+2]=this.keyStates[n],e[t+3]=255;const o=(256+n)*4;e[o]=this.keyPressed[n],e[o+1]=this.keyPressed[n],e[o+2]=this.keyPressed[n],e[o+3]=255;const r=(512+n)*4;e[r]=this.keyToggle[n],e[r+1]=this.keyToggle[n],e[r+2]=this.keyToggle[n],e[r+3]=255,this.keyPressed[n]=0}return this.ctx.putImageData(this.imageData,0,0),this.canvas}getTexture(){return this.canvas}destruct(){this.unbind()}}const cn="https://www.shadertoy.com";class sn{constructor(e,n,t={}){a(this,"renderer");a(this,"shader");a(this,"options");a(this,"loadedImages",new Map);a(this,"keyboardHandler",null);a(this,"keyboardChannels",new Map);a(this,"bufferIdToIndex",new Map);a(this,"cubemapChannels",new Map);this.shader=n,this.options=t;const o=this.getImagePass();if(!o)throw new Error("Shader does not have an image renderpass");this.detectCubemapChannels();const r=this.getCommonCode(),i=this.processShaderCode(o,r);this.renderer=N.createTemporary(e,i,{loop:!0,...t}),this.setupBuffers(r),this.loadInputs()}getImagePass(){return this.shader.renderpass.find(e=>e.type==="image")}getBufferPasses(){return this.shader.renderpass.filter(e=>e.type==="buffer")}detectCubemapChannels(){for(const e of this.shader.renderpass){if(!e.inputs)continue;const n=new Set;for(const t of e.inputs)t.type==="cubemap"&&n.add(t.channel);n.size>0&&this.cubemapChannels.set(e,n)}}processShaderCode(e,n){let t=this.prependCommonCode(e.code,n);const o=this.cubemapChannels.get(e);if(o)for(const r of o){const i=new RegExp(`\\biChannel${r}\\b`,"g");t=t.replace(i,`iChannelCube${r}`)}return t}setupBuffers(e){const n=this.getBufferPasses();this.bufferIdToIndex=new Map,n.forEach((t,o)=>{const r=this.processShaderCode(t,e),i=o;if(t.outputs)for(const c of t.outputs)this.bufferIdToIndex.set(c.id,i);this.renderer.createBuffer(i,r,{type:WebGL2RenderingContext.FLOAT})})}getCommonCode(){const e=this.shader.renderpass.find(n=>n.type==="common");return(e==null?void 0:e.code)||""}prependCommonCode(e,n){return n?`${n}

${e}`:e}async loadInputs(){const e=this.getImagePass();if(!e)return;await this.loadPassInputs(e,this.renderer);const n=this.getBufferPasses();for(let t=0;t<n.length;t++){const o=this.renderer.buffers[t];o&&await this.loadPassInputs(n[t],o)}}async loadPassInputs(e,n){if(e.inputs)for(const t of e.inputs)await this.loadInput(t,n)}async loadInput(e,n){const t=e.channel;if(e.type==="buffer"){const o=this.getBufferIndexFromId(e.id);if(o>=0&&this.renderer.buffers[o]){const r=this.getImageOptions(e);n.setImage(t,this.renderer.buffers[o],r)}}else if(e.type==="texture"){const o=await this.loadImage(e.filepath);if(o){const r=this.getImageOptions(e);n.setImage(t,o,r)}}else if(e.type==="cubemap"){const o=await this.loadCubemap(e.filepath);if(o){const r=this.getImageOptions(e);n.setCubeMap(t,o,r)}}else e.type==="keyboard"&&(this.keyboardHandler||(this.keyboardHandler=new an,this.keyboardHandler.bind(),this.renderer.tick(()=>{if(this.keyboardHandler){const o=this.keyboardHandler.update();for(const[r,i]of this.keyboardChannels)i.setImage(r,o,{minFilterLinear:!1,magFilterLinear:!1})}})),this.keyboardChannels.set(t,n),n.setImage(t,this.keyboardHandler.update(),{minFilterLinear:!1,magFilterLinear:!1}))}getBufferIndexFromId(e){return this.bufferIdToIndex.get(e)??-1}getImageOptions(e){const n=e.sampler;return{clampX:(n==null?void 0:n.wrap)==="clamp",clampY:(n==null?void 0:n.wrap)==="clamp",flipY:(n==null?void 0:n.vflip)==="true",useMipmap:(n==null?void 0:n.filter)==="mipmap",minFilterLinear:(n==null?void 0:n.filter)!=="nearest",magFilterLinear:(n==null?void 0:n.filter)!=="nearest"}}getMediaUrl(e){if(this.options.mediaMapping){const n=this.options.mediaMapping(e);if(n!=null)return n}return`${cn}${e}`}async loadImage(e){if(this.loadedImages.has(e))return this.loadedImages.get(e);const n=this.getMediaUrl(e);return Array.isArray(n)?null:this.loadSingleImage(n)}async loadSingleImage(e){return this.loadedImages.has(e)?this.loadedImages.get(e):new Promise(n=>{const t=new Image;t.crossOrigin="anonymous",t.onload=()=>{this.loadedImages.set(e,t),n(t)},t.onerror=()=>n(null),t.src=e})}async loadCubemap(e){var r;const n=this.getMediaUrl(e);let t;if(Array.isArray(n)){if(n.length!==6)return null;t=n}else{const i=n,c=((r=i.match(/\.[^.]+$/))==null?void 0:r[0])||".jpg",l=i.slice(0,-c.length);t=[i,`${l}_1${c}`,`${l}_2${c}`,`${l}_3${c}`,`${l}_4${c}`,`${l}_5${c}`]}const o=await Promise.all(t.map(i=>this.loadSingleImage(i)));return o.some(i=>i===null)?null:o}play(){this.renderer.play()}stop(){this.renderer.stop()}destruct(){this.keyboardHandler&&(this.keyboardHandler.destruct(),this.keyboardHandler=null),this.keyboardChannels.clear(),N.releaseTemporary(this.renderer),this.loadedImages.clear()}}const ln=JSON.parse(`[{"ver":"0.1","info":{"id":"4sl3z4","date":"1364249310","viewed":11859,"name":"Moonlight","description":"If your using a Mac or Linux please uncomment line 1 to view the full shader with mountains and a floating bottle (screenshot: http://imgur.com/KKPZsj4). \\n\\nPart of the code is copy-pasted from shaders by inigo quilez and dave hoskins.","likes":123,"published":"Public API","usePreview":0,"tags":["procedural","noise","reflection","raymarch","water","raytrace"]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Moonlight. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4sl3z4\\n//\\n\\n#define SHOWALL\\n//#define SHOWBOTTLE\\n\\n#ifdef SHOWALL\\n\\t#define SHOWBOTTLE\\n\\t//#define BOTTLESHADOW 0\\n\\t#define SHOWMOUNTAINS\\n\\t#define CLOUDDETAiL\\n#endif\\n\\n#define CLOUDSHARPNESS 0.001\\n#define WINDSPEED vec2(-43.0, 32.0)\\n#define BUMPFACTOR 0.05\\n#define BUMPDISTANCE 70.\\n#define MAXMOUNTAINDISTANCE 40.\\n#define SKYCOLOR vec3(0.1,0.1,0.15)\\n#define MOONLIGHTCOLOR vec3(.4,0.4,0.2)\\n#define SKYBYMOONLIGHTCOLOR vec3(.4,.2,0.87)\\n#define BOTTLECOLOR vec3( 0.7, 1., 0.6 )*0.3\\n#define WATERCOLOR vec3( 0.2, 0.2, 0.4 )\\n\\n#define EXPOSURE 0.9\\n#define EPSILON 0.01\\n#define MARCHSTEPS 100\\n\\n#define time (iTime + 23.0)\\n#define CLOUDCOVER (0.1*cos( time*0.072+0.2 ) + 0.26)\\n#define moont (time * 0.1)\\n#define moonf (-time * 0.1)\\n#define moondir normalize( vec3( cos(moont), 0.8*(0.6+0.5*sin(moonf)), sin(moont) ) )\\n\\n// math functions\\n\\nconst mat3 m = mat3( 0.00,  0.90,  0.60,\\n                    -0.90,  0.36, -0.48,\\n                    -0.60, -0.48,  0.34 );\\n\\nconst mat2 mr = mat2 (0.84147,  0.54030,\\n                      0.54030, -0.84147 );\\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453);\\n}\\n\\nfloat noise( in vec3 x )\\n{\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\tf = f*f*(3.0-2.0*f);\\n\\t\\n\\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\\n\\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\\n\\treturn mix( rg.x, rg.y, f.z );\\n}\\n\\nfloat noise( in vec2 x )\\n{\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\\n\\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0.0 ).x;\\n}\\n\\n\\nfloat fbm( vec3 p ) {\\n    float f;\\n    f  =      0.5000*noise( p ); p = m*p*2.02;\\n    f +=      0.2500*noise( p ); p = m*p*2.33;\\n    f +=      0.1250*noise( p ); p = m*p*2.01;\\n    f +=      0.0625*noise( p ); \\n    return f/(0.9175);\\n}\\n\\nfloat fbm( vec2 p ) {\\n    float f;\\n    f  =      0.5000*noise( p ); p = mr*p*2.02;\\n    f +=      0.2500*noise( p ); p = mr*p*2.33;\\n    f +=      0.1250*noise( p ); p = mr*p*2.01;\\n    f +=      0.0625*noise( p ); \\n    return f/(0.9175);\\n}\\n\\n// heightmaps\\n\\nfloat heightMap( vec3 pos ) {\\n\\tfloat n = noise( vec2(0.0,4.2)+pos.xz*0.14 );\\n\\treturn 9.*(n-0.7);\\n}\\n\\nfloat waterHeightMap( vec2 pos ) {\\n\\tvec2 posm = pos * mr;\\n\\tposm.x += 0.25*time;\\n\\tfloat f = fbm( vec3( posm*1.9, time*0.27 ));\\n\\tfloat height = 0.5+0.1*f;\\n\\theight += 0.13*sin( posm.x*6.0 + 10.0*f );\\n\\n#ifdef SHOWBOTTLE\\t\\n\\tfloat d = length(pos-vec2(-3., 0.));\\n\\theight += 0.1 * cos( d*50.-time*4. ) * (1. - smoothstep( 0., 1.0, d) );\\n#endif\\n\\t\\n\\treturn  height;\\n}\\n\\n// intersection functions\\n\\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\\t\\n\\tif (rd.y==0.0) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(100000.0, d);\\n\\tif( d > 0. ) {\\n\\t\\tdist = d;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\nbool intersectHeightMap(vec3 ro, vec3 rd, float maxdist, const bool reflection, out float dist ) {\\n\\tfloat dt = 0.3;\\n\\tvec3 pos;\\n\\tdist = 0.0;\\n\\tbool hit = false;\\n\\n\\tfor( int i=0; i<MARCHSTEPS; i++) {\\n\\t\\tif( hit || dist > maxdist ) break;\\n\\t\\t\\n\\t\\tdist += dt;\\n\\t\\tdt = min( dt*1.1, 0.5 );\\n\\t\\tpos = ro + rd*dist;\\n\\t\\tif( heightMap( pos ) >= pos.y ) {\\n\\t\\t\\thit = true;\\n\\t\\t}\\n\\t}\\n\\treturn hit;\\n}\\n\\nbool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph, out float dist, out vec3 normal ) {\\n    vec3  ds = ro - sph.xyz;\\n    float bs = dot( rd, ds );\\n    float cs = dot(  ds, ds ) - sph.w*sph.w;\\n    float ts = bs*bs - cs;\\n\\t\\n    if( ts > 0.0 ) {\\n        ts = -bs - sqrt( ts );\\n\\t\\tif( ts>0. ) {\\n\\t\\t\\tnormal = normalize( ((ro+ts*rd)-sph.xyz)/sph.w );\\n\\t\\t\\tdist = ts;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n    }\\n\\n    return false;\\n}\\n\\nbool intersectCylinder( in vec3 ro, in vec3 rd, in vec3 A, in vec3 B, in float radius, out float dist, out vec3 normal) {\\n\\tvec3 AB = B - A;\\n\\tvec3 AO = ro - A;\\n \\n\\tfloat AB_dot_d = dot( AB, rd );\\n\\tfloat AB_dot_AO = dot( AB, AO );\\n\\tfloat AB_dot_AB = dot( AB, AB );\\n \\n\\tfloat m = AB_dot_d / AB_dot_AB;\\n\\tfloat n = AB_dot_AO / AB_dot_AB;\\n \\n\\tvec3 Q = rd - (AB * m);\\n\\tvec3 R = AO - (AB * n);\\n \\n\\tfloat a = dot( Q, Q );\\n\\tfloat b = 2.0 * dot( Q, R );\\n\\tfloat c = dot( R, R ) - (radius*radius);\\n \\n\\tif(a == 0.0) {\\n\\t\\tfloat adist = 100000., bdist = 100000.;\\n\\t\\tif(\\t!intersectSphere( ro, rd, vec4( A, radius ), adist, normal ) ||\\n\\t\\t\\t!intersectSphere( ro, rd, vec4( B, radius ), bdist, normal ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n \\t\\tdist = min (adist, bdist);\\n\\t\\tnormal = normalize((ro+rd*dist) - (adist<bdist?A:B) );\\n\\t\\treturn true;\\n\\t}\\n \\n\\tfloat discriminant = b * b - 4.0 * a * c;\\n\\tif(discriminant < 0.0) {\\n\\t\\treturn false;\\n\\t}\\n \\n\\tfloat sqrtdis = sqrt(discriminant);\\n\\tfloat tmin = (-b - sqrtdis) / (2.0 * a);\\n\\tfloat tmax = (-b + sqrtdis) / (2.0 * a);\\n\\tif( tmin < 0. )\\n\\t\\ttmin = tmax;\\n\\telse \\n\\t\\ttmin = min(tmin, tmax); \\n\\t\\n\\tif( tmin < 0. ) return false;\\n\\t\\n\\tfloat t_k1 = tmin * m + n;\\n\\tfloat dc = 10000000.;\\n\\t\\n\\tvec3 nc;\\n\\t\\n\\tif(t_k1 < 0.0)\\t{\\t\\t\\n\\t\\tif(intersectSphere( ro, rd, vec4( A, radius ), dist, normal)) {\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\telse if(t_k1 > 1.0) {\\n\\t\\tif(intersectSphere( ro, rd, vec4( B, radius ), dist, normal)) {\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t} else {\\n\\t\\t// On the cylinder...\\n\\t\\tvec3 p1 = ro + (rd * tmin);\\n \\t\\tvec3 k1 = A + AB * t_k1;\\n\\t\\tdist = tmin;\\n\\t\\tnormal = normalize( p1 - k1 );\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\t\\nbool intersectBottle ( in vec3 ro,  in vec3 rd, out float dist, out vec3 normal ) {\\t\\t\\n\\tfloat d = 1000000.;\\n\\tbool  hitc;\\n\\tfloat distc;\\n\\tvec3  normalc;\\t\\n\\t\\n\\tfloat rx = sin( iTime ) * 0.2;\\t\\n\\tvec3 up = vec3( 0., 0.4 * cos(rx), 0.4 * sin(rx) );\\n\\tvec3 pos = vec3(  -3.0, 0.05*cos(iTime*0.6)+0.05, 0.);\\n\\t\\n\\thitc = intersectCylinder( ro, rd, pos+up*1.5, pos-up*1.5, 0.07, distc, normalc);\\n\\tif( hitc && distc < d ) {\\n\\t\\td = distc;\\n\\t\\tnormal = normalc;\\n\\t}\\n\\thitc = intersectCylinder( ro, rd, pos+up*0.15, pos-up*0.15, 0.22, distc, normalc);\\n\\tif( hitc && distc < d ) {\\n\\t\\td = distc;\\n\\t\\tnormal = normalc;\\n\\t}\\n\\tif( d < 1000000. ) {\\n\\t\\tdist = d;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\n// more copy-paste functions...\\n\\nfloat cloudDensity( vec3 rd ) {\\n\\tfloat d;\\n\\tintersectPlane( vec3(0., 0., 0.), rd, 500., d );\\n\\tvec3 intersection = rd*d;\\t\\n\\t\\n\\tfloat cloud = 0.5 + 0.5*fbm( vec3( \\n\\t\\t(intersection.xz + WINDSPEED*time)*0.001, time*0.25) ) - (1.-CLOUDCOVER);\\n\\n#ifdef CLOUDDETAiL\\t\\n\\tcloud += 0.02*noise((intersection.xz - WINDSPEED*time*0.01));\\n#endif\\n\\t\\n    if (cloud < 0.) cloud = 0.;\\n\\t\\n\\tcloud = 1. - pow(CLOUDSHARPNESS, cloud);\\n\\t\\n\\tcloud = mix( CLOUDCOVER, cloud, smoothstep( 0.0, 0.1, dot( rd, vec3(0.,1.,0.) ) ) );\\n\\t\\n\\treturn cloud;\\n}\\n\\nvec3 skyColor( vec3 rd ) {\\t\\n\\tfloat moonglow = clamp( 1.0782*dot(moondir,rd), 0.0, 2.0 );\\n\\tvec3 col = SKYCOLOR * moondir.y;\\n\\tcol += .4*SKYBYMOONLIGHTCOLOR*moonglow;\\n\\tcol += 0.43*MOONLIGHTCOLOR*pow( moonglow, 21.0 );\\n\\n\\t// moon!\\n\\tfloat dist; vec3 normal; bool moonhit = false;\\n\\tif( intersectSphere( vec3(0., 0., 0.), rd, vec4( moondir, 0.07), dist, normal ) ) {\\n\\t\\tfloat l = dot( normalize(vec3( -moondir.x, 0.0, -moondir.z)+vec3( 2.2, -1.6, 0.)), normal );\\n\\t\\tcol += 3.0*MOONLIGHTCOLOR*clamp(l, 0.0, 1.);\\n\\t\\tmoonhit = true;\\n\\t}\\n\\t\\t\\n\\t// Do the stars...\\n\\tif( !moonhit ) {\\n\\t\\tvec3 rds = rd;\\n\\t\\t\\n\\t\\tfloat v = 1.0/( 2. * ( 1. + rds.z ) );\\n\\t\\tvec2 xy = vec2(rds.y * v, rds.x * v);\\n\\t\\tfloat s = noise(rds.xz*134.);\\n\\t\\ts += noise(rds.xz*370.);\\n\\t\\ts += noise(rds.xz*870.);\\n\\t\\ts = pow(s,19.0) * 0.00000001 * max(rd.y, 0.0 );\\n\\t\\tif (s > 0.1) {\\n\\t\\t\\tvec3 backStars = vec3((1.0-sin(xy.x*20.0+time*13.0*rds.x+xy.y*30.0))*.5*s,s, s); \\n\\t\\t\\tcol += backStars;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tcol *= (1.0-cloudDensity( rd ) );\\n\\n\\treturn col;\\n}\\n\\n// trace function\\n\\nvec3 trace(vec3 ro, vec3 rd, float currentDistance, const bool reflection, out vec3 intersection, out vec3 normal, out float dist, out int material) \\n{\\n\\tmaterial = 0; // sky\\n\\tfloat d = 1000000.;\\n\\tbool  hitc;\\n\\tfloat distc;\\n\\tvec3  normalc;\\n\\n#ifdef SHOWMOUNTAINS\\n\\thitc = intersectHeightMap( ro, rd, MAXMOUNTAINDISTANCE-currentDistance, reflection, distc );\\n\\tif( hitc ) {\\n\\t\\tmaterial = 1; // mountain\\n\\t\\tnormal = -rd; // ahum\\n\\t\\td = distc;\\n\\t}\\n#endif\\n\\n\\thitc = intersectPlane( ro, rd, 0., distc);\\n\\tif( hitc && (distc < d) ) {\\n\\t\\tmaterial = 2; // water\\n\\t\\tnormal = vec3( 0., 1., 0. );\\n\\t\\td = distc;\\n\\t}\\n\\t\\n#ifdef SHOWBOTTLE\\n\\thitc = intersectBottle( ro, rd, distc, normalc ); \\n\\tif( hitc && (distc < d) ) {\\n\\t\\tmaterial = 3; // bottle\\n\\t\\tnormal = normalc;\\n\\t\\td = distc;\\n\\t}\\n#endif\\n\\t\\n\\tif( d < 100000. ) {\\n\\t\\tdist = d;\\n\\t\\tintersection = ro + rd*dist;\\n\\t}\\n\\n\\tif( !reflection && material == 2 ) {\\n\\t\\tvec2 coord = intersection.xz;\\n\\t\\tvec2 dx = vec2( EPSILON, 0. );\\n\\t\\tvec2 dz = vec2( 0., EPSILON );\\n\\t\\t\\n\\t\\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, dist) );\\n\\t\\t\\n\\t\\tnormal.x = bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) / (2. * EPSILON);\\n\\t\\tnormal.z = bumpfactor * (waterHeightMap(coord + dz) - waterHeightMap(coord-dz) ) / (2. * EPSILON);\\n\\t\\tnormal = normalize( normal );\\n\\t}\\n\\t\\t\\n\\tvec3 col;\\n\\tfloat diff = clamp(dot(normal,moondir), 0., 1.);\\n\\t\\n\\t// shadow ?\\n#ifdef BOTTLESHADOW\\n\\tif( intersectBottle( intersection+normal*EPSILON, moondir, distc, normalc ) ) {\\n\\t\\tdiff = 0.;\\n\\t}\\n#endif\\n\\t\\n\\tif (material == 2) { // water\\n\\t\\tcol = WATERCOLOR * MOONLIGHTCOLOR * diff;\\n\\t} else if( material == 1 ) { // mountains\\n\\t\\tcol = mix( 0.5 * MOONLIGHTCOLOR * diff, vec3(0.), (currentDistance+dist)/MAXMOUNTAINDISTANCE);\\n\\t} else if( material == 3 ) { // bottle\\n\\t\\tcol = BOTTLECOLOR * diff * smoothstep( 0., 0.2, intersection.y );\\n\\t} else { // sky\\n\\t\\tcol = skyColor(rd);\\n\\t}\\n\\t\\n\\tif( material > 0 ) {\\n\\t\\tcol = mix( col, SKYCOLOR*CLOUDCOVER, clamp( dist/100., 0., 1.) );\\t\\n\\t}\\n\\t\\t\\n\\treturn col;\\n}\\n\\t\\t\\n// main\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\n\\tvec2 q = fragCoord.xy/iResolution.xy;\\n    vec2 p = -1.0+2.0*q;\\n\\tp.x *= iResolution.x/iResolution.y;\\n    vec2 mo = iMouse.xy/iResolution.xy;\\n\\t\\t \\n\\tfloat a = moont + 0.3*sin( time*0.12 )+(mo.x>0.?(mo.x-0.5):0.)*3.1415*2.;\\n\\t// camera\\t\\n\\tvec3 ce = vec3( 0.0, 0.2, 0.0 );\\n\\tvec3 ro = ce + vec3( 1.3*cos(0.11*time + 6.0*mo.x), 0.65*(mo.y>0.?mo.y:0.5), 1.3*sin(0.11*time + 6.0*mo.x) );\\n\\tvec3 ta = ro + vec3( 0.95*cos(a), 0.75*ro.y-0.3+moondir.y*0.2, 0.95*sin(a) );\\n\\t\\n\\tfloat roll = -0.15*sin(0.1*time);\\n\\t\\n\\t// camera tx\\n\\tvec3 cw = normalize( ta-ro );\\n\\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n\\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\\n\\n\\t// raytrace\\n\\tint material;\\n\\tvec3 normal, intersection;\\n\\tfloat dist = 0., dist2 = 0.;\\n\\t\\t\\n\\tvec3 col = trace(ro, rd, 0.0, false, intersection, normal, dist, material);\\n\\n\\tif( material >= 2 ) {\\n\\t\\t// reflection\\n\\t\\tvec3 rfld = reflect( rd, normal );\\n\\t\\t\\n\\t\\tfloat reflectstrength = 1.-abs(dot( rd, normal ));\\n\\t\\t\\n\\t\\tcol += 0.9 * reflectstrength * trace(intersection+rfld*EPSILON, rfld, dist, true, intersection, normal, dist2, material);\\n\\t}\\n\\n\\tcol = pow( col, vec3(EXPOSURE, EXPOSURE, EXPOSURE) );\\t\\n\\tcol = clamp(col, 0.0, 1.0);\\n\\t\\n    // vigneting\\n    col *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\\n\\t\\n\\tfragColor = vec4( col,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdlGz4","date":"1364485357","viewed":11202,"name":"Minecraft Blocks","description":"Shameless port of javascriptcode by Markus Persson (http://jsfiddle.net/uzMPU/).","likes":65,"published":"Public API","usePreview":0,"tags":["raycasting","voxel","minecraft","proceduraltextures"]},"renderpass":[{"inputs":[],"outputs":[],"code":"// Minecraft Blocks. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MdlGz4\\n//\\n// port of javascript minecraft: http://jsfiddle.net/uzMPU/\\n// original code by Markus Persson: https://twitter.com/notch/status/275331530040160256\\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453);\\n}\\n\\n// port of minecraft\\n\\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\\n\\t// 16x16 tex\\n\\tvec2 uv = floor( coord );\\n\\n    float n = uv.x + uv.y*347.0 + 4321.0 * float(i);\\n\\tfloat h = hash(n);\\n\\t\\t\\n    float br = 1. - h * (96./255.\\n\\t\\t\\t\\t\\t\\t);\\n\\tcolor = vec3( 150./255., 108./255.,  74./255.); // 0x966C4A;\\n\\t\\n\\tif (i == 4) {\\n\\t\\tcolor = vec3( 127./255., 127./255., 127./255.); // 0x7F7F7F;\\n\\t}\\n\\t\\n\\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\\n\\t\\n\\tif (i == 1) {\\n\\t\\tif( uv.y < (xm1 + 18.)) {\\n\\t\\t\\tcolor = vec3( 106./255., 170./255.,  64./255.); // 0x6AAA40;\\n\\t\\t} else if (uv.y < (xm1 + 19.)) {\\n\\t\\t\\tbr = br * (2. / 3.);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif (i == 7) {\\n\\t\\tcolor = vec3( 103./255., 82./255.,  49./255.); // 0x675231;\\n\\t\\tif (uv.x > 0. && uv.x < 15.\\n\\t\\t\\t&& ((uv.y > 0. && uv.y < 15.) || (uv.y > 32. && uv.y < 47.))) {\\n\\t\\t\\tcolor = vec3( 188./255., 152./255.,  98./255.); // 0xBC9862;\\n\\t\\t\\tfloat xd = (uv.x - 7.);\\n\\t\\t\\tfloat yd = (mod(uv.y, 16.) - 7.);\\n\\t\\t\\tif (xd < 0.)\\n\\t\\t\\t\\txd = 1. - xd;\\n\\t\\t\\tif (yd < 0.)\\n\\t\\t\\t\\tyd = 1. - yd;\\n\\t\\t\\tif (yd > xd)\\n\\t\\t\\t\\txd = yd;\\n\\t\\t\\t\\n\\t\\t\\tbr = 1. - (h * (32./255.) + mod(xd, 4.) * (32./255.));\\n\\t\\t} else if ( h < 0.5 ) {\\n\\t\\t\\tbr = br * (1.5 - mod(uv.x, 2.));\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif (i == 5) {\\n\\t\\tcolor = vec3( 181./255.,  58./255.,  21./255.); // 0xB53A15;\\n\\t\\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\\n\\t\\t\\tcolor = vec3( 188./255., 175./255., 165./255.); // 0xBCAFA5;\\n\\t\\t}\\n\\t}\\n\\tif (i == 9) {\\n\\t\\tcolor = vec3(  64./255.,  64./255., 255./255.); // 0x4040ff;\\n\\t}\\n\\t\\n\\tfloat brr = br;\\n\\tif (uv.y >= 32.)\\n\\t\\tbrr /= 2.;\\n\\t\\n\\tif (i == 8) {\\n\\t\\tcolor = vec3(  80./255., 217./255.,  55./255.); // 0x50D937;\\n\\t\\tif ( h < 0.5) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tcolor *= brr;\\n\\t\\n\\treturn true;\\n}\\n\\nint getMap( vec3 pos ) {\\t\\n\\tvec3 posf = floor( (pos - vec3(32.))  );\\n    \\n\\tfloat n = posf.x + posf.y*517.0 + 1313.0*posf.z;\\n    float h = hash(n);\\n\\t\\n\\tif( h > sqrt( sqrt( dot( posf.yz, posf.yz )*0.16 ) ) - 0.8  ) {\\n        return 0;\\n\\t}\\t\\n\\t\\n\\treturn int( hash( n * 465.233 ) * 16. );\\n}\\n\\nvec3 renderMinecraft( vec2 uv ) {\\n    float xRot = sin( iTime*0.5 ) * 0.4 + (3.1415 / 2.);\\n    float yRot = cos( iTime*0.5 ) * 0.4;\\n    float yCos = cos(yRot);\\n    float ySin = sin(yRot);\\n    float xCos = cos(xRot);\\n    float xSin = sin(xRot);\\n\\n\\tvec3 opos = vec3( 32.5 + iTime * 6.4, 32.5, 32.5 );\\n\\t\\n\\tfloat gggxd = (uv.x - 0.5) * (iResolution.x / iResolution.y );\\n\\tfloat ggyd = (1.-uv.y - 0.5);\\n\\tfloat ggzd = 1.;\\n\\t\\n\\tfloat gggzd = ggzd * yCos + ggyd * ySin;\\n\\t\\n\\tvec3 _posd = vec3( gggxd * xCos + gggzd * xSin,\\n\\t\\t\\t\\t\\t   ggyd * yCos - ggzd * ySin,\\n\\t\\t\\t\\t\\t   gggzd * xCos - gggxd * xSin );\\n\\t\\n\\tvec3 col = vec3( 0. );\\n\\tfloat br = 1.;\\n\\tvec3 bdist = vec3( 255. - 100., 255. -   0., 255. -  50.  );\\n\\tfloat ddist = 0.;\\n\\t\\n\\tfloat closest = 32.;\\n\\t\\n\\tfor ( int d = 0; d < 3; d++) {\\n\\t\\tfloat dimLength = _posd[d];\\n\\t\\t\\n\\t\\tfloat ll = abs( 1. / dimLength );\\n\\t\\tvec3 posd = _posd * ll;;\\n\\t\\t\\n\\t\\tfloat initial = fract( opos[d] );\\n\\t\\tif (dimLength > 0.) initial = 1. - initial;\\n\\t\\t\\n\\t\\tfloat dist = ll * initial;\\n\\t\\t\\n\\t\\tvec3 pos = opos + posd * initial;\\n\\t\\t\\n\\t\\tif (dimLength < 0.) {\\n\\t\\t\\tpos[d] -= 1.;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i=0; i<30; i++) {\\n\\t\\t\\tif( dist > closest )continue;\\n\\t\\t\\t\\n\\t\\t\\t//int tex = getMap( mod( pos, 64. ) );\\n\\t\\t\\tint tex = getMap( pos );\\n\\t\\t\\t\\n\\t\\t\\tif (tex > 0) {\\n\\t\\t\\t\\tvec2 texcoord;\\n\\t\\t\\t\\ttexcoord.x = mod(((pos.x + pos.z) * 16.), 16.);\\n\\t\\t\\t\\ttexcoord.y = mod((pos.y * 16.), 16.) + 16.;\\n\\t\\t\\t\\tif (d == 1) {\\n\\t\\t\\t\\t\\ttexcoord.x = mod(pos.x * 16., 16.);\\n\\t\\t\\t\\t\\ttexcoord.y = mod(pos.z * 16., 16.);\\n\\t\\t\\t\\t\\tif (posd.y < 0.)\\n\\t\\t\\t\\t\\t\\ttexcoord.y += 32.;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif ( getMaterialColor( tex, texcoord, col ) ) {\\n\\t\\t\\t\\t\\tddist = 1. - (dist / 32.);\\n\\t\\t\\t\\t\\tbr = bdist[d];\\n\\t\\t\\t\\t\\tclosest = dist;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tpos += posd;\\n\\t\\t\\tdist += ll;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn col * ddist * (br/255.);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n\\tvec2 uv = fragCoord.xy / iResolution.xy;\\n\\t\\n\\tfragColor = vec4( renderMinecraft( uv ) ,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsfGzM","date":"1365016363","viewed":3542,"name":"Nyan","description":"Nyan exploring. The shader shows the procedural textures of my shader 'Abandond base on Mars': https://www.shadertoy.com/view/4sfGR7.","likes":46,"published":"Public API","usePreview":0,"tags":["procedural","textures"]},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Nyan. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XsfGzM\\n//\\n\\n// seconds needed to walk through room\\n#define WALKINGSPEED 3.\\n\\n#define DIRT\\n#define NYANSPEED 16.\\n\\n#define NUMBERLIGHTS 4\\n\\n#define EXPOSURE 1.9\\n#define AMBIANT 3.\\n#define DYNAMICLIGHTSTRENGTH 2.\\n#define PI 3.1415926\\n\\n#define INTERVALBACKGROUND 16.\\n#define INTERVALFLOOR 16.\\n#define INTERVALFOREGROUND 16.\\n#define INTERVALSPECULARCOLOR 1.\\n#define INTERVALDIRT 10.\\n\\n\\nfloat dirtFactor;\\n\\n\\n//\\n// math functions\\n//\\n\\nconst mat2 mr = mat2 (0.84147,  0.54030,\\n\\t\\t\\t\\t\\t  0.54030, -0.84147 );\\nfloat hash( float n ) {\\n\\treturn fract(sin(n)*43758.5453);\\n}\\nvec2 hash2( float n ) {\\n    return fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\\n}\\n\\nvec3 hash3( float n ) {\\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\\n}\\nfloat noise(in float x) {\\n\\tfloat p = floor(x);\\n\\tfloat f = fract(x);\\n\\t\\t\\n\\tf = f*f*(3.0-2.0*f);\\t\\n\\treturn mix( hash(p+  0.0), hash(p+  1.0),f);\\n}\\nfloat noise(in vec2 x) {\\n\\tvec2 p = floor(x);\\n\\tvec2 f = fract(x);\\n\\t\\t\\n\\tf = f*f*(3.0-2.0*f);\\t\\n\\tfloat n = p.x + p.y*57.0;\\n\\t\\n\\tfloat res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n\\t\\t\\t\\t\\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\\n\\treturn res;\\n}\\nfloat fbm( vec2 p ) {\\n\\tfloat f;\\n\\tf  =      0.5000*noise( p ); p = mr*p*2.02;\\n\\tf +=      0.2500*noise( p ); p = mr*p*2.33;\\n\\tf +=      0.1250*noise( p ); p = mr*p*2.01;\\n\\tf +=      0.0625*noise( p ); p = mr*p*2.01;\\n\\treturn f/(0.9175);\\n}\\n\\n//\\n// material functions\\n//\\n\\nfloat matfhf, matflf;\\nfloat matnoisehf;\\nvec3 math3;\\n\\nvoid materialInit(in float seed, const vec2 coord) {\\n\\tmatfhf = fbm( coord * 171. );\\n\\tmatflf = fbm( coord );\\n\\tmatnoisehf = noise( coord * 193. );\\n\\tmath3  = hash3( seed * 11. );\\n}\\n\\nvec3 materialBaseColor( float t ) {\\n\\tt = mod( t, 3490423. );\\n\\treturn texture( iChannel0, vec2( t )*vec2(0.14591255443,0.34934560423) ).xyz;\\n}\\n\\nvoid materialDirt( const vec2 coord, out vec3 color, out vec2 normal ) {\\n\\tcolor = vec3( 0.7, 0.5, 0.4 ) * (0.25+0.75*matfhf);\\n\\tnormal = vec2( matnoisehf*2. -1. );\\n}\\n\\nvec2 materialGrooves( float seed, bool iswall ) {\\n\\tvec2 math2 = hash2( seed );\\n\\tif( iswall ) return clamp( floor(math2*6.) / 8. - 0.25, vec2(0.), vec2(1.));\\n\\treturn clamp( floor( math2*4.) / 8., vec2(0.), vec2(1.));\\n}\\n\\nfloat grooveHeight( float l, const float w, float p ) {\\n\\tif( l == 0. ) return 1.;\\n\\treturn (smoothstep( 0.,  w*0.5, mod(p, l) )) * (1.-smoothstep( l-w*0.5, l, mod(p, l) ));\\n}\\n\\nfloat materialHeightMap( const vec2 grooves, const vec2 coord ) {\\n\\treturn min( grooveHeight( grooves.x, 0.01, coord.x ), grooveHeight( grooves.y, 0.01, coord.y ));\\n}\\n\\nfloat materialDirtAmount( const vec2 grooves, const vec2 coord ) {\\n\\tvec2 f = mix( vec2(0.01), grooves*2., dirtFactor );\\n\\treturn 1. - 0.5*min( grooveHeight( grooves.x, f.x, coord.x ), grooveHeight( grooves.y, f.y, coord.y ));\\n}\\n\\n// calculate color\\n\\nvoid getMaterial( float seed, const vec2 coord, const vec2 grooves,  bool isfloor, bool iswall, \\n\\t\\t\\t  \\t  out vec3 color, out vec2 normal, out float spec ) {\\n\\n\\tfloat height = materialHeightMap( grooves, coord );\\t\\n\\tnormal.x = (height-materialHeightMap( grooves, coord-vec2(0.002,0.) )) * 500.;\\n\\tnormal.y = (height-materialHeightMap( grooves, coord-vec2(0.,0.002) )) * 500.;\\n\\tnormal += 0.1*fract( math3.y * 1.64325 ) * (2. * vec2( matfhf, matnoisehf ) - vec2(1.));\\n\\t\\n\\tspec = (height + 4.*matfhf )*0.1*fract( math3.x * 1.13 )*matflf;\\n\\t\\n\\tvec3 color1 = materialBaseColor( seed ); \\t\\n\\tvec3 color2 = materialBaseColor( seed*2.6345 ); \\t\\n\\n\\t// checkboard ?\\n\\tbool checkx = grooves.x > 0. && mod( coord.x, grooves.x*2. ) < grooves.x;\\n\\tbool checky = grooves.y > 0. && mod( coord.y, grooves.y*2. ) < grooves.y;\\n\\t\\n\\tif( fract( math3.z * 4.435 ) < 0.5 && ((checkx && checky) || (!checkx && !checky)) ) {\\n\\t\\tcolor = mix( color2, color1, matflf*fract(math3.y*45.234) );\\n\\t} else {\\t\\t\\n\\t\\tcolor = mix( color1, color2, matflf*fract(math3.y*45.234) );\\n\\t}\\n\\t\\n\\tcolor *= (0.8+0.2*height+0.2*fract( math3.x*3.76 )*matfhf);\\n\\t\\t\\n#ifdef DIRT\\t\\n\\tif( dirtFactor > 0.1 ) { // dirt\\n\\t\\tvec2 dirtNormal; vec3 dirtColor;\\t\\t\\n\\t\\tmaterialDirt( coord, dirtColor, dirtNormal );\\n\\t\\t\\n\\t\\tfloat dirtAmount = materialDirtAmount( grooves, coord );\\t\\n\\n\\t\\tif( iswall ) {\\n\\t\\t\\tdirtAmount += clamp( dirtFactor - coord.y, -dirtAmount, 1.);\\n\\t\\t} else\\tif( !isfloor ) {\\n\\t\\t\\tdirtAmount *= 0.5; // less dirt on ceiling\\n\\t\\t}\\n\\t\\n\\t\\tdirtFactor = clamp( 10. * (0.5* (dirtAmount * matflf + matfhf ) - (1.-dirtFactor)), 0., 1.);\\n\\t\\n\\t\\tif( dirtFactor > 0.1 ) {\\n\\t\\t\\tcolor = mix( color, dirtColor, dirtFactor );\\n\\t\\t\\tspec *= 1. - dirtFactor;\\n\\t\\t\\tnormal = mix( normal, dirtNormal, dirtFactor );\\n\\t\\t}\\n\\t}\\n#endif\\n}\\n\\nvoid getWallMaterial( float seed, vec2 coord,  \\n\\t\\t\\t\\t\\t  out vec3 color, out vec2 normal, out float spec ) {\\n\\tcoord *= 0.1;\\n\\tmaterialInit( seed, coord );\\n\\t\\n\\tfloat s = mod( floor( math3.y*13.4361 ), 8. ) * 0.125;\\n\\t\\n\\tfloat wseed = seed;\\n\\tif( coord.y > s ) wseed += 1.;\\t\\n\\n\\tvec2 grooves = materialGrooves( wseed, true );\\n\\n\\tgetMaterial( seed, coord, vec2(grooves.x, max( grooves.y, s )), false, true, color, normal, spec );\\n}\\n\\nvoid getFloorMaterial( float seed, vec2 coord, bool isfloor,  \\n\\t\\t\\t\\t\\t   out vec3 color, out vec2 normal, out float spec ) {\\t\\n\\tcoord *= 0.1;\\n\\tmaterialInit( seed, coord );\\n\\tvec2 grooves = materialGrooves( seed, false );\\n\\n\\tgetMaterial( seed, coord, grooves, isfloor, false, color, normal, spec );\\n}\\n\\n\\nvec3 getColor(vec2 coord, float time) {\\n\\tfloat z, spec, offset;\\n\\tvec3 color, position, normal, retcolor;\\n\\tvec2 ntangent;\\n\\t\\n    \\n\\toffset = time * NYANSPEED;\\n\\t\\n\\tcoord.y += 0.4;\\n\\t\\n\\tif( coord.y >  0. ) { // wall at z = -8.\\n\\t\\tz = 8.; vec2 dxy = vec2( z );\\n\\t\\tposition = vec3( coord*dxy, z );\\n\\t\\tfloat material = floor( (position.x+offset) / INTERVALBACKGROUND );\\t\\n\\t\\tgetWallMaterial( material, position.xy+offset*vec2(1., 0.), color, ntangent, spec );\\n\\t\\tnormal = normalize( vec3( -ntangent.x, -ntangent.y, -1. ) );\\n\\t} else if( coord.y < -0.125 ) { // wall at z = -4;\\n\\t\\tz = 4.; vec2 dxy = vec2( z );\\n\\t\\tposition = vec3( (coord+vec2(0.,0.125))*dxy, z );\\n\\t\\tfloat material = floor( (position.x+offset) / INTERVALFOREGROUND );\\n\\t\\tgetFloorMaterial( material, position.xy+offset*vec2(1., 0.), false, color, ntangent, spec );\\n\\t\\tnormal = normalize( vec3( -ntangent.x, -ntangent.y, -1. ) );\\n\\t} else { // floor\\n\\t\\tz = -1./(coord.y-0.125); vec2 dxy = vec2( z );\\n\\t\\tposition = vec3( coord*dxy, z );\\n\\t\\tfloat material = floor( (position.x+offset) / INTERVALFLOOR );\\n\\t\\tgetFloorMaterial( material, position.xz+offset*vec2(1., 0.), true, color, ntangent, spec );\\n\\t\\tnormal = normalize( vec3( -ntangent.x, 1., -ntangent.y ) );\\n\\t}\\n\\t\\n\\t// nyan cat! at z=-7;\\n\\tz = 7.; vec2 dxy = vec2( z );\\n\\tvec2 nyanpos = coord*dxy+vec2( 6.5, 1.2 );\\n\\tbool nyanhit = false;\\n\\t\\n\\tif( nyanpos.x >= 0. && nyanpos.x < 5. && nyanpos.y >= 0. && nyanpos.y < 5. ) {\\n\\t\\tvec2 nyancoord = nyanpos/5.;\\n\\t\\t\\n\\t\\tfloat ofx = floor( mod( time*NYANSPEED, 6.0 ) );\\n\\t\\tfloat ww = 40.0/256.0;\\n\\t\\t\\t\\t\\n\\t\\tnyancoord.y = 1.0-nyancoord.y;\\n\\t\\tnyancoord.x = clamp( nyancoord.x*ww + ofx*ww, 0.0, 1.0 );\\n\\t\\tvec4 nyan = texture( iChannel1, nyancoord );\\n\\t\\tif( nyan.w > 0. ) {\\n\\t\\t\\tcolor = nyan.xyz;\\n\\t\\t\\tnormal = vec3( 0., 0., -1. );\\n\\t\\t\\tposition =  vec3( nyanpos, z );\\n\\t\\t\\tspec = 0.5;\\n\\t\\t\\tnyanhit = true;\\n\\t\\t}\\n\\t}\\n\\t\\t\\n\\tvec3 diffcolor = vec3(0.6);\\n\\tretcolor = diffcolor*color*AMBIANT * dot( normalize( -vec3( 0.8, -0.8, 1.0 ) ), normal );\\n\\t\\n\\t// dynamic lights\\n\\n\\tfloat specfactor = time/INTERVALSPECULARCOLOR;\\n\\tvec3 speccolor = normalize( mix( hash3( floor( specfactor ) ), hash3( floor( specfactor+1. ) ), fract( specfactor ) ) );\\n\\t\\n\\tfloat totalwidth = 40.;\\n\\tvec3 rd = normalize( vec3( coord, 0.1 ) );\\n\\t\\n\\tfor( int i=0; i<NUMBERLIGHTS; i++) {\\n\\t\\tfloat lx = mod( float(i)*totalwidth/float(NUMBERLIGHTS)-offset, totalwidth)-totalwidth/2.;\\n\\t\\tvec3 loffset = vec3( 1.5*sin(time*2.+float(i)), 4.4*cos(time*1.3+float(i)), 3.*sin(time*0.9+float(i)) );\\n\\n\\t\\tvec3 lpos = vec3( lx, 5., 4.5 ) + loffset;\\n\\t\\tvec3 lvec = lpos - position;\\n\\t\\t\\n\\t\\tfloat llig = dot( lvec, lvec);\\n\\t\\tfloat im = inversesqrt( llig );\\n\\t\\tlvec = im * lvec;\\n\\t\\t\\n\\t\\t// diffuse\\n\\t\\tfloat diff = DYNAMICLIGHTSTRENGTH * clamp( dot( lvec, normal ), 0., 1.);\\t\\n\\t\\t// specular\\t\\t\\n\\t\\tfloat specu = clamp( dot( reflect(rd,normal), lvec ), 0.0, 1.0 );\\n\\t\\tspecu = 40. * DYNAMICLIGHTSTRENGTH * spec * (pow(specu,16.0) + 0.5*pow(specu,4.0));\\n\\t\\t\\n\\t\\tretcolor += speccolor * color * (diff+specu) / llig;\\n\\t}\\n\\n\\tif( !nyanhit ) {\\n\\t\\tfloat ao = length(position- vec3( -3.5, 1.3, 6.));\\n\\t\\tretcolor *= clamp( ao*0.4, 0., 1.);\\n\\t}\\n\\t\\n\\treturn retcolor;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    float time = iTime + 259.;\\n\\tvec2 q = fragCoord.xy/iResolution.xy;\\n\\tvec2 p = -1.0+2.0*q;\\n\\tp.x *= iResolution.x/iResolution.y;\\n\\t\\n\\tdirtFactor = 0.4+0.2*sin(time/INTERVALDIRT+1.6);\\n\\t\\n\\tvec3 color = getColor( p, time );\\n\\tcolor = pow( 0.7*color, vec3(EXPOSURE) );\\t\\n    // vigneting\\n    color *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\\n\\t\\n\\tfragColor = vec4( color, 1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sfGR7","date":"1365161571","viewed":5438,"name":"Abandoned base on Mars","description":"Complete rewrite of old shader.\\nYou're exploring an abandoned base on Mars. The base is covered with dirt.\\nShader shows procedural levels and materials, a doom-like pseudo 3d-engine, dynamics lights & shadows, bumpmapping, specular maps and reflections.","likes":43,"published":"Public API","usePreview":0,"tags":["raycasting","procedurallevel","proceduralmaterial"]},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Abandoned base on Mars. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4sfGR7\\n//\\n\\n#define DIRT\\n#define DYNAMICLIGHTNING\\n//#define SHADOWS\\n//#define REFLECTION\\n\\n#define ROOMSIZE 10.\\n#define PORTALSIZE 1.5\\n#define PORTALHEIGHT 3.0\\n\\n// seconds needed to walk through room\\n#define WALKINGSPEED 3.\\n\\n#define MAXDISTANCE 1000.\\n#define MAXMATERIALS 1000.\\n\\n#define EXPOSURE 2.3\\n#define AMBIANT 2.2\\n#define DYNAMICLIGHTSTRENGTH 7.\\n#define PI 3.1415926\\n\\n#define NUMBEROFLIGHTS 2\\n\\nfloat dirtFactor;\\n\\n//\\n// math functions\\n//\\n\\nconst mat2 mr = mat2 (0.84147,  0.54030,\\n\\t\\t\\t\\t\\t  0.54030, -0.84147 );\\nfloat hash( float n ) {\\n\\treturn fract(sin(n)*43758.5453);\\n}\\nvec2 hash2( float n ) {\\n    return fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\\n}\\n\\nvec3 hash3( float n ) {\\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\\n}\\nfloat noise(in float x) {\\n\\tfloat p = floor(x);\\n\\tfloat f = fract(x);\\n\\t\\t\\n\\tf = f*f*(3.0-2.0*f);\\t\\n\\treturn mix( hash(p+  0.0), hash(p+  1.0),f);\\n}\\nfloat noise( in vec2 x )\\n{\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\\n\\treturn textureLod( iChannel1, (uv+118.4)/256.0, 0.0 ).x;\\n}\\nfloat fbm( vec2 p ) {\\n\\tfloat f;\\n\\tf  =      0.5000*noise( p ); p = mr*p*2.02;\\n\\tf +=      0.2500*noise( p ); p = mr*p*2.33;\\n\\tf +=      0.1250*noise( p ); p = mr*p*2.01;\\n\\tf +=      0.0625*noise( p ); p = mr*p*2.01;\\n\\treturn f/(0.9175);\\n}\\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\\nfloat crossp( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\\n\\n//\\n// intersection functions\\n//\\n\\nvoid intersectPlane(const vec3 ro, const vec3 rd, const float height, out float dist) {\\t\\n\\tdist = MAXDISTANCE;\\n\\tif (rd.y==0.0) {\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(MAXDISTANCE, d);\\n\\tif( d > 0. ) {\\n\\t\\tdist = d;\\n\\t}\\n}\\n\\nvoid intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\\n\\tdist = MAXDISTANCE;\\n\\tvec2 p = ro.xz;\\n\\tvec2 r = rd.xz;\\n\\tvec2 q = a-p;\\n\\tvec2 s = b-a;\\n\\tfloat rCrossS = crossp(r, s);\\n\\t\\n\\tif( rCrossS == 0.){\\n\\t\\treturn;\\n\\t}\\n\\tfloat t = crossp(q, s) / rCrossS;\\n\\tu = crossp(q, r) / rCrossS;\\n\\t\\n\\tif(0. <= t && 0. <= u && u <= 1.){\\n\\t\\tdist = t;\\n\\t}\\n}\\n\\n//\\n// material functions\\n//\\n\\nfloat matfhf, matflf;\\nfloat matnoisehf;\\nvec3 math3;\\n\\nvoid materialInit(in float seed, const vec2 coord) {\\n\\tmatfhf = fbm( coord * 171. );\\n\\tmatflf = fbm( coord );\\n\\tmatnoisehf = noise( coord * 193. );\\n\\tmath3  = hash3( seed * 11. );\\n}\\n\\nvec3 materialBaseColor( float t ) {\\n\\treturn textureLod( iChannel0, vec2(1.1459123*t,2.3490423*t), 0. ).xyz;\\n}\\n\\nvoid materialDirt(  vec2 coord, out vec3 color, out vec2 normal ) {\\n\\tcolor = vec3( 0.7, 0.5, 0.4 ) * (0.75*matfhf+0.25);\\n\\tnormal = vec2( matnoisehf*2. -1. );\\n}\\n\\nvec2 materialGrooves( float seed, bool iswall ) {\\n\\tvec2 math2 = hash2( seed );\\n\\tif( iswall ) return clamp( floor(math2*6.) * 0.125 - 0.25, vec2(0.), vec2(1.));\\n\\treturn clamp( floor( math2*4.) * 0.125, vec2(0.), vec2(1.));\\n}\\n\\nfloat grooveHeight( float l, float w, float p ) {\\n\\tif( l == 0. ) return 1.;\\n\\treturn smoothstep( l, (l-w), abs(2.*mod(p, l)-l) );\\n}\\n\\nfloat materialHeightMap( vec2 grooves, vec2 coord ) {\\n\\treturn min( grooveHeight( grooves.x, 0.01, coord.x ), grooveHeight( grooves.y, 0.01, coord.y ));\\n}\\n\\nfloat materialDirtAmount( vec2 grooves, vec2 coord ) {\\n\\tvec2 f = mix( vec2(0.01), grooves*2., dirtFactor );\\n\\treturn 1. - 0.5*min( grooveHeight( grooves.x, f.x, coord.x ), grooveHeight( grooves.y, f.y, coord.y ));\\n}\\n\\n// calculate color\\n\\nvoid getMaterial( float seed, vec2 coord, vec2 grooves,  bool isfloor, bool iswall, \\n\\t\\t\\t  \\t  out vec3 color, out vec2 normal, out float spec ) {\\n\\n\\tfloat height = materialHeightMap( grooves, coord );\\t\\n\\tnormal.x = (height-materialHeightMap( grooves, coord-vec2(0.002,0.) )) * 500.;\\n\\tnormal.y = (height-materialHeightMap( grooves, coord-vec2(0.,0.002) )) * 500.;\\n\\tnormal += (0.2 * fract( math3.y * 1.64325 )) * (vec2( matfhf, matnoisehf ) - vec2(0.5));\\n\\t\\n\\tspec = (height + 4.*matfhf )*0.1*fract( math3.x * 1.13 )*matflf;\\n\\t\\n\\tvec3 color1 = materialBaseColor( seed ); \\t\\n\\tvec3 color2 = materialBaseColor( seed*2.6345 ); \\t\\n\\n\\t// checkboard ?\\n\\tbool checkx = grooves.x > 0. && mod( coord.x, grooves.x*2. ) < grooves.x;\\n\\tbool checky = grooves.y > 0. && mod( coord.y, grooves.y*2. ) < grooves.y;\\n\\t\\n\\tif( fract( math3.z * 4.435 ) < 0.5 && ((checkx && checky) || (!checkx && !checky)) ) {\\n\\t\\tcolor = mix( color2, color1, matflf*fract(math3.y*45.234) );\\n\\t} else {\\t\\t\\n\\t\\tcolor = mix( color1, color2, matflf*fract(math3.y*45.234) );\\n\\t}\\n\\t\\n\\tcolor *= (0.4+0.6*height+0.2*fract( math3.x*3.76 )*matfhf);\\n\\t\\t\\n#ifdef DIRT\\t\\n\\tif( dirtFactor > 0.1 ) { // dirt\\n\\t\\tvec2 dirtNormal; vec3 dirtColor;\\t\\t\\n\\t\\tmaterialDirt( coord, dirtColor, dirtNormal );\\n\\t\\t\\n\\t\\tfloat dirtAmount = materialDirtAmount( grooves, coord );\\t\\n\\n\\t\\tif( iswall ) {\\n\\t\\t\\tdirtAmount += clamp( dirtFactor - coord.y, -dirtAmount, 1.);\\n\\t\\t} else\\tif( !isfloor ) {\\n\\t\\t\\tdirtAmount *= 0.5; // less dirt on ceiling\\n\\t\\t}\\n\\t\\n\\t\\tfloat dirtMix = clamp( 10. * (0.5* (dirtAmount * matflf + matfhf ) - (1.-dirtFactor)), 0., 1.);\\n\\t\\n\\t\\tif( dirtFactor > 0.1 ) {\\n\\t\\t\\tcolor = mix( color, dirtColor, dirtMix );\\n\\t\\t\\tspec *= 1. - dirtMix;\\n\\t\\t\\tnormal = mix( normal, dirtNormal, dirtMix );\\n\\t\\t}\\n\\t}\\n#endif\\n}\\n\\nvoid getWallMaterial( float seed, vec2 coord,  \\n\\t\\t\\t\\t\\t  out vec3 color, out vec2 normal, out float spec ) {\\n\\tcoord *= 0.25;\\t\\n\\tmaterialInit( seed, coord );\\n\\t\\n\\tfloat s = mod( floor( math3.y*13.4361 ), 8. ) * 0.125;\\n\\t\\n\\tfloat wseed = seed;\\n\\tif( coord.y > s ) wseed += 1.;\\t\\n\\n\\tvec2 grooves = materialGrooves( wseed, true );\\n\\n\\tgetMaterial( seed, coord, vec2(grooves.x, max( grooves.y, s )), false, true, color, normal, spec );\\n}\\n\\nvoid getFloorMaterial( float seed, vec2 coord, bool isfloor,  \\n\\t\\t\\t\\t\\t   out vec3 color, out vec2 normal, out float spec ) {\\n\\t\\n\\tcoord *= 0.25;\\t\\n\\tmaterialInit( seed, coord );\\n\\tvec2 grooves = materialGrooves( seed, false );\\n\\n\\tgetMaterial( seed, coord, grooves, isfloor, false, color, normal, spec );\\n}\\n\\n//\\n// level creation\\n//\\n\\nvec3 portalPlacements; // t=-1, t=0, t=1\\nbool inRoom;\\nfloat currentSeed, currentSeedFract, roomSeed;\\nvec3 ambiantLight;\\nvec2 pillarPosition;\\nfloat pillarAngle, roomHeight;\\nvec2 roommorph;\\nvec3 roomoffset;\\n\\n\\n//\\n// Initialization\\n//\\n\\nvoid init( float t ) {\\n\\tfloat seed =  t / WALKINGSPEED;\\n\\tcurrentSeedFract = fract( seed );\\t\\n\\tcurrentSeed = floor( seed );\\t\\n\\tinRoom = mod( currentSeed, 2. ) < 1.;\\n\\n\\t// dirt in base\\n\\tdirtFactor = 0.4+0.2*cos(iTime*0.05+0.5);\\n\\t\\n\\t// possible values: 0., 1., 2., 3. (n,e,s,w)\\n\\tportalPlacements = floor( mod( vec3( \\n\\t\\tnoise(currentSeed*0.25-0.25), noise(currentSeed*0.25-0.0), noise(currentSeed*0.25+0.25) )*4., vec3(4.) ) );\\t\\n\\t\\n\\tambiantLight = mix( materialBaseColor( currentSeed ), materialBaseColor( currentSeed+1. ), currentSeedFract );\\n\\tambiantLight = normalize( ambiantLight+vec3(0.5) );\\n\\n\\troomSeed = (currentSeed+(inRoom?0.:1.));\\n\\troommorph = 0.5*hash2( roomSeed ) + vec2( 0.5 );\\n\\tpillarPosition = (vec2(-0.7)+1.4*hash2( roomSeed*11. ))*(ROOMSIZE*roommorph);\\n\\tpillarAngle = hash( roomSeed )*6.;\\n\\troomHeight = PORTALHEIGHT+PORTALHEIGHT*2.*hash(roomSeed);\\n}\\n\\n//\\n// Render level\\n//\\n\\nvec2 avoidPillar( in vec2 position ) {\\n\\tvec2  v = position - pillarPosition;\\n\\tfloat d = length(v);\\n\\tif( d < 1.5 ) {\\n\\t\\tposition += (1.5-d)*normalize(v);\\n\\t}\\n\\treturn position;\\n}\\n\\nvoid traceRoom( bool inside, float seed, bool isroom, vec3 roo, vec3 rd,\\n\\t\\t\\t\\tout float dist, out vec3 color, out vec3 normal, out vec3 bumpnormal, out float spec) {\\n\\t\\n\\tfloat p1, p2;\\n\\tdist = MAXDISTANCE;\\n\\tvec3 offset;\\n\\t\\t\\n\\tcolor = normal = bumpnormal = vec3(0.); spec = 0.;\\n\\t\\n\\tif( inside ) {\\n\\t\\tp1 = mod( portalPlacements[0]+2., 4.); // enter room this side\\n\\t\\tp2 = portalPlacements[1]; // leaving room this side\\n\\t\\toffset = vec3(0.);\\n\\t} else {\\n\\t\\t// if you're not inside this room, calculate offset of room\\n\\t\\tseed += 1.;\\n\\t\\tp1 = portalPlacements[1]; // enter room this side\\n\\t\\toffset = 2.*vec3( p1==1.?ROOMSIZE:p1==3.?-ROOMSIZE:0., 0., p1==0.?ROOMSIZE:p1==2.?-ROOMSIZE:0. );\\n\\t\\tp1 = mod( p1+2., 4.); // enter room this side\\n\\t\\tp2 = portalPlacements[2]; // leaving room this side\\n\\t}\\n\\n\\tbool hitfloor;\\n\\n\\tvec3 ro = roo - offset;\\t\\n\\tvec3 t1, t2, hitnormal;\\n\\tvec2 hittex;\\n\\tfloat d, hitmaterial;\\n\\t\\n\\t// intersect with floor and ceiling\\n\\tt1 = vec3( -1., 0., 0. );\\n\\tt2 = vec3( 0., 0., -1. );\\n\\n\\t// floor\\t\\t\\n\\tintersectPlane( ro, rd, 0.0, d );\\n\\tif( d < dist && all( lessThan( abs( (ro+d*rd).xz), vec2(ROOMSIZE)))) {\\n\\t\\tdist = d;\\n\\t\\thitmaterial\\t= mod(seed*124.565431, MAXMATERIALS); // procedural foor material\\n\\t\\thitnormal = vec3( 0., 1., 0.);\\n\\t\\thitfloor = true;\\n\\t\\thittex = (rd*dist+ro).xz;\\n\\t}\\n\\t// ceiling\\n\\tintersectPlane( ro, rd, isroom?roomHeight:PORTALHEIGHT, d );\\n\\tif( d < dist && all( lessThan( abs( (ro+d*rd).xz), vec2(ROOMSIZE)))) {\\n\\t\\tdist = d;\\n\\t\\thitmaterial\\t= mod(seed*131.565431, MAXMATERIALS); // procedural foor material\\n\\t\\thitnormal = vec3( 0., -1., 0.);\\n\\t\\thitfloor = false;\\n\\t\\thittex = (rd*dist+ro).xz;\\n\\t}\\n\\n\\tvec2 hits, hite, s, e;\\n\\tfloat u, hitu = -1.;\\n\\t\\n\\tif(\\tisroom ) {\\n\\t\\troomoffset = offset;\\n\\t\\t\\n\\t\\t// the walls, check for each side of room...\\n\\t\\tfor( int i=0; i<4; i++ ) {\\n\\t\\t\\tif( i == 0 ) {\\n\\t\\t\\t\\ts = vec2( -ROOMSIZE, ROOMSIZE )*roommorph;\\n\\t\\t\\t\\te = abs(s); //vec2( ROOMSIZE, ROOMSIZE )*roommorph;\\n\\t\\t\\t} else if( i == 1 ) {\\n\\t\\t\\t\\te = vec2( ROOMSIZE, -ROOMSIZE )*roommorph;\\n\\t\\t\\t\\ts = abs(e); //vec2( ROOMSIZE, ROOMSIZE )*roommorph;\\n\\t\\t\\t} else if( i == 2 ) {\\n\\t\\t\\t\\te = vec2( -ROOMSIZE, -ROOMSIZE )*roommorph;\\n\\t\\t\\t\\ts = e; e.x = -e.x; //vec2( ROOMSIZE, -ROOMSIZE )*roommorph;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts = vec2( -ROOMSIZE, -ROOMSIZE )*roommorph;\\n\\t\\t\\t\\te = s; e.y=-e.y;//vec2( -ROOMSIZE, ROOMSIZE )*roommorph;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif( float(i) != p1 && float(i) != p2  ) { // normal wall\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tintersectSegment( ro, rd, s, e, d, u );\\n\\t\\t\\t\\tif( d < dist ) { dist = d; hitu = u; hits = s; hite = e; }\\n\\n\\t\\t\\t} else { // three walls with portal\\n\\t\\t\\t\\tvec2 sp, ep;\\n\\t\\t\\t\\tif( i == 0 ) {\\n\\t\\t\\t\\t\\tsp = vec2( -PORTALSIZE, ROOMSIZE );\\n\\t\\t\\t\\t\\tep = vec2( PORTALSIZE, ROOMSIZE );\\n\\t\\t\\t\\t} else if( i == 1) {\\n\\t\\t\\t\\t\\tsp = vec2( ROOMSIZE, PORTALSIZE );\\n\\t\\t\\t\\t\\tep = vec2( ROOMSIZE, -PORTALSIZE );\\n\\t\\t\\t\\t} else if( i == 2) {\\n\\t\\t\\t\\t\\tsp = vec2( -PORTALSIZE, -ROOMSIZE );\\n\\t\\t\\t\\t\\tep = vec2( PORTALSIZE, -ROOMSIZE );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tsp = vec2( -ROOMSIZE, -PORTALSIZE );\\n\\t\\t\\t\\t\\tep = vec2( -ROOMSIZE, PORTALSIZE );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tintersectSegment( ro, rd, s, sp, d, u );\\n\\t\\t\\t\\tif( d < dist ) { dist = d; hitu = u; hits = s; hite = sp; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tintersectSegment( ro, rd, ep, e, d, u );\\n\\t\\t\\t\\tif( d < dist ) { dist = d; hitu = u; hits = ep; hite = e; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// portal!\\n\\t\\t\\t\\tintersectSegment( ro, rd, sp, ep, d, u );\\n\\t\\t\\t\\tif( d < dist && (rd.y*d+ro.y > PORTALHEIGHT) ) { \\n\\t\\t\\t\\t\\tdist = d; hitu = u; hits = sp; hite = ep;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else { \\n\\t\\t// we are in a portal; check walls:\\t\\t\\n\\t\\tfloat totalu = 2.0 * ROOMSIZE;\\n\\t\\tif( mod( p1, 2.) == mod( p2, 2.) ) {\\n\\t\\t\\t// straight\\t\\n\\t\\t\\n\\t\\t\\tvec2 ps, pw;\\n\\t\\t\\tif( p1==0. || p1==2.) {\\n\\t\\t\\t\\tps = vec2( 0., ROOMSIZE );\\n\\t\\t\\t\\tpw = vec2( PORTALSIZE, 0. );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tps = vec2( ROOMSIZE, 0. );\\n\\t\\t\\t\\tpw = vec2( 0., PORTALSIZE );\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tvec2 o2, o1 = vec2(0.); \\n\\t\\t\\tfor( int j=0; j<6; j++ ) {\\n\\t\\t\\t\\tif( j!=5 ) o2 = hash2(float(j)); else o2 = vec2(0.);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ts = o1+pw+ps*(1.-float(j)/3.);\\n\\t\\t\\t\\te = o2+pw+ps*(1.-float(j+1)/3.);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tintersectSegment( ro, rd, s, e, d, u );\\n\\t\\t\\t\\tif( d < dist ) { dist = d; hitu = totalu+u; hits = s; hite = e; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\te = o1-pw+ps*(1.-float(j)/3.);\\n\\t\\t\\t\\ts = o2-pw+ps*(1.-float(j+1)/3.);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tintersectSegment( ro, rd, s, e, d, u );\\n\\t\\t\\t\\tif( d < dist ) { dist = d; hitu = totalu-u; hits = s; hite = e; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\to1=o2;\\n\\t\\t\\t\\ttotalu += distance( e, s );\\n\\t\\t\\t}\\t\\t\\n\\t\\t} else {\\n\\t\\t\\t// curved\\n\\t\\t\\tfloat a; vec2 o;\\n\\t\\t\\tif( min(p1, p2) == 0. ) {\\n\\t\\t\\t\\tif( max(p1, p2) == 1. ) {\\n\\t\\t\\t\\t\\ta = PI * 0.5; o = vec2( ROOMSIZE, ROOMSIZE );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ta = PI * 0.0; o = vec2( -ROOMSIZE, ROOMSIZE );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if( min(p1, p2) == 1. ) {\\n\\t\\t\\t\\ta = PI * 1.0; o = vec2( ROOMSIZE, -ROOMSIZE );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta = PI * 1.5; o = vec2( -ROOMSIZE, -ROOMSIZE );\\n\\t\\t\\t}\\n\\t\\t\\tfloat da = 0.5 * PI / 6.;\\n\\t\\t\\tfor( int j=0; j<6; j++ ) {\\n\\t\\t\\t\\tfloat si = sin(a); float co = cos(a);\\n\\t\\t\\t\\tfloat ds = sin(a+da); float dc = cos(a+da);\\n\\t\\t\\t\\ta+=da;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ts = o+vec2( (ROOMSIZE+PORTALSIZE)*co , -(ROOMSIZE+PORTALSIZE)*si );\\n\\t\\t\\t\\te = o+vec2( (ROOMSIZE+PORTALSIZE)*dc, -(ROOMSIZE+PORTALSIZE)*ds);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tintersectSegment( ro, rd, s, e, d, u );\\n\\t\\t\\t\\tif( d < dist ) { dist = d; hitu = totalu+u; hits = s; hite = e; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\te = o+vec2( (ROOMSIZE-PORTALSIZE)*co , -(ROOMSIZE-PORTALSIZE)*si );\\n\\t\\t\\t\\ts = o+vec2( (ROOMSIZE-PORTALSIZE)*dc, -(ROOMSIZE-PORTALSIZE)*ds);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tintersectSegment( ro, rd, s, e, d, u );\\n\\t\\t\\t\\tif( d < dist ) { dist = d; hitu = totalu-u; hits = s; hite = e; }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\ttotalu += distance( e, s );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n\\tif(\\tisroom ) {\\t\\t\\t\\n\\t\\t// pillar\\t\\n\\t\\tfor( int i=0; i<4; i++ ) {\\n\\t\\t\\tfloat angle = float(i)*PI*0.5+pillarAngle;\\n\\t\\t\\ts = vec2( cos( angle ), sin( angle ) ) + pillarPosition; \\n\\t\\t\\te = vec2( cos( angle+PI*0.5 ), sin( angle+PI*0.5 ) ) + pillarPosition;\\n\\t\\t\\t\\t\\n\\t\\t\\tintersectSegment( ro, rd, s, e, d, u );\\n\\t\\t\\tif( d < dist ) { dist = d; hitu = u; hits = s; hite = e; }\\n\\t\\t}\\n\\t}\\n\\t\\n\\tif( dist >= MAXDISTANCE ) {\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\t// calculate color for material\\n\\t\\n\\tvec2 ntangent;\\n\\t\\n\\tif( hitu >= 0. ) {\\n\\t\\tvec2 sme = hits-hite;\\n\\t\\tfloat lt = length(sme);\\n\\t\\thittex.x = lt*hitu;\\n\\t\\thittex.y = (ro+rd*dist).y; \\n\\t\\thitnormal = normalize( vec3( -sme.y, 0., sme.x ));\\n\\t\\tt2 = vec3( 0., -1., 0. );\\n\\t\\tt1 = cross( hitnormal, t2 );\\n\\n\\t\\tgetWallMaterial( mod(seed*14.1565431, MAXMATERIALS),\\n\\t\\t\\t\\t\\t\\thittex, color, ntangent, spec );\\t\\n\\t} else {\\n\\t\\tgetFloorMaterial( hitmaterial, hittex, hitfloor,\\n\\t\\t\\t\\t \\t\\t  color, ntangent, spec );\\n\\t}\\n\\t\\n\\tnormal = hitnormal;\\n\\tbumpnormal = normalize( (normal + ntangent.x*t1) + ntangent.y*t2 );\\n}\\n\\n\\nbool traceShadow( vec3 roo, vec3 rd, float maxdist ) { \\t\\n\\n\\tfloat u, d = MAXDISTANCE;\\n\\tvec3 ro = roo - roomoffset;\\n\\tvec2 e, s;\\n\\t\\n\\tfor( int i=0; i<4; i++ ) {\\n\\t\\t\\tfloat angle = float(i)*PI*0.5+pillarAngle;\\n\\t\\t\\ts = vec2( cos( angle ), sin( angle ) ) + pillarPosition; \\n\\t\\t\\te = vec2( cos( angle+PI*0.5 ), sin( angle+PI*0.5 ) ) + pillarPosition;\\n\\t\\t\\t\\t\\n\\t\\t\\tintersectSegment( ro, rd, s, e, d, u );\\n\\t\\t\\tif( d < maxdist ) return true;\\n\\t\\t}\\n\\treturn false;\\n}\\n\\nfloat trace( vec3 roo, vec3 rd, out vec3 color, out vec3 normal, out float spec ) {\\t\\n\\tnormal = color = vec3( 0. );\\n\\tvec3 matcolor, bumpnormal, hitcolor, hitnormal, hitbumpnormal;\\n\\tfloat dist = MAXDISTANCE, d, hitspec;\\t\\n\\t\\n\\t// trace room\\n\\ttraceRoom( inRoom, currentSeed, true, roo, rd, dist,\\n\\t\\t\\t\\t matcolor, normal, bumpnormal, spec);\\n\\t// trace portal\\n\\ttraceRoom( !inRoom, currentSeed, false, roo, rd, d,\\n\\t\\t\\t\\t  hitcolor, hitnormal, hitbumpnormal, hitspec);\\n\\tif( d < dist ) {\\n\\t\\tdist = d;\\n\\t\\tmatcolor = hitcolor; normal = hitnormal; bumpnormal = hitbumpnormal; spec = hitspec;\\n\\t}\\n\\n\\tvec3 intersection  = roo + rd*dist;\\n\\t\\n\\t// lightning\\n\\tcolor = (matcolor*ambiantLight)*(AMBIANT*(0.7 + 0.4*clamp( dot(bumpnormal, normalize( vec3( 0.2, 0.3, 0.5) ) ), 0., 1.)));\\n\\tcolor *= clamp( 7.5/dist, 0., 1.);\\n\\t\\n\\tvec3 offset = roomoffset + vec3( 0., 0.5*roomHeight, 0. );\\n\\t\\n#ifdef DYNAMICLIGHTNING\\t\\n\\tfor( int i=0; i<NUMBEROFLIGHTS; i++ ) {\\t\\n\\t\\tfloat fi = float(i); \\n\\t\\tvec3 lightcolor = hash3( roomSeed+float(i*643) );\\n\\t\\t\\n\\t\\tvec3 lightpos = (lightcolor*vec3(0.8*ROOMSIZE*roommorph.x,0.5*roomHeight,0.8*ROOMSIZE*roommorph.y)*\\n\\t\\t\\t\\t\\t\\t\\t\\t cos((2.*(fi+iTime))*lightcolor ))+offset;\\n\\t\\tvec3 lightvec = lightpos-intersection;\\n\\t\\t\\n\\t\\tif( dot( lightvec, normal ) < 0. ) continue;\\n\\t\\t\\n\\t\\tfloat l = length( lightvec );\\n\\t\\tvec3 nlightvec = lightvec * (1./l);\\n\\t\\t\\n\\t\\t// diffuse\\n\\t\\tfloat diff = DYNAMICLIGHTSTRENGTH * clamp( dot( nlightvec, bumpnormal ), 0., 1.);\\t\\n\\t\\t\\n#ifndef REFLECTION\\t\\t\\n\\t\\t// specular\\t\\t\\n\\t\\tfloat specu = clamp( dot( reflect(rd,bumpnormal), nlightvec ), 0.0, 1.0 );\\n\\t\\tspecu = 20. * DYNAMICLIGHTSTRENGTH * spec * (pow(specu,16.0) + 0.5*pow(specu,4.0));\\n#endif\\n\\t\\t\\n#ifdef SHADOWS\\t\\t\\n\\t\\tif( !traceShadow( nlightvec*0.001+intersection, nlightvec, l ) )\\n#endif\\n#ifdef REFLECTION\\t\\t\\t\\n\\t\\t\\tcolor += matcolor*lightcolor*(diff / (l*l));\\t\\t\\n#else\\n\\t\\t\\tcolor += matcolor*lightcolor*((diff+specu) / (l*l));\\n#endif\\n\\t}\\n#endif\\n\\t\\n\\tnormal = bumpnormal;\\n\\treturn dist;\\n}\\n\\n//\\n// Camera path\\n//\\n\\nvec3 initCamera( float f ) {\\t\\n\\tfloat p1 = mod( portalPlacements[0]+2., 4.);\\n\\tfloat p2 = portalPlacements[1];\\n\\tfloat mf = 1.-f;\\n\\t\\n\\tif( mod( p1, 2.) == mod( p2, 2.) ) {\\n\\t\\t// straight\\t\\n\\t\\tvec3 cam;\\n\\t\\tif( p1==0.) {\\n\\t\\t\\tcam.xy = vec2( 0., ROOMSIZE-f*ROOMSIZE*2. );\\n\\t\\t} else if( p1==1.) {\\n\\t\\t\\tcam.xy = vec2(  ROOMSIZE-f*ROOMSIZE*2., 0. );\\n\\t\\t} else if( p1==2.) {\\n\\t\\t\\tcam.xy = vec2( 0., -ROOMSIZE+f*ROOMSIZE*2. );\\n\\t\\t} else {\\n\\t\\t\\tcam.xy = vec2( -ROOMSIZE+f*ROOMSIZE*2., 0. );\\n\\t\\t}\\n\\t\\tcam.z = (p2==1.)?0.5*PI:(p2==2.)?PI:(p2==3.)?PI*1.5:0.;\\n\\t\\t\\n\\t\\treturn cam;\\n\\t} else {\\n\\t\\t// curved\\n\\t\\tfloat a, an; vec2 o; \\n\\t\\tif( min(p1, p2) == 0. ) {\\n\\t\\t\\tif( max(p1, p2) == 1. ) {\\n\\t\\t\\t\\ta = PI * 0.5; o = vec2( ROOMSIZE, ROOMSIZE );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta = PI * 0.0; o = vec2( -ROOMSIZE, ROOMSIZE );\\n\\t\\t\\t}\\n\\t\\t} else if( min(p1, p2) == 1. ) {\\n\\t\\t\\ta = PI * 1.0; o = vec2( ROOMSIZE, -ROOMSIZE );\\n\\t\\t} else {\\n\\t\\t\\ta = PI * 1.5; o = vec2( -ROOMSIZE, -ROOMSIZE );\\n\\t\\t}\\n\\t\\tif( mod(p1+1.,4.) == p2) f=mf;\\n\\t\\t\\n\\t\\tif( mod(p1+1.,4.) == p2) { // counter clockwise\\n\\t\\t\\tan = f*0.5*PI+(p1)*PI*0.5;\\n\\t\\t} else {\\n\\t\\t\\tan = f*0.5*PI+(p1+1.)*PI*0.5;\\n\\t\\t}\\n\\t\\t\\n\\t\\ta += f*PI*0.5;\\n\\t\\tfloat s = sin(a); float c = cos(a);\\n\\t\\treturn vec3(o, an+0.5*PI)+vec3( c*ROOMSIZE, -s*ROOMSIZE, 0.);\\n\\t}\\n\\treturn vec3(0.);\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy/iResolution.xy;\\n\\tvec2 p = -1.0+2.0*q;\\n\\tp.x *= iResolution.x/iResolution.y;\\n\\t\\n\\tinit( iTime+1.5 );\\n\\t\\t\\n\\tvec3 camPosition = initCamera( currentSeedFract );\\n\\tif(inRoom) camPosition.xy = avoidPillar( camPosition.xy );\\n\\t\\n\\tvec3 ro = vec3( camPosition.x, 1.6+0.03*sin(iTime*6.), camPosition.y );\\n\\tvec3 ta = rotate( vec3(0.0, 0.0, 1.0), camPosition.z + 0.3*sin(iTime) );\\n\\t\\t\\n\\tfloat roll = 0.13*sin(camPosition.z + 0.13*iTime);\\n\\t\\n\\t// camera tx\\n\\tvec3 cw = normalize( ta );\\n\\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n\\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\\n\\n\\t\\n\\t\\n\\tvec3 color, normal;\\n\\tfloat spec, dist;\\n\\tdist = trace( ro, rd, color, normal, spec );\\n\\n#ifdef REFLECTION\\n\\tif( spec > 0.0) {\\n\\t\\tvec3 speccolor = vec3(0.);\\n\\t\\tfloat refspec;\\n\\t\\tvec3 refl = normalize(reflect( rd, normal ));\\n\\t\\tdist = trace( ro+rd*dist+refl*0.001, refl, speccolor, normal, refspec );\\t\\n\\t\\t//dist = trace( ro, rd, speccolor, normal, refspec );\\t\\t\\t\\t\\n\\t\\tcolor += spec*speccolor;\\n\\t}\\n#endif\\n\\t\\n\\tcolor = pow( color, vec3(EXPOSURE) );\\n\\t\\n    // vigneting\\n    color *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\\n\\t\\n\\tfragColor = vec4( clamp(color, 0., 1.),1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Mdf3zM","date":"1365959156","viewed":15949,"name":"Escher's prentententoonstelling","description":"I found this article: http://www.ams.org/notices/200304/fea-escher.pdf describing the transformation used by Escher in the droste-picture: de prentententoonstelling (the picture gallery). The source is a mess atm - I will clean up later.","likes":156,"published":"Public API","usePreview":0,"tags":["distancefields","domain","droste","escher","transformation","reproduction"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Escher's prentententoonstelling. Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/Mdf3zM\\n//\\n// Study of the transformation of Escher in 'the prentententoonstelling' \\n// \`\`\`\\n// h(w) = w^((2i + log scale)/(2i))\\n// \`\`\`\\n// Distance field functions by Inigo Quilez.\\n//\\n// [1] http://www.ams.org/notices/200304/fea-escher.pdf\\n//\\n\\n// #define SHADOW\\n#define WOBBLE\\n\\nfloat t;\\n\\nfloat st = 0., zt = 0.;\\n\\nfloat deformationScale, zoom;\\n\\nvec2 escherDeformation( in vec2 uv ) {\\n\\t\\n// http://www.ams.org/notices/200304/fea-escher.pdf\\n// h(w) = w^((2i + log scale)/(2i))\\n\\t\\n\\tfloat lnr = log(length(uv));\\n\\tfloat th = atan( uv.y, uv.x )+(0.4/256.)*deformationScale;\\n\\tfloat sn = -log(deformationScale)*(1./(2.*3.1415926));\\n\\tfloat l = exp( lnr - th*sn ); \\n\\t\\n\\tvec2 ret = vec2( l );\\n\\t\\n\\tret.x *= cos( sn*lnr+th );\\n\\tret.y *= sin( sn*lnr+th );\\n\\t\\t\\n\\treturn ret;\\n}\\n\\n#define drostescale 256.\\n\\nvec2 drosteTransformation( in vec2 uv ) {\\n\\tfor( int i=0; i<2; i++ ) {\\n\\t\\tif(any(greaterThan(abs(uv),vec2(1.)))) {\\n\\t\\t\\tuv *= (1./drostescale);\\n\\t\\t}\\t\\t\\n\\t\\tif(all(lessThan(abs(uv),vec2(1./drostescale)))) {\\n\\t\\t\\tuv *= drostescale;\\n\\t\\t}\\n\\t}\\n\\treturn uv;\\n}\\n\\nfloat hash( float n )\\n{\\n    return fract(sin(n)*43758.5453);\\n}\\n\\nfloat sdPlane( vec3 p ) {\\n\\treturn p.y+14.+0.05*cos(p.x+iTime*2.);\\n}\\n\\nfloat sdBox( vec3 p, vec3 b ) {\\n  vec3 d = abs(p) - b;\\n  return min(max(d.x,max(d.y,d.z)),0.0) +\\n         length(max(d,0.0));\\n}\\n\\nfloat udBox( vec3 p, vec3 b) {\\n  return length(max(abs(p)-b,0.0));\\n}\\nfloat sdTriPrism( vec3 p, vec2 h ) {\\n    vec3 q = abs(p);\\n    return max(q.x-h.y,max(q.z*0.4+p.y*0.5,-p.y)-h.x*0.5);\\n}\\n\\nfloat sdCylinderXY( vec3 p, vec2 h ) {\\n  return max( length(p.xy)-h.x, abs(p.z)-h.y );\\n}\\nfloat sdCylinderYZ( vec3 p, vec2 h ) {\\n  return max( length(p.yz)-h.x, abs(p.x)-h.y );\\n}\\nfloat sdCylinderXZ( vec3 p, vec2 h ) {\\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\\n}\\n\\n\\n//----------------------------------------------------------------------\\n\\nfloat opS( float d1, float d2 ) {\\n    return max(-d2,d1);\\n}\\nfloat opU( float d1, float d2 ) {\\n    return min(d2,d1);\\n}\\n\\nvec2 opU( vec2 d1, vec2 d2 ) {\\n\\treturn (d1.x<d2.x) ? d1 : d2;\\n}\\n\\nfloat opI( float d1, float d2 ) {\\n    return max(d1,d2);\\n}\\n\\n//----------------------------------------------------------------------\\n\\n\\nfloat objPrentenTentoonstelling( in vec3 pos ) {\\n\\tvec3 tpos;// = pos;\\n\\ttpos.x = min( abs(pos.x), abs(pos.z) );\\n\\ttpos.y = pos.y;\\n\\ttpos.z = max( abs(pos.x), abs(pos.z) );\\n\\t\\n\\tfloat res = opU(opU(opU(opU(opU(\\n\\t\\t\\topS(opS(opS( // main building\\n\\t\\t\\t\\topS(\\n\\t\\t\\t\\t\\tudBox( tpos, vec3( 5.5, 24.0, 5.5 ) ),\\n\\t\\t\\t\\t\\tsdBox( vec3(tpos.x, tpos.y-24.0, tpos.z), vec3( 5.25, 0.5, 5.25) ) \\n\\t\\t\\t\\t),\\n\\t\\t\\t\\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-21.5, tpos.z-5.), vec3( 1.,1.,4.) )\\n\\t\\t\\t),\\n\\t\\t\\t\\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-15.5, tpos.z-5.), vec3( 1.,2.,4.) )\\n\\t\\t\\t),\\n\\t\\t\\t\\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-17.5, tpos.z-5.), vec2( 1.,4.) )\\n\\t\\t\\t),\\n\\t\\t\\topI( // main building windows\\n\\t\\t\\t\\tudBox( tpos, vec3( 5.5, 23., 5.5 ) ),\\n\\t\\t\\t\\topU(\\n\\t\\t\\t\\t\\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-5.2), vec3( 0.05, 24., 0.05 ) ),\\n\\t\\t\\t\\t\\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-5.2), vec3( 10.0, 0.05, 0.05 ) )\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t),\\n\\t\\topS( // gallery\\n\\t\\t\\topU(opU(opU(\\t\\t\\n\\t\\t\\t\\topS(opS( \\n\\t\\t\\t\\t\\t\\tudBox( tpos, vec3( 8.375, 8.75, 8.375 ) ),\\n\\t\\t\\t\\t\\t\\tsdCylinderXY( vec3( mod(tpos.x, 2.75)-1.375, tpos.y-6.5, tpos.z-8.75), vec2( 1.25,2.75) )\\n\\t\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\tsdBox( vec3(  mod(tpos.x, 2.75)-1.375, tpos.y-4.5, tpos.z-8.75), vec3( 1.25,2.0,2.75) )\\t\\t\\t\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\tudBox(  vec3( mod(tpos.x-8.375/18., 8.375/9.)-8.375/18., tpos.y, tpos.z-8.3), vec3( 0.025, 8.5, 0.025 ) )\\n\\t\\t\\t),\\n\\t\\t\\t\\tudBox(  vec3( tpos.x, tpos.y-4.3, tpos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ) \\n\\t\\t\\t),\\n\\t\\t\\t\\tudBox(  vec3( tpos.x, tpos.y-6.3, tpos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ) \\n\\t\\t\\t),\\n\\t\\t\\topU(opU(opU(\\n\\t\\t\\t\\tsdCylinderYZ( vec3( pos.x-8.75, pos.y-6.5, mod(pos.z, 13.75)-6.875), vec2( 1.25,20.) ),\\n\\t\\t\\t\\tsdBox( vec3(  pos.x-8.75, pos.y-2.5, mod(pos.z,  13.75)-6.875), vec3( 20.,4.0,1.25) )\\t\\t\\t\\n\\t\\t\\t),\\n\\t\\t\\t\\tsdCylinderXY( vec3( mod(pos.x,13.75)-6.875, pos.y-6.5, pos.z-8.75), vec2( 1.25,20.) )\\n\\t\\t\\t),\\n\\t\\t\\t\\tsdBox( vec3(  mod(pos.x, 13.75)-6.875, pos.y-2.5, pos.z-8.75), vec3( 1.25,4.0,20.) )\\t\\n\\t\\t\\t)\\n\\t\\t) ),\\n\\t\\t\\tsdTriPrism( vec3(tpos.x, tpos.y-9.3, tpos.z-5.2), vec2(2.0, 10. ) ) // roof\\n\\t\\t),\\n\\t\\t\\tsdTriPrism( vec3(tpos.x, tpos.y-2.8, tpos.z-5.2), vec2(0.75, 8. ) )\\n\\t\\t),\\n\\t\\tudBox( tpos, vec3( 6.5, 2.5, 6.5 ) )\\n\\t);\\n\\t\\n\\treturn res;\\n}\\n\\nfloat objB1( in vec3 pos ) {\\n\\tfloat res =\\n\\t\\topU(opS(\\t\\t\\t\\n\\t\\t\\topS(\\n\\t\\t\\t\\tudBox( pos, vec3( 20., 30.0, 10. ) ),\\t\\t\\t\\t\\n\\t\\t\\t\\tsdBox( pos+vec3(0., -30., 0.), vec3( 19.75, 1., 9.75 ) )\\n\\t\\t\\t),\\n\\t\\t\\tsdBox( vec3( mod(pos.x+1.75, 3.5)-1.75, mod(pos.y+3.5, 7.)-2., pos.z-10.), vec3( 1.,1.,4.) )\\n\\t\\t),\\n\\t\\t\\topI( // main building windows\\n\\t\\t\\t\\tudBox( pos, vec3( 18., 30.0, 10. ) ),\\n\\t\\t\\t\\topU(\\n\\t\\t\\t\\t\\tudBox(  vec3( mod(pos.x+1.75, 3.5)-1.75, pos.y, pos.z-9.8), vec3( 0.05, 30., 0.05 ) ),\\n\\t\\t\\t\\t\\tudBox(  vec3( pos.x, mod(pos.y+0.425, 1.75)-0.875, pos.z-9.8), vec3( 50.0, 0.05, 0.05 ) )\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t);\\n\\treturn res;\\t\\n}\\n\\nfloat objB2( in vec3 pos ) {\\n\\tvec3 tpos;// = pos;\\n\\ttpos.x = min( abs(pos.x), abs(pos.z) );\\n\\ttpos.y = pos.y;\\n\\ttpos.z = max( abs(pos.x), abs(pos.z) );\\n\\t\\n\\tfloat res = opU(\\n\\t\\t\\topS(opS( // main building\\n\\t\\t\\t\\topS(\\n\\t\\t\\t\\t\\tudBox( tpos, vec3( 8.75, 31.0, 8.75 ) ),\\n\\t\\t\\t\\t\\tsdBox( vec3(tpos.x, tpos.y-31.0, tpos.z), vec3( 8.5, 1.0, 8.5) ) \\n\\t\\t\\t\\t\\n\\t\\t\\t),\\n\\t\\t\\t\\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-2.5, tpos.z-5.), vec3( 1.,2.,4.) )\\n\\t\\t\\t),\\n\\t\\t\\t\\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-4.5, tpos.z-5.), vec2( 1.,4.) )\\n\\t\\t\\t),\\n\\t\\t\\topI( // main building windows\\n\\t\\t\\t\\tudBox( tpos, vec3( 8.75, 31.0, 8.75 ) ),\\n\\t\\t\\t\\topU(\\n\\t\\t\\t\\t\\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-8.45), vec3( 0.05, 31., 0.05 ) ),\\n\\t\\t\\t\\t\\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-8.45), vec3( 10.0, 0.05, 0.05 ) )\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t);\\n\\treturn res;\\t\\n}\\n\\nvec2 map( in vec3 pos ) {\\n    vec2 res = opU( vec2( sdPlane( pos), 3.0 ),\\n\\t                vec2( udBox( pos+vec3(0.0, 9.0, 85.0), vec3( 200., 10.0, 100. ) ), 1. ) );\\n\\n\\tres = opU( res, vec2( udBox( pos+vec3(0.0, 20.0, 75.0), vec3( 200., 10.0, 100. ) ), 1. ) );\\n \\tres = opU( res, vec2( udBox( pos+vec3(0.0, 6.5, -15.0), vec3( 200., 10.0, 0.25 ) ), 1. ) );\\n\\n\\tres = opU( res, vec2( udBox( pos+vec3( 220.0, 14.0, 0.0), vec3( 100., 10.0, 200. ) ), 1. ) );\\n\\t\\t\\n\\tres = opU( res, vec2( udBox( (pos+vec3(3.20, -4.95, -5.55)), vec3( 0.55, 0.9, 0.01 ) ), 2. ) );\\n\\tres = opU( res, vec2( sdCylinderXZ( vec3(mod(pos.x+8., 16.)-8., pos.y+10., pos.z-24.), vec2( 0.4, 1.5)), 1.) );\\n\\n\\tif( pos.z > 20. ) {\\n\\t\\treturn res;\\n\\t}\\n\\t\\n\\tres = opU( res, vec2( objPrentenTentoonstelling( vec3(mod(pos.x+40.,80.)-40., pos.y, mod(pos.z+40.,80.)-40.) ), 1. ) );\\n\\t\\n\\tpos += vec3(3.25, -4.60, -5.55);\\n\\tres = opU( res, vec2( opI(\\n\\t\\tudBox( vec3(mod(pos.x+0.8, 1.6)-0.8, pos.y, pos.z), vec3( 0.7, 0.9, 0.1 ) ),\\n\\t\\tudBox( pos-vec3(3.25, -4.60, -5.55), vec3( 5.5, 5.5, 8.5 ) )\\n\\t\\t), 4. ) );\\n\\tpos -= vec3(3.25, -4.60, -5.55);\\n\\t\\n\\tpos += vec3( 15.5, 8., 10.);\\n\\tres = opU( res, vec2( objB1( vec3(mod(pos.x+27.,54.)-27., pos.y, mod(pos.z+50.,100.)-50.) ), 1. ) );\\n\\tpos += vec3( 20.5, -8., 5.);\\n\\tres = opU( res, vec2( objB2( vec3(mod(pos.x+23.,46.)-23., pos.y, mod(pos.z+35.,70.)-35.) ), 1. ) );\\n\\tpos += vec3( 20., -10., 10.);\\n\\tres = opU( res, vec2( objB1( vec3(mod(pos.x+77.,144.)-77., pos.y, mod(pos.z+66.,132.)-66.) ), 1. ) );\\n\\t\\t\\n\\treturn res;\\n}\\n\\n\\n// fast castfunctions to detect if droste picture is hit by ray\\n\\nfloat fastObjPrentenTentoonstelling( in vec3 pos ) {\\n\\treturn opU(\\tudBox(  vec3( pos.x, pos.y-6.3, pos.z-8.3), vec3( 8.5, 0.025, 0.025 ) ),\\n\\t\\t\\t\\tudBox(  vec3( mod(pos.x-8.375/18., 8.375/9.)-8.375/18., pos.y, pos.z-8.3), vec3( 0.025, 8.5, 0.025 ) )\\n\\t);\\n}\\nvec2 fastMap( in vec3 pos ) {\\n    return opU( vec2( fastObjPrentenTentoonstelling( pos), 1.0 ),\\n\\t            vec2( udBox( (pos+vec3(3.30, -4.55, -5.55)), vec3( 0.55, 0.7, 0.01 ) ), 2. ) );\\n}\\n\\nvec2 fastCastRay( in vec3 ro, in vec3 rd, in float maxd )\\n{\\n\\tfloat precis = 0.001;\\n    float h=precis*2.0;\\n    float t = 0.0;\\n    float m = -1.0;\\n    for( int i=0; i<60; i++ )\\n    {\\n\\t\\tif( abs(h)<precis || t>maxd ) break;  {\\n\\t\\t\\tt += h;\\n\\t\\t\\tvec2 res = fastMap( ro+rd*t );\\n\\t\\t\\th = res.x;\\n\\t\\t\\tm = res.y;\\n\\t\\t}\\n    }\\n\\n    if( t>maxd ) m=-1.0;\\n    return vec2( t, m );\\n}\\n\\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\\n{\\n\\tfloat precis = 0.001;\\n    float h=precis*2.0;\\n    float t = 0.0;\\n    float m = -1.0;\\n    for( int i=0; i<60; i++ )\\n    {\\n\\t\\tif( abs(h)<precis || t>maxd ) break;  {\\n\\t\\t\\tt += h;\\n\\t\\t\\tvec2 res = map( ro+rd*t );\\n\\t\\t\\th = res.x;\\n\\t\\t\\tm = res.y;\\n\\t\\t}\\n    }\\n\\n    if( t>maxd ) m=-1.0;\\n    return vec2( t, m );\\n}\\n\\n\\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\\n{\\n\\tfloat res = 1.0;\\n    float t = 0.1;\\n    float ph = 0.0;\\n    for( int i=0; i<32; i++ )\\n    {\\n\\t\\tif( t<maxt )\\n\\t\\t{\\n            float h = map( ro + rd*t ).x;\\t\\t\\t\\n                        \\n            float y = h*h/(2.0*ph);\\n            float d = sqrt(h*h-y*y);\\n            res = min( res, 10.0*d/max(0.0,t-y) );\\n            ph = h;\\n            \\n            t += 0.005+h;\\n\\t\\t} \\n    }\\n    return clamp( res, 0.0, 1.0 );\\n\\n}\\n\\nvec3 calcNormal( in vec3 pos )\\n{\\n\\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\\n\\tvec3 nor = vec3(\\n\\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\\n\\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\\n\\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\\n\\treturn normalize(nor);\\n}\\n\\nvoid getRoAndRd( in vec2 uv, out vec3 ro, out vec3 rd ) {\\n#ifdef WOBBLE\\n\\tro = vec3( 20.2+(1.0+cos((t+42.)/48.*2.*3.1415926))*cos(iTime), 36.0, 47.0  );\\n#else\\n\\tro = vec3( 20.2, 36.0, 47.0  );\\n#endif\\t\\n\\tvec3 ta = vec3( -3.1, 4.8,  5.5 );\\n\\t\\n\\t// camera tx\\n\\tvec3 cw = normalize( ta-ro );\\n\\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n\\trd = normalize( uv.x*cu + uv.y*cv + cw*zoom);\\n}\\n\\nbool hitDrostePicture( vec2 uv ) {\\n\\tvec3 ro, rd;\\n\\tgetRoAndRd( uv, ro, rd );\\t\\n\\t\\n\\tvec2 res = fastCastRay(ro,rd,200.0);\\n\\treturn (res.y == 2. );\\n}\\n\\nvec4 trace( vec2 uv ) {\\n\\tvec3 ro, rd;\\n\\tgetRoAndRd( uv, ro, rd );\\n\\t\\n    vec3 col = vec3(0.);\\n\\t\\t\\n    vec2 res = castRay(ro,rd,400.0);\\n    float t = res.x;\\n\\tfloat m = res.y;\\n    if( m>-0.5 )\\n    {\\n        vec3 pos = ro + t*rd;\\n        vec3 nor = calcNormal( pos );\\n\\n\\t\\tcol = vec3(0.7);\\n\\t\\tif( m == 3. ) col = vec3(0.6,0.71,1.0);\\n\\t\\tif( m == 4. ) col = vec3( 1. );\\n\\t\\t\\n\\t\\tif( m == 1. && all(lessThan(abs(pos), vec3( 5.65, 10., 5.65 ) ) ) ) {\\n\\t\\t\\tcol = vec3( 0.6 ); // inside gallery\\n\\t\\t}\\n\\t\\t\\n\\t\\tvec3 lig = normalize( vec3(-0.4, 0.4, 0.8) );\\n\\t\\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\\n\\n\\t\\tfloat sh = 1.0;\\n#ifdef SHADOW\\t\\t\\n\\t\\tif( dif>0.05 ) { sh = softshadow( pos, lig, 0.1, 30.0, 5.0 ); dif *= (0.8+0.2*sh); }\\n#endif\\t\\t\\n\\t\\tvec3 brdf = vec3(0.0);\\n\\t\\tbrdf += 0.80*amb*vec3(0.6,0.71,0.85);\\n        brdf += 1.30*dif*vec3(1.00,0.90,0.70);\\n\\n\\t\\tcol = col*brdf;\\n\\t\\t\\n\\t} else {\\n\\t\\tcol = 1.2*vec3(0.6,0.71,0.85) - rd.y*0.2*vec3(1.0,0.5,1.0);\\n\\t}\\n\\n\\treturn vec4( clamp(col,0.0,1.0), m );\\n}\\n\\nvoid init() {\\n\\tt = mod( t+11., 48. );\\n\\n\\tif( t < 8. ) st = t;\\n\\telse if( t < 24. ) st = 8.;\\n\\telse if( t < 32. ) st = 32.-t;\\n\\t\\t\\n\\tt = mod( t+12., 48. );\\n\\t\\t\\n\\tif( t < 8. ) zt = t;\\n\\telse if( t < 24. ) zt = 8.;\\n\\telse if( t < 32. ) zt = 32.-t;\\n\\t\\t\\n\\tdeformationScale = clamp(pow(2.0,st), 1., 256.);\\n\\tzoom =  2.71828 * clamp(pow(2.0,zt), 1.0, 256. );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    t = mod(iTime, 48.);\\n\\tvec2 uv = fragCoord.xy / iResolution.xy;\\n\\t\\n\\tuv = 2.*uv - vec2(1.);\\n    uv.x *= iResolution.x/ iResolution.y;\\n\\t\\t\\n\\tinit();\\n\\t\\n\\tvec3 col = vec3(0.);\\n\\n\\tbool band = abs(uv.x)>1.?true:false;\\n\\t\\n\\t// the  gallerymodel is a factor 1./0.7 too high to match Eschers painting, so I cheat :(\\n\\tuv.x *= 0.7;\\n\\tuv = escherDeformation(uv);\\t\\n\\tuv = drosteTransformation(uv);\\n\\t\\n\\tif( hitDrostePicture(uv) ) uv*=256.;\\n\\tif( hitDrostePicture(uv) ) uv*=256.;\\n\\t\\n\\t\\n\\tvec4 tr = trace( uv );\\n\\tcol = tr.xyz;\\n\\t\\n\\tif( band ) {\\n\\t\\tcol = mix( col, vec3(0.), st/8. );\\t\\n\\t}\\t\\t\\n\\t\\n\\tfragColor = vec4( col,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Mdf3Dr","date":"1367336643","viewed":6655,"name":"Outrun","description":"Just a quick one. Please don't look at the source of this shader :) The math is a mess and full of magical numbers and physical incorrect","likes":60,"published":"Public API","usePreview":0,"tags":["raycasting","outrun"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Outrun. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/Mdf3Dr\\n//\\n\\n// DON'T LOOK AT THE MATH!!!\\n\\n#define MAXDISTANCE 10000.\\n#define TRACKSVISIBLE 10\\n#define SEGMENTSPERTRACK 10\\n#define SECONDSPERTRACK 0.97\\n#define TRACKLENGTH 200.\\n\\n#define time iTime\\n\\n//\\n// math functions\\n//\\n\\nfloat hash( float n ) {\\n\\treturn fract(sin(n)*43758.5453);\\n}\\nfloat noise(in float x) {\\n\\tfloat p = floor(x);\\n\\tfloat f = fract(x);\\n\\t\\t\\n\\tf = f*f*(3.0-2.0*f);\\t\\n\\treturn mix( hash(p+  0.0), hash(p+  1.0),f);\\n}\\nfloat crossp( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\\n\\n//\\n// intersection functions\\n//\\n\\nvoid intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\\n\\tdist = MAXDISTANCE;\\n\\tvec2 p = ro.yz;\\n\\tvec2 r = rd.yz;\\n\\tvec2 q = a-p;\\n\\tvec2 s = b-a;\\n\\tfloat rCrossS = crossp(r, s);\\n\\t\\n\\tif( rCrossS == 0.){\\n\\t\\treturn;\\n\\t}\\n\\tfloat t = crossp(q, s) / rCrossS;\\n\\tu = crossp(q, r) / rCrossS;\\n\\t\\n\\tif(0. <= t && 0. <= u && u <= 1.){\\n\\t\\tdist = t;\\n\\t}\\n}\\n\\nfloat trackAngle( float s ) {\\n\\treturn (2.*noise( s*0.1 )-1.)*2.;\\n}\\nfloat trackHeight( float s ) {\\n\\treturn 500.*noise( s*0.2 );\\n}\\n\\nfloat traceTrack( vec3 ro, vec3 rd, out vec2 texcoord ) {\\n\\tfloat dist = MAXDISTANCE, dtest, xdist, zdist = MAXDISTANCE;\\n\\tfloat utest;\\n\\t\\n\\tfloat tf = time / SECONDSPERTRACK;\\n\\tfloat starttrack = floor(tf);\\n\\tfloat fracttrack = fract(tf);\\n\\t\\n\\tfloat z = -fracttrack*TRACKLENGTH;\\n\\t\\n\\tfloat sa = trackAngle( tf );\\n\\t\\t\\n\\tfor( int it=0; it<TRACKSVISIBLE; it++) {\\n\\t\\tfloat t = float(it)+starttrack;\\n\\t\\t\\t\\n\\t\\tfor( int is=0; is<SEGMENTSPERTRACK; is++ ) {\\t\\t\\t\\n\\t\\t\\tfloat dt = float(is)/float(SEGMENTSPERTRACK);\\n\\t\\t\\tintersectSegment( ro, rd, vec2( trackHeight( t+dt ), z ), \\n\\t\\t\\t\\t\\t\\t\\t vec2( trackHeight( t+dt+(1./float(SEGMENTSPERTRACK)) ), z+(TRACKLENGTH/float(SEGMENTSPERTRACK))), dtest, utest );\\n\\t\\t\\tif( dtest < dist ) {\\n\\t\\t\\t\\tdist = dtest;\\n\\t\\t\\t\\ttexcoord.y = utest;\\n\\t\\t\\t\\txdist = ro.x+rd.x*dist;\\n\\t\\t\\t\\tzdist = ro.z+rd.z*dist;\\n\\t\\t\\t\\ttexcoord.x = xdist + 2.*zdist*sin( trackAngle(t+dt+(utest/float(SEGMENTSPERTRACK)))-sa );\\n\\t\\t\\t}\\n\\t\\t\\tz+=(TRACKLENGTH/float(SEGMENTSPERTRACK));\\n\\t\\t}\\n\\t}\\n\\treturn zdist;\\n}\\n\\nvec3 trackColor( vec2 texcoord ) {\\n\\tif( abs(texcoord.x)<50. ) { // road\\n\\t\\tif(texcoord.y>0.5) {\\n\\t\\t\\treturn abs(texcoord.x)>46.?vec3(1.):vec3( 146./255. );\\n\\t\\t} else {\\n\\t\\t\\treturn mod(texcoord.x, 22.)<1.5?vec3(1.):vec3( 154./255. );\\n\\t\\t}\\n\\t} else { // desert\\n\\t\\treturn (texcoord.y>0.5)?vec3( 235./255., 219./255., 203./255. )\\n\\t\\t\\t:vec3( 227./255., 211./255., 195./255. );\\n\\t}\\n}\\nvec3 skyColor( vec2 texcoord ) {\\n\\tvec3 col = vec3( 0./255., 146./255., 255./255.);\\n\\tfloat n = noise( texcoord.x )*texcoord.y*10.+texcoord.y*4.;\\n\\tn += noise( texcoord.x * 10. );\\n\\tif( n < 1. ) col = mix(\\n\\t\\tvec3( 170./255., 154./255., 138./255.),\\n\\t\\tvec3( 235./255., 219./255., 203./255. ), clamp(texcoord.y*16., 0., 1.) );\\n\\treturn col;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy/iResolution.xy;\\n\\tvec2 p = -1.0+2.0*q;\\n\\tp.x *= iResolution.x/iResolution.y;\\n\\n\\tvec3 ro = vec3( -20.*sin(trackAngle(time/SECONDSPERTRACK)), 10.+trackHeight(time/SECONDSPERTRACK), -14. );\\n\\tvec3 rd = normalize( vec3( p, 1. ) );\\t\\n\\tvec3 color = vec3( 0. );\\n\\t\\n\\tvec2 texcoord;\\n\\tfloat d =  traceTrack( ro, rd, texcoord );\\n\\tif( d < MAXDISTANCE ) {\\n\\t\\tcolor = mix( trackColor( texcoord ), vec3( 170./255., 154./255., 138./255.), d/(float(TRACKSVISIBLE)*TRACKLENGTH));\\n\\t} else {\\n\\t\\tif( rd.y > 0. ) {\\n\\t\\t\\tcolor = skyColor( vec2( p.x-2.*trackAngle(time/SECONDSPERTRACK), p.y) );\\n\\t\\t} else {\\n\\t\\t\\tcolor = vec3( 170./255., 154./255., 138./255.);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tfragColor = vec4( clamp(color, 0., 1.),1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsX3WH","date":"1368546969","viewed":27474,"name":"A lot of spheres","description":"Simple raytracer showing a lot of spheres and light sources. A grid is used as an acceleration structure.","likes":181,"published":"Public API","usePreview":0,"tags":["raytracer","spheres"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A lot of spheres. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/lsX3WH\\n//\\n\\n#define SHADOW\\n#define REFLECTION\\n\\n#define RAYCASTSTEPS 40\\n\\n#define EPSILON 0.0001\\n#define MAXDISTANCE 400.\\n#define GRIDSIZE 8.\\n#define GRIDSIZESMALL 5.\\n#define MAXHEIGHT 30.\\n#define SPEED 0.5\\n\\n#define time iTime\\n\\n//\\n// math functions\\n//\\n\\nconst mat2 mr = mat2 (0.84147,  0.54030,\\n\\t\\t\\t\\t\\t  0.54030, -0.84147 );\\nfloat hash( float n ) {\\n\\treturn fract(sin(n)*43758.5453);\\n}\\nvec2 hash2( float n ) {\\n\\treturn fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\\n}\\nvec2 hash2( vec2 n ) {\\n\\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(2.1459123,3.3490423));\\n}\\nvec3 hash3( float n ) {\\n\\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\\n}\\nvec3 hash3( vec2 n ) {\\n\\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\\n}\\n//\\n// intersection functions\\n//\\n\\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\\t\\n\\tif (rd.y==0.0) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(100000.0, d);\\n\\tif( d > 0. ) {\\n\\t\\tdist = d;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\nbool intersectUnitSphere ( in vec3 ro, in vec3 rd, in vec3 sph, out float dist, out vec3 normal ) {\\n\\tvec3  ds = ro - sph;\\n\\tfloat bs = dot( rd, ds );\\n\\tfloat cs = dot(  ds, ds ) - 1.0;\\n\\tfloat ts = bs*bs - cs;\\n\\t\\n\\tif( ts > 0.0 ) {\\n\\t\\tts = -bs - sqrt( ts );\\n\\t\\tif( ts>0. ) {\\n\\t\\t\\tnormal = normalize( (ro+ts*rd)-sph );\\n\\t\\t\\tdist = ts;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn false;\\n}\\n\\n//\\n// Scene\\n//\\n\\nvoid getSphereOffset( vec2 grid, inout vec2 center ) {\\n\\tcenter = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);\\n}\\nvoid getMovingSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\\n\\t// falling?\\n\\tfloat s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );\\n\\tfloat t = fract(14.*s + time/s*.3);\\n\\t\\n\\tfloat y =  s * MAXHEIGHT * abs( 4.*t*(1.-t) );\\n\\tvec2 offset = grid + sphereOffset;\\n\\t\\n\\tcenter = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\\n}\\nvoid getSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\\n\\tvec2 offset = grid + sphereOffset;\\n\\tcenter = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\\n}\\nvec3 getSphereColor( vec2 grid ) {\\n\\treturn normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );\\n}\\n\\nvec3 trace(vec3 ro, vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {\\n\\tmaterial = 0; // sky\\n\\tdist = MAXDISTANCE;\\n\\tfloat distcheck;\\n\\t\\n\\tvec3 sphereCenter, col, normalcheck;\\n\\t\\n\\tif( intersectPlane( ro,  rd, 0., distcheck) && distcheck < MAXDISTANCE ) {\\n\\t\\tdist = distcheck;\\n\\t\\tmaterial = 1;\\n\\t\\tnormal = vec3( 0., 1., 0. );\\n\\t\\tcol = vec3( 0.25 );\\n\\t} else {\\n\\t\\tcol = vec3( 0. );\\n\\t}\\n\\t\\n\\t\\t\\n\\t// trace grid\\n\\tvec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;\\n\\tvec3 ri = 1.0/rd;\\n\\tvec3 rs = sign(rd) * GRIDSIZE;\\n\\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\\n\\tvec3 mm = vec3(0.0);\\n\\tvec2 offset;\\n\\t\\t\\n\\tfor( int i=0; i<RAYCASTSTEPS; i++ )\\t{\\n\\t\\tif( material > 1 || distance( ro.xz, pos.xz ) > dist+GRIDSIZE ) break;\\n\\t\\tvec2 offset;\\n\\t\\tgetSphereOffset( pos.xz, offset );\\n\\t\\t\\n\\t\\tgetMovingSpherePosition( pos.xz, -offset, sphereCenter );\\n\\t\\t\\n\\t\\tif( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\\n\\t\\t\\tdist = distcheck;\\n\\t\\t\\tnormal = normalcheck;\\n\\t\\t\\tmaterial = 2;\\n\\t\\t}\\n\\t\\t\\n\\t\\tgetSpherePosition( pos.xz, offset, sphereCenter );\\n\\t\\tif( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\\n\\t\\t\\tdist = distcheck;\\n\\t\\t\\tnormal = normalcheck;\\n\\t\\t\\tcol = getSphereColor( offset );\\n\\t\\t\\tmaterial = 3;\\n\\t\\t}\\n\\t\\tmm = step(dis.xyz, dis.zyx);\\n\\t\\tdis += mm * rs * ri;\\n\\t\\tpos += mm * rs;\\t\\t\\n\\t}\\n\\t\\n\\tvec3 color = vec3( 0. );\\n\\tif( material > 0 ) {\\n\\t\\tintersection = ro + rd*dist;\\n\\t\\tvec2 map = floor(intersection.xz/GRIDSIZE)*GRIDSIZE;\\n\\t\\t\\n\\t\\tif( material == 1 || material == 3 ) {\\n\\t\\t\\t// lightning\\n\\t\\t\\tvec3 c = vec3( -GRIDSIZE,0., GRIDSIZE );\\n\\t\\t\\tfor( int x=0; x<3; x++ ) {\\n\\t\\t\\t\\tfor( int y=0; y<3; y++ ) {\\n\\t\\t\\t\\t\\tvec2 mapoffset = map+vec2( c[x], c[y] );\\t\\t\\n\\t\\t\\t\\t\\tvec2 offset;\\n\\t\\t\\t\\t\\tgetSphereOffset( mapoffset, offset );\\n\\t\\t\\t\\t\\tvec3 lcolor = getSphereColor( mapoffset );\\n\\t\\t\\t\\t\\tvec3 lpos;\\n\\t\\t\\t\\t\\tgetMovingSpherePosition( mapoffset, -offset, lpos );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfloat shadow = 1.;\\n#ifdef SHADOW\\n\\t\\t\\t\\t\\tif( material == 1 ) {\\n\\t\\t\\t\\t\\t\\tfor( int sx=0; sx<3; sx++ ) {\\n\\t\\t\\t\\t\\t\\t\\tfor( int sy=0; sy<3; sy++ ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif( shadow < 1. ) continue;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\tvec2 smapoffset = map+vec2( c[sx], c[sy] );\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\tvec2 soffset;\\n\\t\\t\\t\\t\\t\\t\\t\\tgetSphereOffset( smapoffset, soffset );\\n\\t\\t\\t\\t\\t\\t\\t\\tvec3 slpos, sn;\\n\\t\\t\\t\\t\\t\\t\\t\\tgetSpherePosition( smapoffset, soffset, slpos );\\n\\t\\t\\t\\t\\t\\t\\t\\tfloat sd;\\n\\t\\t\\t\\t\\t\\t\\t\\tif( intersectUnitSphere( intersection, normalize( lpos - intersection ), slpos, sd, sn )  ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tshadow = 0.;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n#endif\\n\\t\\t\\t\\t\\tcolor += col * lcolor * ( shadow * max( dot( normalize(lpos-intersection), normal ), 0.) *\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t clamp(10. / dot( lpos - intersection, lpos - intersection) - 0.075, 0., 1.)  );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// emitter\\n\\t\\t\\tcolor = (3.+2.*dot(normal, vec3( 0.5, 0.5, -0.5))) * getSphereColor( map );\\n\\t\\t}\\n\\t}\\n\\treturn color;\\n}\\n\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy/iResolution.xy;\\n\\tvec2 p = -1.0+2.0*q;\\n\\tp.x *= iResolution.x/iResolution.y;\\n\\t\\n\\t// camera\\t\\n\\tvec3 ce = vec3( cos( 0.232*time) * 10., 6.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );\\n\\tvec3 ro = ce;\\n\\tvec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\\n\\t\\n\\tfloat roll = -0.15*sin(0.5*time);\\n\\t\\n\\t// camera tx\\n\\tvec3 cw = normalize( ta-ro );\\n\\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n\\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\\n\\t\\n\\t// raytrace\\n\\tint material;\\n\\tvec3 normal, intersection;\\n\\tfloat dist;\\n\\t\\n\\tvec3 col = trace(ro, rd, intersection, normal, dist, material);\\n\\n#ifdef REFLECTION\\n\\tif( material > 0 ) {\\n    \\tfloat f = 0.04 * clamp(pow(1. + dot(rd, normal), 5.), 0., 1.);\\n    \\t    \\n\\t\\tvec3 ro = intersection + EPSILON*normal;\\n\\t\\trd = reflect( rd, normal );\\n\\t\\tvec3 refColor = trace(ro, rd, intersection, normal, dist, material);\\n\\t\\tif (material > 2) { \\n    \\t\\tcol += .5 * refColor; \\n\\t\\t} else { // fresnell on floor\\n\\t\\t    col += f * refColor;\\n\\t\\t}\\n\\t}\\n#endif\\n\\t\\n\\tcol = pow( col * .5, vec3(1./2.2) );\\t\\n\\tcol = clamp(col, 0.0, 1.0);\\n\\t\\n\\t// vigneting\\n\\tcol *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\\n\\t\\n\\tfragColor = vec4( col,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsX3DH","date":"1368639478","viewed":30777,"name":"More spheres","description":"A simple pathtracer based on my shader https://www.shadertoy.com/view/lsX3WH showing motion blur, depth of field and importance sampling. Based on: https://iquilezles.org/articles/simplepathtracing/simplepathtracing.htm\\n","likes":205,"published":"Public API","usePreview":0,"tags":["motionblur","spheres","pathtracer","depthoffield"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// More spheres. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lsX3DH\\n//\\n// based on: https://iquilezles.org/articles/simplepathtracing\\n//\\n\\n#define MOTIONBLUR\\n#define DEPTHOFFIELD\\n\\n#define CUBEMAPSIZE 256\\n\\n#define SAMPLES 8\\n#define PATHDEPTH 4\\n#define TARGETFPS 60.\\n\\n#define FOCUSDISTANCE 17.\\n#define FOCUSBLUR 0.25\\n\\n#define RAYCASTSTEPS 20\\n#define RAYCASTSTEPSRECURSIVE 2\\n\\n#define EPSILON 0.001\\n#define MAXDISTANCE 180.\\n#define GRIDSIZE 8.\\n#define GRIDSIZESMALL 5.9\\n#define MAXHEIGHT 30.\\n#define SPEED 0.5\\n\\nfloat time;\\n\\n//\\n// math functions\\n//\\n\\nfloat hash( const float n ) {\\n\\treturn fract(sin(n)*43758.54554213);\\n}\\nvec2 hash2( const float n ) {\\n\\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\\n}\\nvec2 hash2( const vec2 n ) {\\n\\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(25.1459123,312.3490423));\\n}\\nvec3 hash3( const vec2 n ) {\\n\\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(36.5453123,43.1459123,11234.3490423));\\n}\\n//\\n// intersection functions\\n//\\n\\nfloat intersectPlane( const vec3 ro, const vec3 rd, const float height) {\\t\\n\\tif (rd.y==0.0) return 500.;\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\tif( d > 0. ) {\\n\\t\\treturn d;\\n\\t}\\n\\treturn 500.;\\n}\\n\\nfloat intersectUnitSphere ( const vec3 ro, const vec3 rd, const vec3 sph ) {\\n\\tvec3  ds = ro - sph;\\n\\tfloat bs = dot( rd, ds );\\n\\tfloat cs = dot( ds, ds ) - 1.0;\\n\\tfloat ts = bs*bs - cs;\\n\\n\\tif( ts > 0.0 ) {\\n\\t\\tts = -bs - sqrt( ts );\\n\\t\\tif( ts > 0. ) {\\n\\t\\t\\treturn ts;\\n\\t\\t}\\n\\t}\\n\\treturn 500.;\\n}\\n\\n//\\n// Scene\\n//\\n\\nvoid getSphereOffset( const vec2 grid, out vec2 center ) {\\n\\tcenter = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);\\n}\\nvoid getMovingSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {\\n\\t// falling?\\n\\tfloat s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );\\n\\tfloat t = fract(14.*s + time/s*.3);\\n\\t\\n\\tfloat y =  s * MAXHEIGHT * abs( 4.*t*(1.-t) );\\n\\tvec2 offset = grid + sphereOffset;\\n\\t\\n\\tcenter = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\\n}\\nvoid getSpherePosition( const vec2 grid, const vec2 sphereOffset, out vec3 center ) {\\n\\tvec2 offset = grid + sphereOffset;\\n\\tcenter = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\\n}\\nvec3 getSphereColor( const vec2 grid ) {\\n\\tvec3 col = hash3( grid+vec2(43.12*grid.y,12.23*grid.x) );\\n    return mix(col,col*col,.8);\\n}\\n\\nvec3 getBackgroundColor( const vec3 ro, const vec3 rd ) {\\t\\n\\treturn 1.4*mix(vec3(.5),vec3(.7,.9,1), .5+.5*rd.y);\\n}\\n\\nvec3 trace(const vec3 ro, const vec3 rd, out vec3 intersection, out vec3 normal, \\n           out float dist, out int material, const int steps) {\\n\\tdist = MAXDISTANCE;\\n\\tfloat distcheck;\\n\\t\\n\\tvec3 sphereCenter, col, normalcheck;\\n\\t\\n\\tmaterial = 0;\\n\\tcol = getBackgroundColor(ro, rd);\\n\\t\\n\\tif( (distcheck = intersectPlane( ro,  rd, 0.)) < MAXDISTANCE ) {\\n\\t\\tdist = distcheck;\\n\\t\\tmaterial = 1;\\n\\t\\tnormal = vec3( 0., 1., 0. );\\n\\t\\tcol = vec3(.7);\\n\\t} \\n\\t\\n\\t// trace grid\\n\\tvec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;\\n\\tvec3 ri = 1.0/rd;\\n\\tvec3 rs = sign(rd) * GRIDSIZE;\\n\\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\\n\\tvec3 mm = vec3(0.0);\\n\\tvec2 offset;\\n\\t\\t\\n\\tfor( int i=0; i<steps; i++ )\\t{\\n\\t\\tif( material == 2 ||  distance( ro.xz, pos.xz ) > dist+GRIDSIZE ) break; {\\n\\t\\t\\tgetSphereOffset( pos.xz, offset );\\n\\t\\t\\t\\n\\t\\t\\tgetMovingSpherePosition( pos.xz, -offset, sphereCenter );\\t\\t\\t\\n\\t\\t\\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\\n\\t\\t\\t\\tdist = distcheck;\\n\\t\\t\\t\\tnormal = normalize((ro+rd*dist)-sphereCenter);\\n\\t\\t\\t\\tcol = getSphereColor(pos.xz);\\n\\t\\t\\t\\tmaterial = 2;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tgetSpherePosition( pos.xz, offset, sphereCenter );\\n\\t\\t\\tif( (distcheck = intersectUnitSphere( ro, rd, sphereCenter )) < dist ) {\\n\\t\\t\\t\\tdist = distcheck;\\n\\t\\t\\t\\tnormal = normalize((ro+rd*dist)-sphereCenter);\\n\\t\\t\\t\\tcol = getSphereColor(pos.xz+vec2(1.,2.));\\n\\t\\t\\t\\tmaterial = 2;\\n\\t\\t\\t}\\t\\t\\n\\t\\t\\tmm = step(dis.xyz, dis.zyx);\\n\\t\\t\\tdis += mm * rs * ri;\\n\\t\\t\\tpos += mm * rs;\\t\\t\\n\\t\\t}\\n\\t}\\n\\t\\n\\tintersection = ro+rd*dist;\\n\\t\\n\\treturn col;\\n}\\n\\nvec2 rv2;\\n\\nvec3 cosWeightedRandomHemisphereDirection2( const vec3 n ) {\\n\\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\\n\\tvec3  vv = cross( uu, n );\\n\\t\\n\\tfloat ra = sqrt(rv2.y);\\n\\tfloat rx = ra*cos(6.2831*rv2.x); \\n\\tfloat ry = ra*sin(6.2831*rv2.x);\\n\\tfloat rz = sqrt( 1.0-rv2.y );\\n\\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\\n\\n    return normalize( rr );\\n}\\n\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\ttime = iTime;\\n    vec2 q = fragCoord.xy/iResolution.xy;\\n\\tvec2 p = -1.0+2.0*q;\\n\\tp.x *= iResolution.x/iResolution.y;\\n\\t\\n\\tvec3 col = vec3( 0. );\\n\\t\\n\\t// raytrace\\n\\tint material;\\n\\tvec3 normal, intersection;\\n\\tfloat dist;\\n\\tfloat seed = time+(p.x+iResolution.x*p.y)*1.51269341231;\\n\\t\\n\\tfor( int j=0; j<SAMPLES + min(0,iFrame); j++ ) {\\n\\t\\tfloat fj = float(j);\\n\\t\\t\\n#ifdef MOTIONBLUR\\n\\t\\ttime = iTime + fj/(float(SAMPLES)*TARGETFPS);\\n#endif\\n\\t\\t\\n\\t\\trv2 = hash2( 24.4316544311*fj+time+seed );\\n\\t\\t\\n\\t\\tvec2 pt = p+rv2/(0.5*iResolution.xy);\\n\\t\\t\\t\\t\\n\\t\\t// camera\\t\\n\\t\\tvec3 ro = vec3( cos( 0.232*time) * 10., 6.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );\\n\\t\\tvec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\\n\\t\\t\\n\\t\\tfloat roll = -0.15*sin(0.5*time);\\n\\t\\t\\n\\t\\t// camera tx\\n\\t\\tvec3 cw = normalize( ta-ro );\\n\\t\\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\\n\\t\\tvec3 cu = normalize( cross(cw,cp) );\\n\\t\\tvec3 cv = normalize( cross(cu,cw) );\\n\\t\\n#ifdef DEPTHOFFIELD\\n    // create ray with depth of field\\n\\t\\tconst float fov = 3.0;\\n\\t\\t\\n        vec3 er = normalize( vec3( pt.xy, fov ) );\\n        vec3 rd = er.x*cu + er.y*cv + er.z*cw;\\n\\n        vec3 go = FOCUSBLUR*vec3( (rv2-vec2(0.5))*2., 0.0 );\\n        vec3 gd = normalize( er*FOCUSDISTANCE - go );\\n\\t\\t\\n        ro += go.x*cu + go.y*cv;\\n        rd += gd.x*cu + gd.y*cv;\\n\\t\\trd = normalize(rd);\\n#else\\n\\t\\tvec3 rd = normalize( pt.x*cu + pt.y*cv + 1.5*cw );\\t\\t\\n#endif\\t\\t\\t\\n\\t\\tvec3 colsample = vec3( 1. );\\n\\t\\t\\n\\t\\t// first hit\\n\\t\\trv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.) );\\n\\t\\tcolsample *= trace(ro, rd, intersection, normal, dist, material, RAYCASTSTEPS);\\n\\n\\t\\t// bounces\\n\\t\\tfor( int i=0; i<(PATHDEPTH-1); i++ ) {\\n\\t\\t\\tif( material != 0 ) {\\n\\t\\t\\t\\trd = cosWeightedRandomHemisphereDirection2( normal );\\n\\t\\t\\t\\tro = intersection + EPSILON*rd;\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\trv2 = hash2( (rv2.x*2.4543263+rv2.y)*(time+1.)+(float(i+1)*.23) );\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tcolsample *= trace(ro, rd, intersection, normal, dist, material, RAYCASTSTEPSRECURSIVE);\\n\\t\\t\\t}\\n\\t\\t}\\t\\n\\t\\tcolsample = sqrt(clamp(colsample, 0., 1.));\\n\\t\\tif( material == 0 ) {\\t\\t\\t\\n\\t\\t\\tcol += colsample;\\t\\n\\t\\t}\\n\\t}\\n\\tcol  /= float(SAMPLES);\\n\\t\\n\\tfragColor = vec4( col,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XdsGWH","date":"1368889425","viewed":6180,"name":"Mars demo","description":"Tribute to Tim Clarke's Mars demo from 1993. Click and move your mouse to look around.\\n\\nhttp://pouet.net/prod.php?which=4662&howmanycomments=25&page=0","likes":32,"published":"Public API","usePreview":0,"tags":["mars","timclarke","terrainmarching"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mars demo. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XdsGWH\\n//\\n\\n#define RAYMARCHSTEPS 150\\n\\n#define time iTime\\n\\n//\\n// math functions\\n//\\n\\nconst mat2 mr = mat2 (0.84147,  0.54030,\\n\\t\\t\\t\\t\\t  0.54030, -0.84147 );\\nfloat hash( in float n ) {\\n\\treturn fract(sin(n)*43758.5453);\\n}\\nfloat noise(in vec2 x) {\\n\\tvec2 p = floor(x);\\n\\tvec2 f = fract(x);\\n\\t\\t\\n\\tf = f*f*(3.0-2.0*f);\\t\\n\\tfloat n = p.x + p.y*57.0;\\n\\t\\n\\tfloat res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n\\t\\t\\t\\t\\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\\n\\treturn res;\\n}\\nfloat fbm( in vec2 p ) {\\n\\tfloat f;\\n\\tf  =      0.5000*noise( p ); p = mr*p*2.02;\\n\\tf +=      0.2500*noise( p ); p = mr*p*2.33;\\n\\tf +=      0.1250*noise( p ); p = mr*p*2.01;\\n\\tf +=      0.0625*noise( p ); p = mr*p*5.21;\\n//\\tf +=      0.005*noise( p ); \\n\\treturn f/(0.9375);\\n}\\nfloat detailFbm( in vec2 p ) {\\n\\tfloat f;\\n\\tf  =      0.5000*noise( p ); p = mr*p*2.02;\\n\\tf +=      0.2500*noise( p ); p = mr*p*2.33;\\n\\tf +=      0.1250*noise( p ); p = mr*p*2.01;\\n\\tf +=      0.0625*noise( p ); p = mr*p*5.21;\\n\\tf +=      0.005*noise( p ); \\n\\treturn f/(0.9375);\\n}\\n\\n//\\n// intersection functions\\n//\\n\\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\\t\\n\\tif (rd.y==0.0) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(100000.0, d);\\n\\tif( d > 0. ) {\\n\\t\\tdist = d;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\n//\\n// Scene\\n//\\n\\nfloat skyDensity( vec2 p ) {\\n\\treturn fbm( p*0.125 );\\n}\\nfloat mapHeight( vec2 p ) {\\n\\treturn fbm(  p*0.35 )*4.;\\n}\\nfloat detailMapHeight( vec2 p ) {\\n\\treturn detailFbm(  p*0.35 )*4.;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy/iResolution.xy;\\n\\tvec2 p = vec2(-1.0)+2.0*q;\\n\\tp.x *= iResolution.x/iResolution.y;\\n\\t\\n\\tvec2 pos = abs(iMouse.xy)*0.025 + vec2( 0.8, 10.);\\n\\t\\n\\tvec3 ro = vec3( pos.x, mapHeight( pos )+0.25, pos.y );\\n\\tvec3 rd = ( vec3(p, 1. ) );\\n\\t\\n\\tfloat dist;\\n\\tvec3 col = vec3(0.);\\n\\tvec3 intersection = vec3(9999.);\\n\\t\\n\\t// sky\\n\\tif( intersectPlane( ro, rd, 8., dist ) ) {\\n\\t\\tintersection = ro+rd*dist;\\n\\t\\tcol = mix( vec3(240./255., 0./255., 0./255.), vec3(1.), skyDensity( intersection.xz ) );\\n\\t} else {\\n\\t\\tcol = mix( vec3(112./255.,2./255.,6./255.), vec3(0.), clamp(-p.y*3., 0., 1.) );\\n\\t}\\n\\t// terrain - raymarch\\n\\tfloat t, h = 0.;\\n\\tconst float dt=0.05;\\n\\t\\n\\tt = mod( ro.z, dt );\\n\\t\\n\\tfor( int i=0; i<RAYMARCHSTEPS; i++) {\\n\\t\\tif( h < intersection.y ) {\\n\\t\\t\\tt += dt;\\n\\t\\t\\tintersection = ro + rd*t;\\n\\t\\t\\t\\n\\t\\t\\th = mapHeight( intersection.xz );\\n\\t\\t}\\n\\t}\\n\\tif( h > intersection.y ) {\\t\\n\\t\\t// calculate projected height of intersection and previous point\\n\\t\\tfloat h1 = (h-ro.y)/(rd.z*t);\\n\\t\\tvec3 prev =  ro + rd*(t-dt);\\n\\t\\tfloat h2 = (mapHeight( prev.xz )-ro.y)/(rd.z*(t-dt));\\n\\t\\t\\t\\t\\n\\t\\tfloat dx1 = detailMapHeight( intersection.xz+vec2(0.001,0.0) ) - detailMapHeight( intersection.xz+vec2(-0.001, 0.0) );\\n\\t\\tdx1 *= (1./0.002);\\n\\t\\tfloat dx2 = detailMapHeight( prev.xz+vec2(0.001,0.0) ) - detailMapHeight( prev.xz+vec2(-0.001, 0.0) );\\n\\t\\tdx2 *= (1./0.002);\\n\\t\\t\\n\\t\\t\\n\\t\\tfloat dx = mix( dx1, dx2, clamp( (h1-p.y)/(h1-h2), 0., 1.));\\n\\t\\t\\n\\t\\tcol = mix( vec3(232./201.,121./255.,101./255.), vec3(31./255.,0.,0.), 0.5+0.25*dx );\\n\\n\\t}\\n\\t\\n\\tfragColor = vec4(col,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lds3D8","date":"1369417084","viewed":1685,"name":"Oculus rift & Spheres","description":"Just a modification of the shader 'lot of spheres', so you can use it with the Oculus Rift (http://www.oculusvr.com/). All constants are empircal measured. Run the shader full screen.","likes":16,"published":"Public API","usePreview":0,"tags":["spheres","raytrace","oculusrift"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n\\n// empirical measured values\\n#define EYEDISTANCE  1. \\n#define LENSDISTANCE -0.136 \\n#define FOV 0.62  \\n\\n#define SHADOW\\n//#define REFLECTION\\n\\n#define RAYCASTSTEPS 30\\n\\n#define EXPOSURE 0.9\\n#define EPSILON 0.0001\\n#define MAXDISTANCE 400.\\n#define GRIDSIZE 10.\\n#define GRIDSIZESMALL 8.\\n#define MAXHEIGHT 10.\\n#define SPEED 2.5\\n\\nfloat time;\\n\\n//\\n// math functions\\n//\\n\\nconst mat2 mr = mat2 (0.84147,  0.54030,\\n\\t\\t\\t\\t\\t  0.54030, -0.84147 );\\nfloat hash( float n ) {\\n\\treturn fract(sin(n)*43758.5453);\\n}\\nvec2 hash2( float n ) {\\n\\treturn fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\\n}\\nvec2 hash2( vec2 n ) {\\n\\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(2.1459123,3.3490423));\\n}\\nvec3 hash3( float n ) {\\n\\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\\n}\\nvec3 hash3( vec2 n ) {\\n\\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\\n}\\n//\\n// intersection functions\\n//\\n\\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\\t\\n\\tif (rd.y==0.0) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(100000.0, d);\\n\\tif( d > 0. ) {\\n\\t\\tdist = d;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\nbool intersectUnitSphere ( in vec3 ro, in vec3 rd, in vec3 sph, out float dist, out vec3 normal ) {\\n\\tvec3  ds = ro - sph;\\n\\tfloat bs = dot( rd, ds );\\n\\tfloat cs = dot(  ds, ds ) - 1.0;\\n\\tfloat ts = bs*bs - cs;\\n\\t\\n\\tif( ts > 0.0 ) {\\n\\t\\tts = -bs - sqrt( ts );\\n\\t\\tif( ts>0. ) {\\n\\t\\t\\tnormal = normalize( (ro+ts*rd)-sph );\\n\\t\\t\\tdist = ts;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn false;\\n}\\n\\n//\\n// Scene\\n//\\n\\nvoid getSphereOffset( vec2 grid, inout vec2 center ) {\\n\\tcenter = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);\\n}\\nvoid getMovingSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\\n\\t// falling?\\n\\tfloat s = 0.1+hash( grid.x*1.23114+5.342+754.324231*grid.y );\\n\\tfloat t = 14.*s + time/s;\\n\\t\\n\\tfloat y =  s * MAXHEIGHT * abs( cos( t ) );\\n\\tvec2 offset = grid + sphereOffset;\\n\\t\\n\\tcenter = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\\n}\\nvoid getSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\\n\\tvec2 offset = grid + sphereOffset;\\n\\tcenter = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\\n}\\nvec3 getSphereColor( vec2 grid ) {\\n\\treturn normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );\\n}\\n\\nvec3 trace(vec3 ro, vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {\\n\\tmaterial = 0; // sky\\n\\tdist = MAXDISTANCE;\\n\\tfloat distcheck;\\n\\t\\n\\tvec3 sphereCenter, col, normalcheck;\\n\\t\\n\\tif( intersectPlane( ro,  rd, 0., distcheck) && distcheck < MAXDISTANCE ) {\\n\\t\\tdist = distcheck;\\n\\t\\tmaterial = 1;\\n\\t\\tnormal = vec3( 0., 1., 0. );\\n\\t\\tcol = vec3( 1. );\\n\\t} else {\\n\\t\\tcol = vec3( 0. );\\n\\t}\\n\\t\\n\\t// trace grid\\n\\tvec2 map = floor( ro.xz / GRIDSIZE ) * GRIDSIZE;\\n\\tfloat deltaDistX = GRIDSIZE*sqrt(1. + (rd.z * rd.z) / (rd.x * rd.x));\\n\\tfloat deltaDistY = GRIDSIZE*sqrt(1. + (rd.x * rd.x) / (rd.z * rd.z));\\n\\tfloat stepX, stepY, sideDistX, sideDistY;\\n\\t\\n\\t//calculate step and initial sideDist\\n\\tif (rd.x < 0.) {\\n\\t\\tstepX = -GRIDSIZE;\\n\\t\\tsideDistX = (ro.x - map.x) * deltaDistX / GRIDSIZE;\\n\\t} else {\\n\\t\\tstepX = GRIDSIZE;\\n\\t\\tsideDistX = (map.x + GRIDSIZE - ro.x) * deltaDistX / GRIDSIZE;\\n\\t}\\n\\tif (rd.z < 0.) {\\n\\t\\tstepY = -GRIDSIZE;\\n\\t\\tsideDistY = (ro.z - map.y) * deltaDistY / GRIDSIZE;\\n\\t} else {\\n\\t\\tstepY = GRIDSIZE;\\n\\t\\tsideDistY = (map.y + GRIDSIZE - ro.z) * deltaDistY / GRIDSIZE;\\n\\t}\\n\\t\\n\\tbool hit = false; \\n\\t\\n\\tfor( int i=0; i<RAYCASTSTEPS; i++ ) {\\n\\t\\tif( hit || distance( ro.xz, map ) > dist+GRIDSIZE ) continue;\\n\\n\\t\\tvec2 offset;\\n\\t\\tgetSphereOffset( map, offset );\\n\\t\\t\\n\\t\\tgetMovingSpherePosition( map, -offset, sphereCenter );\\n\\t\\t\\n\\t\\tif( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\\n\\t\\t\\tdist = distcheck;\\n\\t\\t\\tnormal = normalcheck;\\n\\t\\t\\tmaterial = 2;\\n\\t\\t\\thit = true;\\n\\t\\t}\\n\\t\\t\\n\\t\\tgetSpherePosition( map, offset, sphereCenter );\\n\\t\\tif( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\\n\\t\\t\\tdist = distcheck;\\n\\t\\t\\tnormal = normalcheck;\\n\\t\\t\\tcol = vec3( 2. );\\n\\t\\t\\tmaterial = 3;\\n\\t\\t\\thit = true;\\n\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\n\\t\\tif (sideDistX < sideDistY) {\\n\\t\\t\\tsideDistX += deltaDistX;\\n\\t\\t\\tmap.x += stepX;\\n\\t\\t} else {\\n\\t\\t\\tsideDistY += deltaDistY;\\n\\t\\t\\tmap.y += stepY;\\n\\t\\t}\\t\\t\\n\\t}\\n\\t\\n\\tvec3 color = vec3( 0. );\\n\\tif( (hit || material == 1) ) {\\n\\t\\tintersection = ro + rd*dist;\\n\\t\\tvec2 map = intersection.xz - mod( intersection.xz, vec2(GRIDSIZE,GRIDSIZE) );\\n\\t\\t\\n\\t\\tif( material == 1 || material == 3 ) {\\n\\t\\t\\t// lightning\\n\\t\\t\\tvec3 c = vec3( -GRIDSIZE,0., GRIDSIZE );\\n\\t\\t\\tfor( int x=0; x<3; x++ ) {\\n\\t\\t\\t\\tfor( int y=0; y<3; y++ ) {\\n\\t\\t\\t\\t\\tvec2 mapoffset = map+vec2( c[x], c[y] );\\t\\t\\n\\t\\t\\t\\t\\tvec2 offset;\\n\\t\\t\\t\\t\\tgetSphereOffset( mapoffset, offset );\\n\\t\\t\\t\\t\\tvec3 lcolor = getSphereColor( mapoffset );\\n\\t\\t\\t\\t\\tvec3 lpos;\\n\\t\\t\\t\\t\\tgetMovingSpherePosition( mapoffset, -offset, lpos );\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tfloat shadow = 1.;\\n#ifdef SHADOW\\n\\t\\t\\t\\t\\tif( material == 1 ) {\\n\\t\\t\\t\\t\\t\\tfor( int sx=0; sx<3; sx++ ) {\\n\\t\\t\\t\\t\\t\\t\\tfor( int sy=0; sy<3; sy++ ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif( shadow < 1. ) continue;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\tvec2 smapoffset = map+vec2( c[sx], c[sy] );\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\tvec2 soffset;\\n\\t\\t\\t\\t\\t\\t\\t\\tgetSphereOffset( smapoffset, soffset );\\n\\t\\t\\t\\t\\t\\t\\t\\tvec3 slpos, sn;\\n\\t\\t\\t\\t\\t\\t\\t\\tgetSpherePosition( smapoffset, soffset, slpos );\\n\\t\\t\\t\\t\\t\\t\\t\\tfloat sd;\\n\\t\\t\\t\\t\\t\\t\\t\\tif( intersectUnitSphere( intersection, normalize( lpos - intersection ), slpos, sd, sn )  ) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tshadow = 0.;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n#endif\\n\\t\\t\\t\\t\\tcolor += col * lcolor * ( shadow * max( dot( normalize(lpos-intersection), normal ), 0.) *\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t (1. - clamp( distance( lpos, intersection )/GRIDSIZE, 0., 1.) ) );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// emitter\\n\\t\\t\\tcolor = (1.5+dot(normal, vec3( 0.5, 0.5, -0.5) )) *getSphereColor( map );\\n\\t\\t}\\n\\t}\\n\\treturn color;\\n}\\n\\n// left\\nfloat w = 1.0;\\nfloat h = 1.0;\\nfloat scaleFactor = 1.0;\\n\\nvec2 leftLensCenter = vec2( LENSDISTANCE, 0. );\\nvec2 rightLensCenter = vec2( -LENSDISTANCE, 0. );\\n\\nvec2 Scale;\\nvec2 ScaleIn = vec2( 1., 1.);\\nvec4 HmdWarpParam = vec4(1., 0.22, 0.24, 0);\\n\\nvec2 HmdWarp(vec2 in01, vec2 lensCenter) {\\n   vec2 theta = (in01-lensCenter) * ScaleIn; // Scales to [-1, 1]\\n   float rSq = dot(theta, theta);\\n   vec2 rvector = theta * \\n\\t (HmdWarpParam.x + HmdWarpParam.y * rSq +\\n      HmdWarpParam.z * rSq * rSq +\\n      HmdWarpParam.w * rSq * rSq * rSq);\\n   return lensCenter + Scale * rvector;\\n}\\n\\n\\n\\n\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    Scale = 0.65*vec2( 1., iResolution.x/iResolution.y );\\n    time = iTime;\\n\\tvec2 q = fragCoord.xy/iResolution.xy;\\n\\tvec2 p = 2.0*q;\\n\\t\\n\\tp.x *= 2.;\\n\\t\\t\\n\\tbool lefteye = true;\\n\\tif( p.x > 2. ) {\\n\\t\\tp.x -= 2.;\\n\\t\\tlefteye = false;\\n\\t}\\n\\tp -= vec2(1.);\\n\\t\\t\\n\\tp = HmdWarp( p, lefteye?leftLensCenter:rightLensCenter );\\n\\n\\n\\tp.x *= iResolution.x/iResolution.y;\\n\\t\\n\\t// camera\\t\\n\\tvec3 ce = vec3( cos( 0.232*time) * 10., 7.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );\\n\\tvec3 ro = ce;\\n\\tvec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\\n\\t\\n\\tfloat roll = -0.15*sin(0.5*time);\\n\\t\\n\\t// camera tx\\n\\tvec3 cw = normalize( ta-ro );\\n\\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n\\n\\tvec3 go = vec3( 0.0 );\\n\\tgo.x = (lefteye?-0.5*EYEDISTANCE:0.5*EYEDISTANCE);\\n\\tro += go.x*cu + go.y*cv;\\n\\n\\t// create offset voor left or right eye\\n\\tvec3 er = normalize( vec3( p.xy, FOV ) );\\n\\tvec3 rd = er.x*cu + er.y*cv + er.z*cw;\\n\\t\\n\\t\\n\\t\\n\\t// raytrace\\n\\tint material;\\n\\tvec3 normal, intersection;\\n\\tfloat dist;\\n\\t\\n\\tvec3 col = trace(ro, rd, intersection, normal, dist, material);\\n\\n#ifdef REFLECTION\\n\\tif( material > 0 ) {\\n\\t\\tvec3 ro = intersection + EPSILON*normal;\\n\\t\\trd = reflect( rd, normal );\\n\\t\\tcol += 0.05 * trace(ro, rd, intersection, normal, dist, material);\\n\\t}\\n#endif\\n\\t\\n\\tcol = pow( col, vec3(EXPOSURE, EXPOSURE, EXPOSURE) );\\t\\n\\tcol = clamp(col, 0.0, 1.0);\\n\\t\\n\\n\\n\\tfragColor = vec4( col,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4ds3WS","date":"1378461634","viewed":31259,"name":"Minecraft","description":"port of javascript minecraft: http://jsfiddle.net/uzMPU/ combined with voxel-shader by inigo quilez (https://www.shadertoy.com/view/4dfGzs).","likes":187,"published":"Public API","usePreview":0,"tags":["voxels","voxel","minecraft"]},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Minecraft. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4ds3WS\\n//\\n// port of javascript minecraft: http://jsfiddle.net/uzMPU/\\n// original code by Markus Persson: https://twitter.com/notch/status/275331530040160256\\n// combined with voxel-shader by inigo quilez (https://www.shadertoy.com/view/4dfGzs)\\n//\\n\\n#define SEALEVEL -25.\\n#define MAXSTEPS 180 \\n//#define HOUSE\\n\\nvec3 sundir = normalize( vec3(-0.5,0.6,0.7) );\\n\\nfloat hash( in float n ) {\\n    return fract(sin(n)*43758.5453);\\n}\\nfloat hash( in vec3 x ) {\\n\\tfloat n = dot( x, vec3(1.0,113.0,257.0) );\\n    return fract(sin(n)*43758.5453);\\n}\\nvec3 hash3( vec3 n ) {\\n\\treturn fract(sin(n)*vec3(653.5453123,4456.14123,165.340423));\\n}\\nfloat noise( in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\tf = f*f*(3.0-2.0*f);\\n\\t\\n\\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\\n\\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\\n\\treturn mix( rg.x, rg.y, f.z );\\n}\\nfloat noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\\n\\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0.0 ).x;\\n}\\nfloat sum(vec3 v) { return dot(v, vec3(1.0)); }\\n\\n// port of minecraft\\n\\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\\n\\t// 16x16 tex\\n\\tvec2 uv = floor( coord );\\n\\n    float n = uv.x + uv.y*347.0 + 4321.0 * float(i);\\n\\tfloat h = hash(n);\\n\\t\\t\\n    float br = 1. - h * (96./255.);\\n\\tcolor = vec3( 150./255., 108./255.,  74./255.); // 0x966C4A;\\n\\t\\t\\t\\n\\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\\n\\t\\n\\tif (i == 1) {\\n\\t\\tif( uv.y < (xm1 + 18.)) {\\n\\t\\t\\tcolor = vec3( 106./255., 170./255.,  64./255.); // 0x6AAA40;\\n\\t\\t} else if (uv.y < (xm1 + 19.)) {\\n\\t\\t\\tbr = br * (2. / 3.);\\n\\t\\t}\\n\\t}\\n\\tif (i == 4) {\\n\\t\\tcolor = vec3( 127./255., 127./255., 127./255.); // 0x7F7F7F;\\n\\t}\\t\\n\\tif (i == 7) {\\n\\t\\tcolor = vec3( 103./255., 82./255.,  49./255.); // 0x675231;\\n\\t\\tif ( h < 0.5 ) {\\n\\t\\t\\tbr = br * (1.5 - mod(uv.x, 2.));\\n\\t\\t}\\t\\n\\t}\\t\\n#ifdef HOUSE\\n\\tif (i == 5) {\\n\\t\\tcolor = vec3( 181./255.,  58./255.,  21./255.); // 0xB53A15;\\n\\t\\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\\n\\t\\t\\tcolor = vec3( 188./255., 175./255., 165./255.); // 0xBCAFA5;\\n\\t\\t}\\n\\t}\\n#endif\\n\\tif (i == 9) {\\n\\t\\tcolor = vec3(  64./255.,  64./255., 255./255.); // 0x4040ff;\\n\\t}\\t\\n\\tif (i == 8) {\\n\\t\\tcolor = vec3(  80./255., 217./255.,  55./255.); // 0x50D937;\\n\\t\\tif ( h < 0.5) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\tif (i == 10) {\\n\\t\\tcolor = vec3(0.65,0.68,0.7)*1.35; \\n\\t\\tbr = 1.;\\n\\t}\\n\\tcolor *= br;\\n\\t\\n\\treturn true;\\n}\\n\\n//=====================================================================\\n// Code by inigo quilez - iq/2013:\\n\\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\\n                    -0.80,  0.36, -0.48,\\n                    -0.60, -0.48,  0.64 );\\n\\nfloat mapTerrain( vec2 p ) {\\n\\tp *= 0.02;\\n\\n\\tfloat f;\\n    f  = 0.500*textureLod( iChannel1, p*0.01, 0. ).x;\\n    f += 0.1250*noise( p*4.01 );\\n\\treturn  max( 50.0*f-30., SEALEVEL);\\n}\\n\\nvec3 gro = vec3(0.0);\\n\\nbool map(in vec3 c ) {\\n\\tvec3 p = c + 0.5;\\n    \\n\\tfloat f = mapTerrain( p.xz );\\n\\n\\tvec2 fc = floor( c.xz * 0.05 );\\n\\tvec3 h = hash3( vec3( fc*vec2(213.123,2134.125), mapTerrain(fc) ) );\\t\\n\\tbool hit = false;\\n\\t\\n\\tif( h.z > 0.75 ) {\\n\\t\\tvec2 tp = floor(fc*20.+mod(h.yx*154.43125, 10.)) + 5.5;\\n\\t\\tfloat h = mapTerrain( tp );\\n\\t\\tif( h > SEALEVEL ) {\\t\\t\\n\\t\\t\\tif( all( equal( tp, p.xz ) ) ) hit = c.y < h+4.; // treetrunk\\n\\t\\t\\tif( distance( p, vec3( tp.x, h+6., tp.y ) ) < 2.5 ) hit = true; // leaves\\n\\t\\t} \\n\\t}\\n\\t\\n\\thit = c.y < f ? true:hit; // ground\\n\\t\\n\\tif( c.y > 8. && \\n\\t   sin( (c.y-8.)*(3.1415/32.)) * (10./(c.y-7.)) * noise( c*0.08+(0.7*iTime)*vec3(0.3, 0.07, 0.12) ) \\n\\t   > 0.6 ) hit = true; // clouds\\n\\n#ifdef HOUSE\\n\\tvec2 hc = abs(c.xz - vec2( 32., 130.)); // house\\n\\tif( all( lessThan( hc, vec2( 6., 10. ) ) ) && c.y < -hc.x-12. ) {\\n\\t\\thit = true;\\n\\t\\tif( all( lessThan( hc, vec2( 2., 10. ) ) ) && c.y < -18. && c.y > -23. ) {\\n\\t\\t\\thit = false;\\n\\t\\t}\\n\\t\\tif( all( lessThan( hc, vec2( 5., 9. ) ) ) && c.y < -18. && c.y > -23. ) {\\n\\t\\t\\thit = false;\\n\\t\\t}\\n\\t}\\n#endif\\n\\t\\n\\tif( distance( gro, c ) < 1.5 ) return false;\\n\\t\\n\\treturn hit;\\n}\\n\\n\\nint mapMaterial(in vec3 c ) {\\n\\tint mat = 0;\\n\\tvec3 p = c + 0.5;\\n    \\n\\tfloat f = ceil( mapTerrain( p.xz ) ); \\n\\t\\n\\tif( p.y <= f ) mat = 1; // ground\\n\\telse if( p.y < f+3. ) mat = 7; // treetrunk\\n\\telse if( p.y < f+10. ) mat = 8; // leaves\\n\\telse mat = 10; // clouds\\n\\t\\n#ifdef HOUSE\\n\\tvec2 hc = abs(c.xz - vec2( 32., 130.));\\n\\tif( c.y < 0. && all( lessThan( hc, vec2( 6., 10. ) ) ) ) {\\n\\t\\tmat = 5;\\n\\t\\tif( !map( c+vec3(0.,1.,0.) ) ) mat = 6;\\n\\t}\\n#endif\\n\\t\\n\\treturn mat;\\n}\\n\\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir ) {\\n\\tvec3 pos = floor(ro);\\n\\tvec3 ri = 1.0/rd;\\n\\tvec3 rs = sign(rd);\\n\\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\\n\\t\\n\\tfloat res = 0.0;\\n\\tvec3 mm = vec3(0.0);\\n\\tbool hit = false;\\n\\t\\n\\tfor( int i=0; i<MAXSTEPS; i++ ) \\n\\t{\\n\\t\\tif( hit ) break;\\n\\t\\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\\n\\t\\tdis += mm * rs * ri;\\n        pos += mm * rs;\\n\\t\\tif( map(pos) ) { hit = true;}\\n\\t}\\n\\n\\tvec3 nor = -mm*rs;\\n\\tvec3 vos = pos;\\n\\t\\n    // intersect the cube\\t\\n\\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\\n\\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\\n\\t\\n\\toDir = mm;\\n\\toVos = vos;\\n\\n\\treturn hit?t:0.;\\n\\n}\\n\\nfloat castVRay( in vec3 ro, in vec3 rd, in float maxDist ) {\\n\\tvec3 pos = floor(ro);\\n\\tvec3 ri = 1.0/rd;\\n\\tvec3 rs = sign(rd);\\n\\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\\n\\t\\n\\tfloat res = 1.0;\\n\\t\\n\\tfor( int i=0; i<18; i++ ) \\n\\t{\\n\\t\\tif( map(pos) ) {res=0.0; break; }\\n\\t\\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\\n\\t\\tdis += mm * rs * ri;\\n        pos += mm * rs;\\n\\t}\\n\\t\\n\\treturn res;\\n}\\n\\nvec3 path( float t ) {\\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\\n\\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\\n\\t\\n\\treturn vec3( p.x, mapTerrain(p)+2.+4.*(1.-cos(iTime*0.1)), p.y );\\n}\\n\\n\\n//=====================================================================\\n// Ambient occlusion \\n\\nvec4 edges( in vec3 vos, in vec3 nor, in vec3 dir )\\n{\\n\\tvec3 v1 = vos + nor + dir.yzx;\\n\\tvec3 v2 = vos + nor - dir.yzx;\\n\\tvec3 v3 = vos + nor + dir.zxy;\\n\\tvec3 v4 = vos + nor - dir.zxy;\\n\\n\\tvec4 res = vec4(0.0);\\n\\tif( map(v1) ) res.x = 1.0;\\n\\tif( map(v2) ) res.y = 1.0;\\n\\tif( map(v3) ) res.z = 1.0;\\n\\tif( map(v4) ) res.w = 1.0;\\n\\n\\treturn res;\\n}\\n\\nvec4 corners( in vec3 vos, in vec3 nor, in vec3 dir )\\n{\\n\\tvec3 v1 = vos + nor + dir.yzx + dir.zxy;\\n\\tvec3 v2 = vos + nor - dir.yzx + dir.zxy;\\n\\tvec3 v3 = vos + nor - dir.yzx - dir.zxy;\\n\\tvec3 v4 = vos + nor + dir.yzx - dir.zxy;\\n\\n\\tvec4 res = vec4(0.0);\\n\\tif( map(v1) ) res.x = 1.0;\\n\\tif( map(v2) ) res.y = 1.0;\\n\\tif( map(v3) ) res.z = 1.0;\\n\\tif( map(v4) ) res.w = 1.0;\\n\\n\\treturn res;\\n}\\n\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    // inputs\\t\\n\\tvec2 q = fragCoord.xy / iResolution.xy;\\n    vec2 p = -1.0 + 2.0*q;\\n    p.x *= iResolution.x/ iResolution.y;\\n\\t\\n    vec2 mo = iMouse.xy / iResolution.xy;\\n    if( iMouse.z < 0. ) mo=vec2(0.0);\\n\\t\\n\\tfloat time = 2.0*iTime + 50.0*mo.x;\\n    // camera\\n\\t\\n\\tfloat cr = 0.2*cos(0.1*iTime);\\t\\n\\tvec3 ro = path( time );\\n\\tvec3 ta = path( time+4. );\\n\\tta.y = ro.y;\\n\\tgro = ro;\\n\\t\\n\\t// build ray\\n    vec3 ww = normalize( ta - ro);\\n    vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\\n    vec3 vv = normalize(cross(ww,uu));\\n\\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\\n\\n\\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\\n\\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\\n\\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\\n\\tcol *= 0.95;\\n\\t\\n\\tvec3 vos, dir;\\n\\tfloat t = castRay( ro, rd, vos, dir );\\n\\t\\n\\tif( t>0.0 ) {\\n\\t\\tvec3 nor = -dir*sign(rd);\\n\\t\\t\\n\\t\\tvec3 pos = ro + rd*t;\\n\\t\\tint mMat = mapMaterial( vos );\\t\\t\\t\\n\\t\\tvec3 mpos = mod( pos * 16., 16. );\\n\\t\\t\\n\\t\\tif( mMat == 1 ) {\\n\\t\\t\\tif( map( vos + vec3(0., 1., 0. ) ) ) {\\n\\t\\t\\t\\tmMat = hash(vos) > 0.5?2:4; \\n\\t\\t\\t\\tif( map( vos + vec3(0., 2., 0. ) ) ) mMat = 4;\\n\\t\\t\\t}\\n\\t\\t\\tif ( vos.y < SEALEVEL ) mMat = 9;\\t\\n\\t\\t} \\n\\t\\t\\n\\t\\tvec3 mCol;\\n\\t\\tgetMaterialColor( mMat, nor.y!=0.?mpos.xz:nor.x!=0.?-mpos.zy+vec2(32.,32.):-mpos.xy+vec2(32.,32.),mCol );\\n\\t\\t\\n\\t\\t// lighting\\n\\t\\tfloat dif = clamp( dot( nor, sundir ), 0.0, 1.0 );\\n\\t\\tfloat sha = 0.0; if( dif>0.01) sha=castVRay(pos+nor*0.01,sundir,32.0);\\n\\t\\tfloat bac = clamp( dot( nor, normalize(sundir*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\\n\\t\\tfloat sky = 0.5 + 0.5*nor.y;\\n\\t\\tfloat amb = 1.0;//clamp(0.75 + pos.y/100.0,0.0,1.0);\\n\\t\\t\\t\\n        // ambient occlusion\\n\\t\\t\\n        vec4 ed = edges( vos, nor, dir );\\n        vec4 co = corners( vos, nor, dir );\\n        vec3 uvw = pos - vos;\\n        vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\\n\\t\\t\\n        float occ = 0.0; \\n        // (for edges)\\n        occ += (    uv.x) * ed.x;\\n        occ += (1.0-uv.x) * ed.y;\\n        occ += (    uv.y) * ed.z;\\n        occ += (1.0-uv.y) * ed.w;\\n        // (for corners)\\n        occ += (      uv.y *     uv.x ) * co.x*(1.0-ed.x)*(1.0-ed.z);\\n        occ += (      uv.y *(1.0-uv.x)) * co.y*(1.0-ed.z)*(1.0-ed.y);\\n        occ += ( (1.0-uv.y)*(1.0-uv.x)) * co.z*(1.0-ed.y)*(1.0-ed.w);\\n        occ += ( (1.0-uv.y)*     uv.x ) * co.w*(1.0-ed.w)*(1.0-ed.x);\\n        occ = 1.0 - occ/8.0;\\n        occ = occ*occ;\\n        occ = occ*occ;\\n\\t\\t\\n\\t\\t\\n\\t\\tvec3 lin = vec3(0.0);\\n\\t\\tlin += 4.0*dif*vec3(1.)*(0.5+0.5*occ)*(0.25+0.75*sha);\\n\\t\\tlin += 1.8*bac*vec3(1.0,0.5,1.0)*(0.5+0.5*occ);\\n\\t\\tlin += 4.0*sky*vec3(0.6,0.71,0.75)*occ;\\n\\t\\n\\t\\t\\n\\t\\tif( mMat == 10 ) {\\n\\t\\t\\tcol = mix( col, mCol*lin*0.6, 0.3);\\t\\t\\n\\t\\t} else {\\n\\t\\t\\t// atmospheric\\n\\t\\t\\tcol = mix( mCol*lin*0.2, col, 1.0-exp(-0.0000001*t*t*t) );\\n\\t\\t}\\t\\t\\t\\n\\t}\\n\\t\\n\\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\\n\\t\\n    // gamma\\t\\n\\tcol = pow( col, vec3(0.45) );\\n\\t\\n\\t// contrast\\n    col = col* 0.25 + 0.75*col*col*(3.0-2.0*col);\\n\\t\\t\\n    col = clamp( col, 0.0, 1.0 );\\n\\n\\t// vignetting\\t\\n\\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\\n\\t\\n\\tfragColor = vec4( col, 1.0 );\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lslGDB","date":"1378971661","viewed":6570,"name":"Water world","description":"A living, surrealistic, water world showing reflections and distance field rendering.\\nAs usual, almost al code is copy-paste from shaders by inigo quilez.\\nLens flare by musk! (https://www.shadertoy.com/view/4sX3Rs).","likes":41,"published":"Public API","usePreview":0,"tags":["distancefield","reflection","water","flare"]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Water world. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lslGDB\\n//\\n// As usual, almost al code is copy-paste from shaders by inigo quilez \\n// Lens flare by musk! (https://www.shadertoy.com/view/4sX3Rs)\\n// \\n\\n#define BUMPFACTOR 0.1\\n#define EPSILON 0.1\\n#define BUMPDISTANCE 36.\\n#define MAXDISTANCE 150.\\n\\nvec3 lig = normalize(vec3(-0.8,0.6,-0.2));\\n\\n\\nfloat noise(float t) {\\n\\treturn textureLod(iChannel0,vec2(t,.0)/iChannelResolution[0].xy, 0.0).x;\\n}\\n\\nfloat noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\n\\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\\n\\n\\treturn -1.0 + 2.0*textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).x;\\n}\\n\\nfloat noise( in vec3 x )\\n{\\n\\tfloat  z = x.z*64.0;\\n\\tvec2 offz = vec2(0.317,0.123);\\n\\tvec2 uv1 = x.xy + offz*floor(z); \\n\\tvec2 uv2 = uv1  + offz;\\n\\treturn mix(textureLod( iChannel0, uv1 ,0.0).x,textureLod( iChannel0, uv2 ,0.0).x,fract(z))-0.5;\\n}\\n\\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\\n\\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\\n                     -0.80,  0.36, -0.48,\\n                     -0.60, -0.48,  0.64 );\\n\\nfloat fbm( vec3 p ) {\\n    float f = 0.0;\\n    f += 0.5000*noise( p ); p = m3*p*2.02;\\n    f += 0.2500*noise( p ); p = m3*p*2.03;\\n    f += 0.1250*noise( p ); p = m3*p*2.01;\\n    f += 0.0625*noise( p );\\n    return f/0.9375;\\n}\\n\\nfloat base( in vec3 p){\\n\\treturn noise(p*0.005)*20.0;\\n}\\n\\nvec3 terrainOffset;\\nfloat terrainYFactor;\\n\\nfloat mapTerrain( in vec3 p ) {\\n\\tvec3 c = p  + terrainOffset;\\n\\treturn base(c)+7.0+0.03*base(c*10.)+2.0*p.y*terrainYFactor;\\n}\\n\\n// intersection functions\\n\\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\\t\\n\\tif (rd.y==0.0) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(100000.0, d);\\n\\tif( d > 0. ) {\\n\\t\\tdist = d;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\nvec3 intersect( in vec3 ro, in vec3 rd, in float maxd ) {\\n\\tfloat precis = 0.0005;\\n    float h=precis*2.0;\\n    float t = 0.0;\\n\\tfloat d = 0.0;\\n    float m = 1.0;\\n    for( int i=0; i<150; i++ ) {\\n\\t\\tif( abs(h) < precis || t > maxd ) break; {\\n\\t        t += h;\\n\\t\\t    h = 0.15*mapTerrain( ro+rd*t );\\n\\t\\t}\\n    }\\n\\n    if( t>maxd ) m=-1.0;\\n    return vec3( t, d, m );\\n}\\n\\nvec3 calcNormal( vec3 pos ) {\\n    vec3 eps = vec3(0.1,0.0,0.0);\\n\\n\\treturn normalize( vec3(\\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\\n           mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\\n}\\n\\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\\n{\\n    float res = 1.0;\\n    float t = mint;\\n\\tfloat h = 1.0;\\n    for( int i=0; i<32; i++ ) {\\n        h = 0.15*mapTerrain(ro + rd*t);\\n        res = min( res, k*h/t );\\n\\t\\tt += clamp( h, 0.02, 2.0 );\\n\\t\\t\\n\\t\\tif( h<0.0001 ) break;\\n    }\\n    return clamp(res,0.0,1.0);\\n}\\n\\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n ) {\\n\\tvec4 x = texture( sam, p.yz );\\n\\tvec4 y = texture( sam, p.zx );\\n\\tvec4 z = texture( sam, p.xy );\\n\\n\\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\\n}\\n\\nfloat waterHeightMap( vec2 pos, float time ) {\\n\\tvec2 posm = 0.01*pos * m2;\\n\\tposm.x += 0.001*time;\\n\\tfloat f = fbm( vec3( posm*1.9, time*0.01 ));\\n\\tfloat height = 0.5+0.1*f;\\n\\theight += 0.05*sin( posm.x*6.0 + 10.0*f );\\n\\t\\n\\tfloat h1 = 1.*mapTerrain( vec3(pos.x, -2.0, pos.y ) );\\n\\tfloat h2 = 1.*mapTerrain( vec3(pos.x, -1.5, pos.y ) );\\n\\tfloat h = min(h1,h2);\\n\\theight += 0.25*sin( 4.*h-(time+0.8*noise( pos.xy*2. ))*6. )/(1.5*h1+1.0);\\n\\t\\n\\treturn  height;\\n}\\n\\n//-----------------------------------------------------\\n// Lens flare\\n//\\n// by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\\n//\\n// Trying to get some interesting looking lens flares.\\n// \\n//  13/08/13: \\n// \\tpublished\\n// \\n// muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!\\n//-----------------------------------------------------\\n\\nvec3 lensflare(vec2 uv,vec2 pos) {\\n\\tvec2 main = uv-pos;\\n\\tvec2 uvd = uv*(length(uv));\\n\\t\\n\\tfloat ang = atan(main.x,main.y);\\n\\tfloat dist=length(main); dist = pow(dist,.1);\\n\\tfloat n = noise(vec2(ang*16.0,dist*32.0));\\n\\t\\n\\tfloat f0 = 1.0/(length(uv-pos)*16.0+1.0);\\n\\t\\n\\tf0 = f0+f0*(sin(noise((pos.x+pos.y)*2.2+ang*4.0+5.954)*16.0)*.1+dist*.1+.8);\\n\\t\\n\\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\\n\\n\\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\\n\\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\\n\\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\\n\\t\\n\\tvec2 uvx = mix(uv,uvd,-0.5);\\n\\t\\n\\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\\n\\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\\n\\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\\n\\t\\n\\tuvx = mix(uv,uvd,-.4);\\n\\t\\n\\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\\n\\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\\n\\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\\n\\t\\n\\tuvx = mix(uv,uvd,-0.5);\\n\\t\\n\\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\\n\\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\\n\\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\\n\\t\\n\\tvec3 c = vec3(.0);\\n\\t\\n\\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\\n\\tc = c*1.3 - vec3(length(uvd)*.05);\\n\\tc+=vec3(f0);\\n\\t\\n\\treturn c;\\n}\\n\\n//-----------------------------------------------------\\n\\t\\n\\nvec3 path( float time ) {\\n\\treturn vec3( 26.0*cos(0.2+0.35*.1*time*1.5), 1.5, 26.0*sin(0.1+0.5*0.099*time*1.5) );\\t\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    float time = iTime + 350.;\\n    terrainOffset =  0.5*vec3( 0., -0.4, 0. )*(time+0.12*sin(time*4.));\\n    terrainYFactor = (1.1+sin(time*0.125));\\n\\n    vec2 q = fragCoord.xy / iResolution.xy;\\n\\tvec2 p = -1.0 + 2.0*q;\\n\\tp.x *= iResolution.x / iResolution.y;\\n\\t\\n\\t\\n    // camera\\t\\n\\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x/iResolution.x;\\n\\ttime += off;\\n\\tvec3 ro = path( time+0.0 );\\n\\tvec3 ta = path( time+1.6 );\\n\\t\\n\\tro.y += clamp(0.4-mapTerrain(ro), 0., 1.);\\n\\t\\n\\tta.y *= 0.8 + 0.25*sin(0.09*time);\\n\\tfloat roll = 0.3*sin(1.0+0.07*time);\\n\\t\\n\\t// camera tx\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\\n\\tvec3 cu = normalize(cross(cw,cp));\\n\\tvec3 cv = normalize(cross(cu,cw));\\n\\t\\n\\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\\n\\n\\tfloat flare = dot( lig, normalize(ta-ro) );\\n\\t\\n    //-----------------------------------------------------\\n\\t// render\\n    //-----------------------------------------------------\\n\\t\\n\\t// raymarch\\n\\tbool reflection = false;\\t\\n\\tfloat dist, totaldist = 0., depth = 0.;\\n\\tvec3 normal;\\n\\tbool planeIntersect = intersectPlane( ro, rd, -2., dist );\\n\\t\\t\\n    vec3 tmat = intersect(ro,rd, planeIntersect?dist:MAXDISTANCE );\\n\\t\\n\\tif( planeIntersect && dist < tmat.x ) {\\t\\t\\t\\n\\t\\tro = ro+rd*dist;\\n\\t\\ttotaldist = dist;\\n\\t\\t\\n\\t\\tdepth = mapTerrain(ro);\\n\\t\\t\\n\\t\\tvec2 coord = ro.xz;\\n\\t\\tvec2 dx = vec2( EPSILON, 0. );\\n\\t\\tvec2 dz = vec2( 0., EPSILON );\\n\\t\\t\\n\\t\\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, dist) );\\n\\t\\t\\n\\t\\tnormal = vec3( 0., 1., 0. );\\n\\t\\tnormal.x = -bumpfactor * (waterHeightMap(coord + dx, time) - waterHeightMap(coord-dx, time) ) / (2. * EPSILON);\\n\\t\\tnormal.z = -bumpfactor * (waterHeightMap(coord + dz, time) - waterHeightMap(coord-dz, time) ) / (2. * EPSILON);\\n\\t\\tnormal = normalize( normal );\\n\\t\\t\\n\\t\\trd = reflect( rd, normal );\\n\\t\\t\\n\\t\\ttmat = intersect(ro,rd, MAXDISTANCE);\\n\\t\\treflection = true;\\n\\t} \\n\\t\\t\\n\\ttotaldist += tmat.x;\\n\\t\\n\\t// sky\\t \\n\\tvec3 col = 2.0*vec3(0.32,0.36,0.4) - rd.y*0.6;\\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\\n\\tcol += vec3(1.0,0.8,0.4)*0.2*pow( sun, 6.0 );\\n\\t\\t\\n\\tcol += 0.1*vec3( fbm( rd*0.2 ) );\\n\\t\\n    vec3 bgcol = col;\\n\\t\\t\\t\\n    if( tmat.z>-0.5 && totaldist < MAXDISTANCE)\\n    {\\n        // geometry\\n        vec3 pos = ro + tmat.x*rd;\\n        vec3 nor = calcNormal(pos);\\n\\t\\tvec3 ref = reflect( rd, nor );\\n\\t\\t\\t\\t\\n        // material\\n\\t\\tvec4 mate = vec4(0.0);\\n\\t\\tvec3 matpos = pos+terrainOffset;\\n\\t\\t\\n\\t\\tmate.w = 0.0;\\n\\t\\tmate.xyz = texcube( iChannel1, 0.1*matpos*vec3(1.0,2.2,1.0), nor ).xyz;\\n\\t\\tmate.xyz *= vec3(0.4,0.4,0.4);\\n\\t\\t\\n\\t\\tmate.xyz *= 3.0*vec3(0.32,0.36,0.4) - nor.y*0.6;\\n\\n\\t\\t// lighting\\n\\t\\tfloat occ = 1.0;//(0.5 + 0.5*nor.y);//*mate2.y;\\n        float amb = clamp(0.5 + 0.5*nor.y,0.0,1.0);\\n\\t\\tfloat bou = clamp(-nor.y,0.0,1.0)*clamp(1.0-pos.y/10.0,0.0,1.0);\\n\\t\\tfloat dif = max(dot(nor,lig),0.0);\\n        float bac = max(0.2 + 0.8*dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\\n\\t\\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.05*nor, lig, 0.0005, 32.0 );\\n        float fre = mate.w;//pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\\n        float spe = max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), 100.0 ) );\\n\\t\\t\\n\\t\\t// lights\\n\\t\\tvec3 brdf = vec3(0.0);\\n        brdf += 3.0*dif*vec3(1.10,0.90,0.80)*pow(vec3(sha),vec3(1.0,1.2,1.5));\\n\\t\\tbrdf += 1.0*amb*vec3(0.10,0.15,0.30)*occ;\\n\\t\\tbrdf += 1.0*bac*vec3(0.09,0.06,0.04)*occ;\\n\\t\\tbrdf += 2.5*bou*vec3(0.02,0.06,0.09)*occ;\\n\\t\\t\\n\\t\\tbrdf += 50.0*spe*vec3(1.0)*occ*dif*sha*clamp( (4.-pos.y)/6., 0., 1.)*clamp( 0.5+fbm(matpos), 0., 1.);\\n\\n\\t\\t// surface-light interacion\\n\\t\\tcol = mate.xyz* brdf + 0.7*sha*vec3(0.3,0.5,0.6)*fre*mate.w + mate.w*vec3(1.0,0.9,0.8)*spe*sha;\\t\\t\\t\\n\\t} \\n\\n\\tif( reflection ) {\\n\\t\\tcol = mix( bgcol, col, exp(-0.000001*pow(totaldist-dist,3.0)) );\\n\\t\\t\\n\\t\\tcol *= 0.9*vec3( 0.8, 0.9, 1. )*(0.5+clamp( depth*2., 0.0, 0.5));\\n\\n        float spe = max( 0.0, pow( clamp( dot(lig,rd), 0.0, 1.0), 100.0 ) )*softshadow( ro, lig, 0.0005, 32.0 );\\n\\t\\t\\n\\t\\tcol += 2.0*spe*vec3(1.0);\\n\\t\\t\\n\\t\\tif( dist != totaldist ) totaldist = dist;\\n\\t} \\n\\tcol = mix( bgcol, col, exp(-0.000001*pow(totaldist,3.0)) );\\n\\t\\n\\t// sun glow\\n    col += vec3(1.0,0.6,0.2)*0.2*pow( sun, 2.0 )*clamp( (rd.y+0.4)/(0.0+0.4),0.0,1.0);\\n\\n\\t\\n\\tvec2 sunuv =  2.7*vec2( dot( lig, cu ), dot( lig, cv ) );\\n\\t\\n\\tcol += vec3(1.4,1.2,1.0)*lensflare(p, sunuv)\\n\\t\\t*clamp( 3.*flare, 0., 1.);\\t\\n\\t\\n\\t//-----------------------------------------------------\\n\\t// postprocessing\\n    //-----------------------------------------------------\\n    // gamma\\n\\tcol = clamp( col, 0.0, 1.0 );\\n\\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\\n\\t\\n    // contrast, desat, tint and vignetting\\t\\n\\tcol = col*0.7 + 0.3*col*col*(3.0-2.0*col);\\n\\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.1 );\\n\\tcol *= vec3(1.03,1.02,1.0);\\n\\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\\n\\t\\n    fragColor = vec4( col, 1.0 );\\n}\\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MdXGW2","date":"1379503432","viewed":24665,"name":"Venice","description":"My attempt to create a procedural city with a lot of lights. The city is inspired by Venice. The shader is a combination of my shaders: https://www.shadertoy.com/view/Mdf3zM and https://www.shadertoy.com/view/lslGDB.\\n(I have never been in Venice btw)","likes":189,"published":"Public API","usePreview":0,"tags":["procedural","distancefield","reflection","water","city"]},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Venice. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MdXGW2\\n//\\n// My attempt to create a procedural city with a lot of lights. The city is inspired by Venice. \\n// The shader is a combination of my shaders: https://www.shadertoy.com/view/Mdf3zM and \\n// https://www.shadertoy.com/view/lslGDB.\\n// (I have never been in Venice btw)\\n//\\n\\n// #define SHOW_ORNAMENTS\\n#define SHOW_GALLERY\\n#define SHOW_LIGHTS\\n#define SHOW_BRIDGES\\n#define SHOW_MOON_AND_CLOUDS\\n\\n//----------------------------------------------------------------------\\n\\n#define BUMPFACTOR 0.2\\n#define EPSILON 0.1\\n#define BUMPDISTANCE 200.\\n\\n#define CAMERASPEED 15.\\n\\n#define BUILDINGSPACING 20.\\n#define MAXBUILDINGINSET 12.\\n\\n#define GALLERYHEIGHT 10.5\\n#define GALLERYINSET 2.5\\n\\nfloat time;\\n\\nfloat hash( float n ) {\\n\\treturn fract(sin(n)*32.5454412211233);\\n}\\nvec2 hash2( float n ) {\\n\\treturn fract(sin(vec2(n,n+1.0))*vec2(11.1451239123,34.349430423));\\n}\\nvec3 hash3( float n ) {\\n\\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(84.54531253,42.145259123,23.349041223));\\n}\\n\\nfloat noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\n\\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\\n\\n\\treturn -1.0 + 2.0*textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).x;\\n}\\n\\nfloat noise( in vec3 x )\\n{\\n\\tfloat  z = x.z*64.0;\\n\\tvec2 offz = vec2(0.317,0.123);\\n\\tvec2 uv1 = x.xy + offz*floor(z); \\n\\tvec2 uv2 = uv1  + offz;\\n\\treturn mix(texture( iChannel0, uv1 ,-100.0).x,texture( iChannel0, uv2 ,-100.0).x,fract(z))-0.5;\\n}\\n\\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\\n\\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\\n                     -0.80,  0.36, -0.48,\\n                     -0.60, -0.48,  0.64 );\\n\\nfloat fbm( vec3 p ) {\\n    float f = 0.0;\\n    f += 0.5000*noise( p ); p = m3*p*2.02;\\n    f += 0.2500*noise( p ); p = m3*p*2.03;\\n    f += 0.1250*noise( p ); p = m3*p*2.01;\\n    f += 0.0625*noise( p );\\n    return f/0.9375;\\n}\\n\\n//----------------------------------------------------------------------\\n// distance functions\\n\\nfloat sdBox( vec3 p, vec3 b ) {\\n  vec3 d = abs(p) - b;\\n  return min(max(d.x,max(d.y,d.z)),0.0) +\\n         length(max(d,0.0));\\n}\\nfloat sdSphere( vec3 p, float s ) {\\n    return length(p)-s;\\n}\\nfloat udBox( vec3 p, vec3 b) {\\n  return length(max(abs(p)-b,0.0));\\n}\\nfloat sdCylinderXY( vec3 p, vec2 h ) {\\n  return length(p.xy)-h.x; //max( length(p.xy)-h.x, abs(p.z)-h.y );\\n}\\nfloat sdCylinderXZ( vec3 p, vec2 h ) {\\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\\n}\\nfloat sdTriPrism( vec3 p, vec2 h ) {\\n    vec3 q = abs(p);\\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\\n}\\n\\n//----------------------------------------------------------------------\\n\\nfloat opS( float d1, float d2 ) {\\n    return max(-d2,d1);\\n}\\nfloat opU( float d1, float d2 ) {\\n    return min(d2,d1);\\n}\\nvec2 opU( vec2 d1, vec2 d2 ) {\\n\\treturn (d1.x<d2.x) ? d1 : d2;\\n}\\nfloat opI( float d1, float d2 ) {\\n    return max(d1,d2);\\n}\\n\\n//----------------------------------------------------------------------\\n// building functions\\n\\nfloat getXoffset( float z ) {\\n\\treturn 20.*sin( z*0.02);\\n}\\n\\nvec2 getBuildingInfo( in vec3 pos ) {\\n\\tvec2 res;\\n\\t// base index\\t\\n\\tres.x = floor( pos.z/BUILDINGSPACING + 0.5 );\\n\\t// base z coord\\n\\tres.y = res.x * BUILDINGSPACING;\\n\\t\\n\\t// negative index for buildings at the right side\\n\\tres.x *= sign( pos.x + getXoffset(pos.z) );\\n\\t\\n\\treturn res;\\n}\\n\\nvec4 getBuildingParams( in float buildingindex ) {\\n\\tvec3 h = hash3( buildingindex );\\n\\treturn vec4(\\n\\t\\t20. + 4.5*floor( h.x*7. ),\\t // height\\n\\t\\th.y*MAXBUILDINGINSET,\\n\\t\\tstep(h.z, 0.5),\\t\\t\\t\\t // sidewalk\\n\\t\\tstep(abs(h.z-0.4),0.25)\\t\\t // balcony\\n\\t);\\n}\\n\\nfloat baseBuilding( in vec3 pos, in float h ) {\\n\\tvec3 tpos = vec3( pos.z, pos.y, pos.x );\\n\\t\\n\\tfloat res = \\n\\topS(\\t\\t\\n\\t\\t// main building\\n\\t\\tudBox( tpos, vec3( 8.75, h, 8.75 ) ),\\n\\t\\t\\t// windows\\n\\t\\topS(\\n\\t\\t\\topU(\\n\\t\\t\\t\\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-2.5, tpos.z-5.), vec3( 1.,2.,4.) ),\\n\\t\\t\\t\\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, mod(tpos.y+4.5, 9.)-4.5, tpos.z-5.), vec2( 1.,4.) )\\n\\t\\t\\t),\\n\\t\\t\\tudBox( tpos+vec3(0.,-h,0.), vec3( 9.0, 1.0, 9.0 ) )\\n\\t\\t)\\t\\t\\n\\t);\\n\\t\\n\\tres =\\n\\topU( \\n\\t\\tres,\\n\\t\\topI( // main building windows\\n\\t\\t\\tudBox( tpos, vec3( 8.75, h, 8.75 ) ), \\n\\t\\t\\topU(\\n\\t\\t\\t\\tudBox(  vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y, tpos.z-8.45), vec3( 0.05, h, 0.05 ) ),\\n\\t\\t\\t\\tudBox(  vec3( tpos.x, mod(tpos.y+0.425, 1.75)-0.875, tpos.z-8.45), vec3( 10.0, 0.05, 0.05 ) )\\n\\t\\t\\t)\\n\\t\\t)\\n\\t);\\n\\treturn res;\\t\\n}\\n\\nfloat baseGallery( in vec3 pos ) {\\n\\tvec3 tpos = vec3( pos.z, pos.y, pos.x );\\n\\t\\n\\tfloat res = \\n\\topU(\\t\\n\\t\\topS(\\n\\t\\t\\tudBox( tpos+vec3(0.,0.,-GALLERYINSET), vec3( 8.75, GALLERYHEIGHT, 0.125 ) ),\\n\\t\\t\\topU(\\n\\t\\t\\t\\tsdBox( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-5., tpos.z-5.), vec3( 1.6,3.,10.) ),\\n\\t\\t\\t\\tsdCylinderXY( vec3( mod(tpos.x+1.75, 3.5)-1.75, tpos.y-8., tpos.z-5.), vec2( 1.6,10.) )\\n\\t\\t\\t)\\n\\t\\t),\\n\\t\\tsdTriPrism( vec3( tpos.z+3.4,-44.4+3.9*tpos.y, tpos.x), vec2( 7.5, 8.7 ) )\\n\\t);\\n\\t\\n\\treturn res;\\t\\n}\\n\\nfloat baseBalcony( in vec3 pos, in float h ) {\\n\\tfloat res = opI(\\t\\t\\n\\t\\t// main building\\n\\t\\tudBox( pos, vec3( 9.0, h, 9.0 ) ),\\n\\t\\t\\t// balcony\\n\\t\\tsdBox( vec3( pos.x, mod(pos.y+4.5, 9.)-7.5, pos.z-5.), vec3( 40.,0.5,40.) )\\n\\t);\\n\\treturn res;\\t\\t\\n}\\n\\nfloat baseBridge( in vec3 pos ) {\\n\\tpos.x *= 0.38;\\n\\tfloat res = \\n\\topS(\\t\\n\\t\\topU( \\n\\t\\t\\tsdBox( pos, vec3( 4., 2., 2.5 ) ),\\n\\t\\t\\tsdTriPrism( vec3( pos.x,-8.+3.*pos.y, pos.z), vec2( 4.5, 2.5 ) )\\n\\t\\t),\\n\\t\\tsdCylinderXY( pos+vec3( 0., 1.5, 0. ), vec2( 3.8, 3. ) )\\n\\t);\\n\\treturn res;\\n}\\n\\n// dinstancefield definitions\\n\\nfloat mapSimpleTerrain( in vec3 p ) {\\t\\n\\tp.x += getXoffset( p.z );\\t\\n\\tp.x = -abs( p.x );\\n\\tvec2 res = vec2( udBox( vec3(p.x+30., p.y-1., p.z) , vec3( 20., 100.25, 99999. ) ), 1.);\\n\\n#ifdef SHOW_BRIDGES\\n\\tfloat zcenter = mod(p.z+60.,120.)-70.;\\n\\tres = opU( res, vec2( baseBridge( vec3( p.x, p.y, zcenter) ), 8. ) ); // bridge\\n#endif\\n\\t\\n\\treturn min( res.x, p.y+10. );\\n}\\n\\nvec2 mapTerrain( in vec3 p ) {\\t\\n\\tvec2 buildingInfo = getBuildingInfo( p );\\n\\tvec4 buildingParams = getBuildingParams( buildingInfo.x );\\n\\t\\n\\tvec3 pos = p;\\n\\tpos.x += getXoffset( pos.z );\\n\\tpos.x = -abs( pos.x );\\n\\t\\n\\tvec2 res = vec2( udBox( vec3(pos.x+30., pos.y, pos.z) , vec3( 20., 0.25, 99999. ) ), 1.); // ground\\n\\t\\n\\tfloat z = buildingInfo.y;\\n\\tfloat zcenter = mod(pos.z+10.,20.)-10.;\\n\\n#ifdef SHOW_BRIDGES\\n\\tres = opU( res, vec2( baseBridge( vec3( pos.x, pos.y,  mod(pos.z+60.,120.)-70.) ), 8. ) ); // bridge\\n#endif\\n\\t\\t\\n\\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-6.0, zcenter) , 0.5 ), 3. ) ); // light\\t\\n\\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter+0.6) , 0.35 ), 3. ) ); // light\\t\\n\\tres =  opU( res, vec2( sdSphere( vec3( pos.x+11.5, pos.y-5.4, zcenter-0.6) , 0.35 ), 3. ) ); // light\\n\\t\\n\\tres =  opU( res, vec2( sdCylinderXZ( vec3( pos.x+11.5, pos.y, zcenter), vec2( 0.1, 6.0) ), 4.)); // \\n\\t\\t\\t\\t\\t\\t  \\n\\tpos += vec3( 28.75+buildingParams.y, 2.5, 0.);\\t\\t\\n\\tres =  opU( res, vec2( baseBuilding( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 2. ) );\\n\\n#ifdef SHOW_ORNAMENTS\\n\\tres = mix( res, opU( res, vec2( baseBalcony( vec3( pos.x, pos.y, zcenter), buildingParams.x+2.5  ), 9. ) ), buildingParams.w );\\n#endif\\n\\t\\n#ifdef SHOW_GALLERY\\n\\tpos.x += -8.75-GALLERYINSET;\\t\\t\\n\\tres = mix( res, opU( res, vec2( baseGallery( vec3( pos.x, pos.y, zcenter) ), 5. ) ), buildingParams.z );\\n#endif\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\treturn vec2( min( res.x,  11.-zcenter ), res.y );\\n}\\n\\nfloat waterHeightMap( vec2 pos ) {\\n\\tvec2 posm = 0.02*pos * m2;\\n\\tposm.x += 0.001*time;\\n\\tfloat f = fbm( vec3( posm*1.9, time*0.01 ));\\n\\tfloat height = 0.5+0.1*f;\\n\\theight += 0.05*sin( posm.x*6.0 + 10.0*f );\\n\\t\\n\\treturn  height;\\n}\\n\\n// intersection functions\\n\\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\\t\\n\\tif (rd.y==0.0) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(100000.0, d);\\n\\tif( d > 0. ) {\\n\\t\\tdist = d;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\nbool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph, out vec3 normal ) {\\n    vec3  ds = ro - sph.xyz;\\n    float bs = dot( rd, ds );\\n    float cs = dot(  ds, ds ) - sph.w*sph.w;\\n    float ts = bs*bs - cs;\\n\\t\\n    if( ts > 0.0 ) {\\n        ts = -bs - sqrt( ts );\\n\\t\\tif( ts>0. ) {\\n\\t\\t\\tnormal = normalize( ((ro+ts*rd)-sph.xyz)/sph.w );\\n\\t\\t\\treturn true;\\n\\t\\t}\\n    }\\n\\n    return false;\\n}\\n\\nvec3 intersect( const vec3 ro, const vec3 rd ) {\\n\\tfloat maxd = 1500.0;\\n\\tfloat precis = 0.01;\\n    float h=precis*2.0;\\n    float t = 0.0;\\n\\tfloat d = 0.0;\\n    float m = 1.0;\\n    for( int i=0; i<140; i++ ) {\\n\\t\\tif( abs(h)<precis || t>maxd ) break; {\\n\\t\\t\\tt += h;\\n\\t\\t\\tvec2 mt = mapTerrain( ro+rd*t );\\n\\t\\t\\th = 0.96*mt.x;\\n\\t\\t\\tm = mt.y;\\n\\t\\t}\\n    }\\n\\n    if( t>maxd ) m=-1.0;\\n    return vec3( t, d, m );\\n}\\n\\nfloat intersectSimple( const vec3 ro, const vec3 rd ) {\\n\\tfloat maxd = 10000.0;\\n\\tfloat precis = 0.01;\\n    float h=precis*2.0;\\n    float t = 0.0;\\n    for( int i=0; i<50; i++ ) {\\n\\t\\tif( abs(h)<precis || t>maxd ) break;  {\\n\\t\\t\\tt += h;\\n\\t\\t\\th = mapSimpleTerrain( ro+rd*t );\\n\\t\\t}\\n    }\\n\\n    return t;\\n}\\n\\nvec3 calcNormal( const vec3 pos ) {\\n    vec3 eps = vec3(0.1,0.0,0.0);\\n\\n\\treturn normalize( vec3(\\n           mapTerrain(pos+eps.xyy).x - mapTerrain(pos-eps.xyy).x,\\n           mapTerrain(pos+eps.yxy).x - mapTerrain(pos-eps.yxy).x,\\n           mapTerrain(pos+eps.yyx).x - mapTerrain(pos-eps.yyx).x ) );\\n}\\n\\nfloat calcAO( const vec3 pos, const vec3 nor ) {\\n\\tfloat totao = 0.0;\\n    float sca = 1.0;\\n    for( int aoi=0; aoi<5; aoi++ ) {\\n        float hr = 0.01 + 0.05*float(aoi);\\n        vec3 aopos =  nor * hr + pos;\\n        float dd = mapTerrain( aopos ).x;\\n        totao += -(dd-hr)*sca;\\n        sca *= 0.75;\\n    }\\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\\n}\\n\\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\\n{\\n\\tvec4 x = texture( sam, p.yz );\\n\\tvec4 y = texture( sam, p.zx );\\n\\tvec4 z = texture( sam, p.xy );\\n\\n\\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\\n}\\n\\nvoid getSkyColor( in vec3 rd, out vec3 bgcol, out vec3 col ) {\\n\\tvec3 lig = normalize( vec3( -2.5, 1.7, 2.5 ) );\\n\\t\\n\\tbgcol = 1.1*vec3(0.15,0.15,0.4) - rd.y*0.4;\\t\\n\\tbgcol *= 0.3;\\n    float moon = clamp( dot(rd,lig), 0.0, 1.0 );\\n\\tbgcol += vec3(2.0,1.5,0.8)*0.015*pow( moon, 32.0 );\\n\\t\\n\\tcol = bgcol;\\n\\t\\n#ifdef SHOW_MOON_AND_CLOUDS\\t\\n\\t// moon!\\n\\tvec3 normal;\\n\\tif( intersectSphere( vec3(0., 0., 0.), rd, vec4( lig, 0.03), normal ) ) {\\n\\t\\tfloat l = dot( normalize( vec3( 2.2, -1.9, 0.5)), normal )*(0.4+texture( iChannel2, normal.xy*0.5 ).y);\\n\\t\\tcol += 0.2*clamp( 2.5*vec3(2.0,1.5,0.8)*clamp(l, 0.0, 1.), vec3(0.), vec3(1.) );\\n\\t}\\t\\t\\t\\n\\t\\n// cloud function by inigo: https://www.shadertoy.com/view/Mds3z2 \\n\\tvec2 cuv = rd.xz*(100.0)/rd.y;\\n\\tfloat cc = texture( iChannel2, 0.0001*cuv +0.1+ 0.0013*time ).x;\\n\\tcc = 0.65*cc + 0.35*texture( iChannel2, 0.0001*2.0*cuv + 0.0013*.5*time ).x;\\n\\tcc = smoothstep( 0.3, 1.0, 1.1*cc );\\n\\tcol = mix( col, 0.1*vec3(0.05,0.05,0.4), 0.99*cc );\\n#endif\\n}\\n\\n//-----------------------------------------------------\\n\\nvec3 path( float _time ) {\\n\\tfloat z = _time*CAMERASPEED;\\t\\n\\treturn vec3( -getXoffset(z)+5.*cos(_time*0.1), 1.25, z );\\t\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    time = iTime + 43.;\\n    vec2 q = fragCoord.xy / iResolution.xy;\\n\\tvec2 p = -1.0 + 2.0*q;\\n\\tp.x *= iResolution.x / iResolution.y;\\n\\t\\n\\t\\n    // camera\\t\\n\\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x/iResolution.x;\\n\\ttime += off;\\n\\tvec3 ro = path( time+0.0 );\\n\\tvec3 ta = path( time+1.6 );\\n\\t\\n\\tta.y *= 1.1 + 0.25*sin(0.09*time);\\n\\tfloat roll = 0.3*sin(1.0+0.07*time);\\n\\t\\n\\t// camera tx\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\\n\\tvec3 cu = normalize(cross(cw,cp));\\n\\tvec3 cv = normalize(cross(cu,cw));\\n\\t\\n\\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\\n\\n\\t\\n    //-----------------------------------------------------\\n\\t// render\\n    //-----------------------------------------------------\\n\\t\\n\\t// raymarch\\n    float distSimple = intersectSimple(ro,rd);\\n\\tbool reflection = false;\\n\\t\\n\\tfloat dist, totaldist = 0., depth = 0.;\\n\\tvec3 normal, tmat, lp, lig;\\n\\t\\n\\tif( intersectPlane( ro, rd, 0., dist ) && dist < distSimple ) {\\t\\t\\t\\n\\t\\tro = ro+rd*dist;\\n\\t\\ttotaldist = dist;\\n\\t\\t\\n\\t\\tdepth = mapTerrain(ro).x;\\n\\t\\t\\n\\t\\tvec2 coord = ro.xz;\\n\\t\\tvec2 dx = vec2( EPSILON, 0. );\\n\\t\\tvec2 dz = vec2( 0., EPSILON );\\n\\t\\t\\n\\t\\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, dist) );\\n\\t\\t\\t\\t\\n\\t\\tnormal = vec3( 0., 1., 0. );\\n\\t\\tnormal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) / (2. * EPSILON);\\n\\t\\tnormal.z = -bumpfactor * (waterHeightMap(coord + dz) - waterHeightMap(coord-dz) ) / (2. * EPSILON);\\n\\t\\tnormal = normalize( normal );\\n\\t\\t\\n\\t\\trd = reflect( rd, normal );\\n\\t\\treflection = true;\\n\\t} \\n\\t\\n\\t// intersect scene\\t\\n\\ttmat = intersect(ro,rd);\\n\\ttotaldist += tmat.x;\\n\\t\\n\\t// sky\\t \\n\\tvec3 col, bgcol;\\n\\tgetSkyColor( rd, bgcol, col );\\n\\t\\t\\t\\n    vec3 pos = ro + tmat.x*rd;\\n\\t\\n    if( tmat.z>-0.5 && totaldist < 500.) {\\n\\t\\t// info building hit\\n\\t\\tvec2 buildingInfo = getBuildingInfo( pos );\\t\\t\\t\\n\\t\\tvec4 buildingParams = getBuildingParams( buildingInfo.x );\\n\\t\\t\\t\\n\\t\\tfloat z = buildingInfo.y;\\n\\t\\tlp = vec3( 11.5*sign(buildingInfo.x)-getXoffset(z), 6.0, z );\\n\\t\\tlig = normalize(lp-pos);\\n\\t\\t\\n\\t\\t// geometry\\n        vec3 nor = calcNormal(pos);\\n\\t\\t\\t\\t\\n        // material\\n\\t\\tvec3 mate, origmate;\\n\\t\\tvec3 matpos = pos*0.3;\\n\\t\\t\\n#ifdef SHOW_GALLERY\\n\\t\\tif( tmat.z == 5. )\\n\\t\\tmate.xyz = texcube(iChannel3, matpos, nor ).xyz*0.2;\\n\\t\\t\\telse\\n#endif\\n\\t\\torigmate = mate.xyz = texcube(iChannel1, matpos, nor ).xyz*0.4;\\n\\t\\t\\n\\t\\tbool aboveGallery = false;\\n\\t\\t\\n\\t\\tif( tmat.z == 3. ) mate.xyz = 160.*vec3(1.30,1.10,0.40);\\n\\t\\telse if( tmat.z == 2. ) mate.xyz *= \\n\\t\\t\\tclamp( 4.*texture( iChannel2, buildingInfo.x*vec2(1.4231153121) ).xyz\\n\\t\\t\\t,vec3(0.), vec3(1.) );\\n\\t\\t\\t\\n\\t\\t// lighting\\n\\t\\tfloat occ = calcAO( pos, nor );\\n        float amb = clamp(0.5 + 0.5*nor.y,0.0,1.0);\\n\\t\\tfloat dif = max(dot(nor,lig),0.0);\\n\\t\\tif( tmat.z == 5. && pos.y > GALLERYHEIGHT-2.6 ) {\\n\\t\\t\\tdif = abs(dot(nor,lig));\\n\\t\\t\\tmate.xyz = vec3(0.3,0.,0.);\\n\\t\\t}\\n\\t\\tdif /= dot( lp-pos,lp-pos );\\n\\t\\t\\n        float bac = max(0.2 + 0.8*dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0);\\n\\t\\t\\n\\t\\tif( buildingParams.z == 1. && pos.y > GALLERYHEIGHT ) {\\n\\t\\t\\taboveGallery=true;\\n\\t\\t}\\t\\t\\n\\t\\tvec3 lcol = aboveGallery?vec3(2.9, 1.65, 0.65 ):vec3(1.30,0.60,0.40);\\n\\t\\t\\n\\t\\t// lights\\n\\t\\tvec3 brdf = vec3(0.0);\\n        brdf += (60.0*dif)*lcol;\\n\\t\\tbrdf += (0.1*amb)*vec3(0.10,0.15,0.30);\\n\\t\\tbrdf += (0.1*bac)*vec3(0.09,0.03,0.01);\\n\\t\\t\\n\\t\\t// surface-light interacion\\n\\t\\tcol = (mate.xyz*brdf)*occ;\\n\\t\\t\\n\\t\\t// in room ?\\n\\t\\tfloat isLeft = sign(buildingInfo.x);\\n\\t\\t\\n\\t\\tif( ((pos.x+getXoffset( pos.z ))*isLeft > buildingParams.y+20.25 &&\\n\\t\\t    abs( pos.z-buildingInfo.y ) < 8.5 &&\\n\\t\\t  \\tpos.y < buildingParams.x-0.5) || false ) {\\n\\t\\t\\t\\n\\t\\t\\tvec2 roomcoord = pos.zy;\\n\\t\\t\\troomcoord.x = floor( (roomcoord.x-buildingInfo.y+5.) / 3.5 ) * 3.5 +\\n\\t\\t\\t\\t\\t\\t  floor( (buildingInfo.y+5. ) / 10.) * 10.;\\n\\t\\t\\troomcoord.y = floor( roomcoord.y / 9. ) * 9.;\\n\\t\\t\\t\\n\\t\\t\\tif( noise( vec3(roomcoord*1.15321*isLeft, time*0.0005 ) ) > -0.1 ) {\\n\\t\\t\\t\\tvec3 rlc = vec3( \\n\\t\\t\\t\\t\\t(buildingParams.y+3.+20.25)*isLeft-getXoffset( roomcoord.x-5. ), \\n\\t\\t\\t\\t\\troomcoord.y+5.5, \\n\\t\\t\\t\\t\\troomcoord.x-5. );\\n\\t\\t\\t\\t\\tvec3 ld = rlc-pos;\\n\\t\\t\\t\\t\\tdif = max(dot(nor,normalize(ld) ),0.0)/dot(ld,ld);\\n\\t\\t\\t\\t\\tcol += origmate*(dif*120.)*texture( iChannel2, roomcoord*0.1231 ).xyz;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n#ifdef SHOW_LIGHTS\\n\\t\\t// and extra lights!\\n\\t\\tfloat basez = floor( (pos.z)/2. )*2.-2.0;\\n\\t\\tfor(int i=0; i<3; i++) {\\n\\t\\t\\tbuildingInfo = getBuildingInfo( vec3( pos.x, pos.y, basez ) );\\n\\t\\t\\t// check if building lights here\\n\\t\\t\\tif( abs( basez - buildingInfo.y ) > 8.75 ||\\n\\t\\t\\t  \\tnoise( buildingInfo ) > 0.15 ) {\\n\\t\\t\\t\\tbasez += 2.;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tbuildingParams = getBuildingParams( buildingInfo.x );\\n\\t\\t\\tvec3 rlc = vec3( (buildingParams.y-1.+20.25)*isLeft-getXoffset( basez ),\\n\\t\\t\\t\\t\\t\\t7.7-1.5*abs(sin(basez*0.3)), basez );\\n\\t\\t\\tvec3 ld = rlc-pos;\\n\\t\\t\\tdif = max(dot(nor,normalize(ld) ),0.0)/dot(ld,ld);\\n\\t\\t\\tcol += mate.xyz*(dif*6.0)*texture( iChannel2, vec2(basez*time*0.0001)*0.1231 ).xyz;\\t\\n\\t\\t\\tbasez += 2.;\\n\\t\\t}\\n#endif\\n\\t\\n\\t\\tif( reflection ) {\\n\\t\\t\\tcol = mix( bgcol, col, exp(-0.00000001*pow(totaldist-dist,3.0)) );\\t\\t\\n\\t\\t\\tcol *= 0.9*vec3( 0.8, 0.9, 1. )*(0.5+clamp( depth*2., 0.0, 0.5));\\t\\t\\n\\t\\t\\tif( dist != totaldist ) totaldist = dist;\\n\\t\\t} \\n\\t\\tcol = mix( bgcol, col, exp(-0.00000001*pow(totaldist,3.0)) );\\n\\t} \\n\\n\\t\\n\\t//-----------------------------------------------------\\n\\t// postprocessing\\n    //-----------------------------------------------------\\n    // gamma\\n\\tcol = clamp( col, 0.0, 1.0 );\\n\\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\\n\\t\\n\\tcol *= vec3(1.03,1.02,1.0);\\n\\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\\n\\t\\n    fragColor = vec4( col, 1.0 );\\n}\\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4sfGWX","date":"1380117630","viewed":146859,"name":"Wolfenstein 3D","description":"Experiment to generate some well-known textures (from the [url=https://en.wikipedia.org/wiki/Wolfenstein_3D]first-person shooter video game developed by id Software[/url]) in a textureless shader.","likes":266,"published":"Public API","usePreview":1,"tags":["procedural","voxel","textures","wolfenstein"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wolfenstein. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4sfGWX\\n//\\n\\n#define NUM_MATERIALS 3\\n#define NUM_OBJECTS 1\\n#define SECONDS_IN_ROOM 3.\\n#define ROOM_SIZE 10.\\n#define MAXSTEPS 17\\n#define MATERIAL_DOOR 200\\n#define MATERIAL_DOORWAY 201\\n\\n#define COL(r,g,b) vec3(r/255.,g/255.,b/255.)\\n\\n#define time (iTime+40.)\\nvec3 rdcenter;\\n\\n//----------------------------------------------------------------------\\n// Math functions\\n\\nfloat hash( const float n ) {\\n    return fract(sin(n*14.1234512)*51231.545341231);\\n}\\nfloat hash( const vec2 x ) {\\n\\tfloat n = dot( x, vec2(14.1432,1131.15532) );\\n    return fract(sin(n)*51231.545341231);\\n}\\nfloat crossp( const vec2 a, const vec2 b ) { return a.x*b.y - a.y*b.x; }\\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\\nbool intersectSegment(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, out float dist, out float u) {\\n\\tvec2 p = ro.xz;\\tvec2 r = rd.xz;\\n\\tvec2 q = a-p;\\tvec2 s = b-a;\\n\\tfloat rCrossS = crossp(r, s);\\n\\t\\n\\tif( rCrossS == 0.){\\n\\t\\treturn false;\\n    } else {\\n\\t\\tdist = crossp(q, s) / rCrossS;\\n\\t\\tu = crossp(q, r) / rCrossS;\\n\\t\\n\\t\\tif(0. <= dist && 0. <= u && u <= 1.){\\n\\t\\t\\treturn true;\\n        } else {\\n\\t\\t\\treturn false;\\n        }\\n    }\\n}\\n\\n//----------------------------------------------------------------------\\n// Material helper functions\\n\\nfloat onCircle( const vec2 c, const vec2 centre, const float radius ) {\\n\\treturn clamp( 4.*(radius - distance(c,centre)), 0., 1. );\\n}\\nfloat onCircleLine( const vec2 c, const vec2 centre, const float radius ) {\\n\\treturn clamp( 1.-1.5*abs(radius - distance(c,centre)), 0., 1. );\\n}\\nfloat onLine( const float c, const float b ) {\\n\\treturn clamp( 1.-abs(b-c), 0., 1. );\\n}\\nfloat onBand( const float c, const float mi, const float ma ) {\\n\\treturn clamp( (ma-c+1.), 0., 1. )*clamp( (c-mi+1.), 0., 1. );\\n}\\nfloat onLineSegmentX( const vec2 c, const float b, const float mi, const float ma ) {\\n\\treturn onLine( c.x, b )*onBand( c.y, mi, ma );\\n}\\nfloat onLineSegmentY( const vec2 c, const float b, const float mi, const float ma ) {\\n\\treturn onLine( c.y, b )*onBand( c.x, mi, ma );\\n}\\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\\n\\treturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\\n}\\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\\n\\tfloat xl = clamp( (c.x-lt.x)/size, 0., 1. ); \\n\\tfloat xr = clamp( (rb.x-c.x)/size, 0., 1. );\\t\\n\\tfloat yt = clamp( (c.y-lt.y)/size, 0., 1. ); \\n\\tfloat yb = clamp( (rb.y-c.y)/size, 0., 1. );\\t\\n\\n\\treturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRect( c, lt, rb ) );\\n}\\nvec3 addKnob( const vec2 c, const vec2 centre, const float radius, const float strength, const vec3 col ) {\\n\\tvec2 lv = normalize( centre-c );\\n\\treturn mix( col, col*(1.0+strength*dot(lv,vec2(-0.7071,0.7071))), onCircle(c, centre, radius ) );\\n}\\nfloat stepeq( float a, float b ) { \\n\\treturn step( a, b )*step( b, a );\\n}\\n//----------------------------------------------------------------------\\n// Generate materials!\\n\\nvoid getMaterialColor( const int material, in vec2 uv, const float decorationHash, out vec3 col ) {\\t\\n\\tvec3 fgcol;\\n\\t\\n\\tuv = floor( mod(uv+64., vec2(64.)) );\\n\\tvec2 uvs = uv / 64.;\\n\\t\\n\\t// basecolor\\n\\tvec3 basecol = vec3( mix(55./255.,84./255.,uvs.y ) );\\t\\n\\tfloat br = hash(uv);\\n\\tcol = basecol;\\n// grey bricks\\n\\tif( material == 0 || material == 1 ) {\\n\\t\\tvec2 buv = vec2( mod(uv.x+1. + (floor((uv.y+1.) / 16.) * 16.), 32.) , mod( uv.y+1., 16.) );\\n\\t\\tfloat bbr = mix( 190./255., 91./255., (buv.y)/14. ) + 0.05*br;\\n\\t\\tif ( buv.x < 2. || buv.y < 2.) {\\n\\t\\t\\tbbr = 72./255.; \\n\\t\\t}\\n\\t\\tcol = vec3(bbr*0.95);\\n\\t\\tcol = addBevel( buv, vec2(1.,1.), vec2( 31.5, 15.), 2., 0.35, 1., 1., col);\\n\\t// blue wall\\n\\t\\tif( material == 1 ) {\\n\\t\\t\\tcol *= 1.3*COL(11.,50.,209.);\\n\\t\\t\\tcol = mix( col, COL(2.,15.,86.), onBand(uv.y,14.,49.));\\n\\t\\t\\tcol = mix( col, COL(9.,44.,185.)*(0.9+0.1*br), onBand(uv.y,16.,47.));\\n\\t\\t\\tcol = mix( col, COL(3.,25.,122.), onBand(uv.y,21.,42.));\\n\\t\\t\\tcol = addBevel( uv, vec2(-1.,16.), vec2( 65., 21.), 1., 0.35, 1., 1., col);\\n\\t\\t\\tcol = addBevel( uv, vec2(-1.,43.), vec2( 65., 48.), 1., 0.35, 1., 1., col);\\n\\t\\t\\t\\n\\t\\t\\tcol = mix( col, COL(2.,11.,74.), onRect(uv, vec2(22.,22.), vec2(42.,42.)));\\t\\t\\n\\t\\t\\tcol = mix( col, COL(9.,44.,185.)*(0.95+0.1*br), onRect(uv, vec2(22.,23.), vec2(42.,40.)));\\n\\t\\t\\tcol = addBevel( uv, vec2(22.,23.), vec2(42.,40.), 1., 0.2, -1., 1., col);\\n\\t\\t\\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.x-26.)/3.), onRect(uv, vec2(26.,23.), vec2(29.,29.)));\\n\\t\\t\\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)/2.), onRect(uv, vec2(22.,34.), vec2(29.,36.)));\\n\\t\\t\\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-27.)/2.), onRect(uv, vec2(35.,27.), vec2(42.,29.)));\\n\\t\\t\\tcol = mix( col, mix(COL(2.,11.,74.), COL(3.,25.,122.), (uv.y-34.)/8.), onRect(uv, vec2(35.,34.), vec2(38.,42.)));\\n\\t\\t}\\n\\t}\\n// wooden wall\\n\\telse if( material == 2 ) {\\n\\t\\tfloat mx = mod( uv.x, 64./5. ); \\n\\t\\tfloat h1 = hash( floor(uv.x/(64./5.)) );\\n\\t\\tfloat h2 = hash( 1.+1431.16*floor(uv.x/(64./5.)) );\\n\\t\\tcol = mix( COL(115.,75.,43.),COL( 71.,56.,26.), smoothstep( 0.2, 1., (0.7+h2)*abs(mod( h2-uv.y*(0.05+0.1*h2)+(1.+h1+h2)*sin(mx*(0.1+0.2*h2)), 2. )-1.) ) );\\n\\n\\t\\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x)/2.), step(uv.x,2.) );\\n\\t\\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-10.)/2.), step(10.,uv.x)*step(uv.x,12.) );\\n\\t\\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-26.)/2.), step(26.,uv.x)*step(uv.x,28.) );\\n\\t\\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-40.)/2.), step(40.,uv.x)*step(uv.x,42.) );\\n\\t\\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.x-54.)/2.), step(54.,uv.x)*step(uv.x,56.) );\\n\\n\\t\\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x- 8.)), step( 8.,uv.x)*step(uv.x,9.) );\\n\\t\\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-24.)), step(24.,uv.x)*step(uv.x,25.) );\\n\\t\\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-38.)), step(38.,uv.x)*step(uv.x,39.) );\\n\\t\\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-52.)), step(52.,uv.x)*step(uv.x,53.) );\\n\\t\\tcol = mix( col, mix(COL(83.,60.,31.), COL(142.,91.,56.), (uv.x-62.)), step(62.,uv.x) );\\n\\t\\t\\n\\t\\tcol = mix( col, mix(COL(40.,31.,13.), COL(142.,91.,56.), (uv.y)/2.), step(uv.y,2.) );\\n\\t\\tcol *= 1.-0.3*stepeq(uv.y,3.);\\n\\t}\\n// door\\n\\telse if( material == MATERIAL_DOOR ) {\\n\\t\\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)/(1.3-0.8*uvs.x)) ) );\\n\\t\\tfgcol = addBevel( uv, vec2(-1.,1.), vec2(62.,66.), 2., 0.4, -1., -1., fgcol);\\n\\t\\tfgcol = addBevel( uv, vec2( 6.,6.), vec2(57.,57.), 2.25, 0.5, -1., -1., fgcol);\\t\\n\\t\\tfgcol = mix( addKnob( mod( uv, vec2(8.) ), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uv,  vec2( 6.,6.), vec2(57.,57.)) ) ;\\n\\t\\t\\n\\t\\t//knob\\n\\t\\tfgcol *= 1.-0.2*onRect( uv, vec2( 13.5, 28.5 ), vec2( 22.5, 44.5 ) );\\n\\t\\tfgcol = mix( fgcol, mix( COL(44.,44.,44.),COL(152.,152.,152.), ((uv.x+(43.-uv.y)-15.)/25. ) ), onRect( uv, vec2( 15., 27. ), vec2( 24., 43. ) ) );\\n\\t\\tfgcol = addBevel( uv, vec2( 15., 27. ), vec2( 24., 43. ), 1., 0.45, 1., 1., fgcol);\\t\\n\\t\\tfgcol = mix( fgcol, addKnob( mod( uv, vec2(6.) ), vec2(4.25,5.5), 1.15, 0.75, fgcol ), onRect( uv,  vec2( 15., 27. ), vec2( 24., 43. ) ) ) ;\\n\\n\\t\\tfgcol *= 1.-0.5*onRect( uv, vec2( 16.5, 33.5 ), vec2( 20.5, 38.5 ) );\\n\\t\\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(37.-uv.y)-18.)/7. ) ), onRect( uv, vec2( 18., 33. ), vec2( 21., 37. ) ) );\\n\\t\\tfgcol = mix( fgcol, COL(0.,0.,0.), onRect( uv, vec2( 19., 34. ), vec2( 20., 35.7 ) ) );\\n\\n\\t\\tfgcol *= 1.-0.2*onRect( uv, vec2( 6.5, 29.5 ), vec2( 10.5, 41.5 ) );\\n\\t\\tfgcol = mix( fgcol, mix( COL(88.,84.,11.),COL(251.,242.,53.), ((uv.x+(40.-uv.y)-9.)/13. ) ), onRect( uv, vec2( 9., 29. ), vec2( 11., 40. ) ) );\\n\\t\\tfgcol = addBevel( uv, vec2( 9., 29. ), vec2( 11., 40. ), 0.75, 0.5, 1., 1., fgcol);\\t\\n\\t\\t\\n\\t\\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\\t\\n\\t}\\n// doorway\\n\\telse if( material == MATERIAL_DOORWAY ) {\\n\\t\\tfgcol = COL(44., 176., 175.)*(0.95+0.15*sin(-0.25+ 4.*((-0.9-uvs.y)/(1.3-0.8*uvs.x)) ) );\\n\\t\\tvec2 uvhx = vec2( 32.-abs(uv.x-32.), uv.y );\\n\\t\\tfgcol = addBevel( uvhx, vec2(-1.,1.), vec2(28.,66.), 2., 0.4, -1., -1., fgcol);\\n\\t\\tfgcol = addBevel( uvhx, vec2( 6.,6.), vec2(23.,57.), 2.25, 0.5, -1., -1., fgcol);\\t\\n\\t\\tfgcol = mix( addKnob( vec2( mod( uvhx.x, 22. ), mod( uvhx.y, 28. )), vec2(3.5), 1.65, 0.5, fgcol ), fgcol, onRect( uvhx,  vec2( 6.,6.), vec2(24.,57.)) ) ;\\n\\t\\tfgcol = mix( fgcol, vec3(0.), onRect( uv, vec2( 29., 1.), vec2( 35., 63.) ) );\\n\\t\\tcol = mix( basecol, fgcol, onRect( uv, vec2(1.,1.), vec2(62.,62.) ) );\\t\\n\\t}\\n\\t\\n// prison door\\t\\n\\tif( decorationHash > 0.93 && material < (NUM_MATERIALS+1) ) {\\t\\n\\t\\tvec4 prisoncoords = vec4(12.,14.,52.,62.);\\n\\t// shadow\\n\\t\\tcol *= 1.-0.5*onRect( uv,  vec2( 11., 13. ), vec2( 53., 63. ) );\\n\\t// hinge\\n\\t\\tcol = mix( col, COL(72.,72.,72.), stepeq(uv.x, 53.)*step( mod(uv.y+2.,25.), 5.)*step(13.,uv.y) );\\n\\t\\tcol = mix( col, COL(100.,100.,100.), stepeq(uv.x, 53.)*step( mod(uv.y+1.,25.), 3.)*step(13.,uv.y) );\\n\\t\\t\\n\\t\\tvec3 pcol = vec3(0.)+COL(100.,100.,100.)*step( mod(uv.x-4., 7.), 0. ); \\n\\t\\tpcol += COL(55.,55.,55.)*step( mod(uv.x-5., 7.), 0. ); \\n\\t\\tpcol = addBevel(uv, vec2(0.,17.), vec2(63.,70.), 3., 0.8, 0., -1., pcol);\\n\\t\\tpcol = addBevel(uv, vec2(0.,45.), vec2(22.,70.), 3., 0.8, 0., -1., pcol);\\n\\t\\t\\n\\t\\tfgcol = COL(72.,72.,72.);\\n\\t\\tfgcol = addBevel(uv, prisoncoords.xy, prisoncoords.zw+vec2(1.,1.), 1., 0.5, -1., 1., fgcol );\\n\\t\\tfgcol = addBevel(uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(2.,1.), 1., 0.5, 1., -1., fgcol );\\n\\t\\tfgcol = mix( fgcol, pcol, onRect( uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(3.,2.) ) );\\n\\t\\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uv, vec2(15.,32.5), vec2(21.,44.) ) );\\n\\t\\t\\n\\t\\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.) ), stepeq(uv.x, 15.)*step(37.,uv.y)*step(uv.y,38.) );\\n\\t\\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.)/3. ), stepeq(uv.x, 17.)*step(37.,uv.y)*step(uv.y,40.) );\\n\\t\\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 18.)*step(37.,uv.y)*step(uv.y,41.) );\\n\\t\\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(100.,100.,100.), (uv.y-37.)/3. ), stepeq(uv.x, 18.)*step(36.,uv.y)*step(uv.y,40.) );\\n\\t\\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 19.)*step(37.,uv.y)*step(uv.y,40.) );\\n\\n\\t\\tfgcol = mix( fgcol, mix( COL(84.,84.,84.), COL(108.,108.,108.), (uv.x-15.)/2. ), stepeq(uv.y, 32.)*step(15.,uv.x)*step(uv.x,17.) );\\n\\t\\tfgcol = mix( fgcol, COL(81.,81.,81.), stepeq(uv.y, 32.)*step(20.,uv.x)*step(uv.x,21.) );\\n\\n\\t\\tcol = mix( col, fgcol, onRect( uv, prisoncoords.xy, prisoncoords.zw ) );\\n\\t}\\n// flag\\n\\telse if( decorationHash > 0.63 && material < (NUM_MATERIALS+1) ) {\\t\\t\\n\\t\\tvec2 uvc = uv-vec2(32.,30.);\\n\\t\\n\\t// shadow\\t\\n\\t\\tvec4 shadowcoords = vec4( 14., 7., \\n\\t\\t\\t\\t\\t\\t\\t\\t  54., max( 56. + sin( uv.x*0.32-1. ),56.) ); \\n\\t\\tcol *= 1.-0.3*onRect( uv,  vec2( 6., 6. ), vec2( 61., 7. ) );\\n\\t\\tcol *= 1.-0.3*clamp( 0.25*(56.-uv.x), 0., 1.)*onRect( uv, shadowcoords.xy, shadowcoords.zw );\\n\\n\\t// rod\\n\\t\\tcol = mix( col, COL(250.,167.,98.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 4., 6.5 ) );\\n\\t\\tcol = mix( col, COL(251.,242.,53.), onLineSegmentY( uv, 5., 4., 60. ) );\\n\\t\\tcol = mix( col, COL(155.,76.,17.), onLineSegmentY( uv, 6., 4., 60. ) );\\n\\t\\tcol = mix( col, COL(202.,96.,25.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 26., 28. ) );\\n\\t\\tcol = mix( col, COL(251.,242.,53.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 3., 7. ) );\\n\\t\\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 25., 4.3, 5.5 ) );\\n\\t\\tcol = mix( col, COL(252.,252.,217.), onLineSegmentX( vec2( abs(uv.x-32.), uv.y ), 26., 5.3, 5.5 ) );\\n\\t\\tcol = mix( col, COL(0.,0.,0.), onLineSegmentY( vec2( abs(uv.x-32.), uv.y ), 6., 18.3, 19.5 ) );\\n\\n\\t// flag\\t\\n\\t\\tvec4 flagcoords = vec4( 13., min( 9.5 - pow(5.5* (uvs.x-0.5), 2.), 9. ), \\n\\t\\t\\t\\t\\t\\t    51., max( 55. + sin( uv.x*0.4+2.7 ),55.) ); \\n\\t\\n\\t\\tfgcol = COL(249.,41.,27.);\\n\\t\\t\\n\\t\\tfgcol = mix( fgcol, COL(255.,255.,255.), onBand( min(abs(uvc.x), abs(uvc.y)), 2., 4. ) );\\n\\t\\tfgcol = mix( fgcol, COL(72.,72.,72.), onLine( min(abs(uvc.x), abs(uvc.y)), 3. ) );\\t\\t\\n\\t\\t\\n\\t\\tfgcol = mix( fgcol, COL(255.,255.,255.), onCircle( uv, vec2(32.,30.), 12.5 ) );\\t\\n\\t\\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 11. ) );\\t\\n\\t\\tfgcol = mix( fgcol, COL(0.,0.,0.), onCircleLine( uv, vec2(32.,30.), 9. ) );\\n\\t\\t\\n\\t\\tvec2 uvr = vec2( (uvc.x-uvc.y)*0.7071, (uvc.y+uvc.x)*0.7071)*sign( uvc.x+0.5 );\\n\\t\\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(1.,4.) ) );\\n\\t\\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-4.2, 4.2), vec2(1.,6.15) ) );\\n\\t\\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2(-1.,-1.), vec2(4.,1.) ) );\\n\\t\\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uvr, vec2( 4.2,-1.), vec2(6.15,4.2) ) );\\n\\t\\n\\t\\tfgcol *= (0.8+0.2*sin( uv.x*0.4+2.7 ));\\n\\t\\tfgcol *= (0.8+0.2*clamp( 0.5*(uv.y-7.), 0., 1.));\\n\\t\\n\\t// mix flag on background\\n\\t\\tcol = mix( col, fgcol, onRect( uv, flagcoords.xy, flagcoords.zw ) );\\n\\t}\\n\\t\\n// fake 8-bit color palette and dithering\\t\\n\\tcol = floor( (col+0.5*mod(uv.x+uv.y,2.)/32.)*32.)/32.;\\n}\\nbool getObjectColor( const int object, in vec2 uv, inout vec3 icol ) {\\n\\tuv = floor( mod(uv, vec2(64.)) );\\n\\tvec2 uvs = uv / 64.;\\n\\tvec3 col = vec3(20./255.);\\n\\tfloat d;\\n\\t\\n// only a lamp for now\\n\\t\\n\\t// lamp top\\n\\td = distance( uv*vec2(1.,2.), vec2(28.1, 5.8)*vec2(1.,2.) );\\n\\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( d/8.-0.2, 0., 1.) ), \\n\\t\\t\\t  onCircle(uv, vec2(31.,13.6), 11.7 )*step( uv.y, 6. )); \\n\\tcol = mix( col, COL(9.,75.,6.), onCircleLine( uv, vec2(31.,14.), 11.6 ) *\\n\\t\\t\\t  step( length(uv-vec2(31.,13.6)), 11.7 )*step( uv.y, 6. ) );\\n\\tcol = mix( col, COL(100.,100.,100.), onLine( abs(uv.x-31.), 1. )*step( uv.y, 1. ) );\\n\\tcol = mix( col, COL(140.,140.,140.), onLine( abs(uv.x-31.), 0.25 )*step( uv.y, 1. )*step( 1., uv.y ) );\\n\\t\\n\\t// lamp bottom\\n\\td = distance( uv*vec2(1.,2.), vec2(30.5, 6.5)*vec2(1.,2.) );\\n\\tcol = mix( col, mix( COL(41.,250.,46.), COL(13.,99.,12.), clamp( abs(uv.x-31.)/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 7.) );\\n\\tcol = mix( col, mix( COL(41.,250.,46.), COL(16.,123.,17.), clamp( abs(uv.x-31.)/4.-1.25, 0., 1. )), step( abs(uv.x-31.), 9. )*stepeq( uv.y, 8.) );\\n\\tcol = mix( col, mix( COL(133.,250.,130.), COL(22.,150.,23.), clamp( abs(uv.x-31.)/4.-0.75, 0., 1. )), step( abs(uv.x-31.), 7. )*stepeq( uv.y, 9.) );\\n\\n\\tcol = mix( col, mix( COL(255.,251.,187.), col, clamp( d/4.5-0.6, 0., 1.) ), \\n\\t\\t\\t  onCircle(uv, vec2(31.,1.), 10.2 )*step( uv.y, 8. )*step( 7., uv.y )); \\n\\tcol = mix( col, mix( COL(255.,255.,255.), col, clamp( d/4.-0.7, 0., 1.) ), \\n\\t\\t\\t  onCircle(uv, vec2(31.,1.), 7.2 )*step( uv.y, 8. )*step( 7., uv.y )); \\n\\t\\t\\n\\t// floor\\n\\td = distance( vec2(mod(uv.x, 32.),uv.y)*vec2(1.5,30./3.), vec2(16., 61.5)*vec2(1.5,30./3.) );\\n\\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(d/15.-0.5, 0., 1.) ), step(d,24.5)); \\n\\tcol = mix( col, mix( COL(124.,124.,124.), COL(140.,140.,140.), clamp((uv.y-59.)/1., 0., 1.)), step(59.,uv.y)*step(uv.x, 57.)*step(7.,uv.x)); \\n\\tcol = mix( col, mix( COL(168.,168.,168.), COL(124.,124.,124.), clamp(abs(32.-uv.x)/10.-2., 0., 1.)), step(uv.y, 62.)*step(62.,uv.y)*step(uv.x, 61.)*step(3.,uv.x)); \\n\\tcol = mix( col, mix( COL(152.,152.,152.), COL(124.,124.,124.), clamp(abs(32.-uv.x)/10.-2.25, 0., 1.)), step(uv.y, 61.)*step(61.,uv.y)*step(uv.x, 59.)*step(5.,uv.x)); \\n\\n\\tcol = floor( (col)*32.)/32.;\\n\\tif( any(notEqual(col, vec3(floor((20./255.)*32.)/32.))) ) {\\n\\t\\ticol = col;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\n//----------------------------------------------------------------------\\n// Proocedural MAP functions\\n\\nbool isWall( const vec2 vos ) {\\n\\treturn vos.y<0.4*ROOM_SIZE || vos.y>2.75*ROOM_SIZE || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(0.,0.) ) );\\n}\\nbool isDoor( const vec2 vos ) {\\n\\treturn isWall(vos) && ((hash(vos)>0.75 &&  any( equal( mod( vos, vec2( ROOM_SIZE*0.5 ) ), vec2(2.) ) )) \\n\\t\\t    || any( equal( mod( vos, vec2( ROOM_SIZE ) ), vec2(ROOM_SIZE*0.5) ) )); \\n}\\nbool isObject( const vec2 vos ) {\\n\\treturn hash( vos*10. ) > 0.95;\\n}\\nbool map( const vec2 vos ) {\\n\\treturn isObject( vos ) || isWall( vos );\\n}\\n\\n//----------------------------------------------------------------------\\n// Render MAP functions\\n\\nbool intersectSprite( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 nor, out vec2 uv ) {\\n\\tfloat dist, u;\\n\\tvec2 a = vos.xz + nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\\n\\tvec2 b = vos.xz - nor.zx*vec2(-0.5,0.5) + vec2(0.5, 0.5);\\n\\tif( intersectSegment( ro, rd, a, b, dist, u) ) {\\n\\t\\tuv.x = u; uv.y = 1.-(ro+dist*rd).y;\\n\\t\\tif( sign(nor.x)<0. ) uv.x = 1.-uv.x;\\n\\t\\treturn uv.y>0.&&uv.y<1.;\\n\\t}\\n\\treturn false;\\n}\\nint getMaterialId( const vec2 vos ) {\\n\\treturn int( mod( 521.21 * hash( floor((vos-vec2(0.5))/ROOM_SIZE )  ), float(NUM_MATERIALS)) );\\n}\\nbool getColorForPosition( const vec3 ro, const vec3 rd, const vec3 vos, const vec3 pos, const vec3 nor, inout vec3 col ) {\\t\\n\\tvec2 uv;\\n\\n\\tif( isWall( vos.xz ) ) {\\n\\t\\tif( isDoor( vos.xz ) ) {\\n\\t\\t\\tif( intersectSprite( ro, rd, vos+nor*0.03, nor, uv ) ) {\\n\\t\\t\\t\\t// open the door\\n\\t\\t\\t\\tuv.x -= clamp( 2.-0.75*distance( ro.xz, vos.xz+vec2(0.5) ), 0., 1.);\\n\\t\\t\\t\\tif( uv.x > 0. ) {\\n\\t\\t\\t\\t\\tgetMaterialColor( MATERIAL_DOOR, uv*64., 0., col );\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t// a wall is hit\\n\\t\\tif( pos.y <= 1. && pos.y >= 0. ) {\\n\\t\\t\\tvec2 mpos = vec2( dot(vec3(-nor.z,0.0,nor.x),pos), -pos.y );\\n    \\t\\tfloat sha = 0.6 + 0.4*abs(nor.z);\\t\\t\\n\\t\\t\\tgetMaterialColor( isDoor( vos.xz+nor.xz )?MATERIAL_DOORWAY:getMaterialId(vos.xz), mpos*64., hash( vos.xz ), col );\\n\\t\\t\\tcol *= sha;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tif( isObject( vos.xz ) && !isWall( vos.xz+vec2(1.,0.) ) && !isWall( vos.xz+vec2(-1.,0.) )\\n\\t    && !isWall( vos.xz+vec2(0.,-1.) ) && !isWall( vos.xz+vec2(0.,1.) ) &&\\n\\t    intersectSprite( ro, rd, vos, rdcenter, uv ) ) {\\n\\t\\treturn getObjectColor( 0, uv*64., col );\\n\\t}\\n\\treturn false;\\n}\\n\\nbool castRay( const vec3 ro, const vec3 rd, inout vec3 col ) {\\n\\tvec3 pos = floor(ro);\\n\\tvec3 ri = 1.0/rd;\\n\\tvec3 rs = sign(rd);\\n\\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\\n\\t\\n\\tfloat res = 0.0;\\n\\tvec3 mm = vec3(0.0);\\n\\tbool hit = false;\\n\\t\\n\\tfor( int i=0; i<MAXSTEPS; i++ )\\t{\\n\\t\\tif( hit ) continue;\\n\\t\\t\\n\\t\\tmm = step(dis.xyz, dis.zyx);\\n\\t\\tdis += mm * rs * ri;\\n        pos += mm * rs;\\n\\t\\t\\n\\t\\tif( map(pos.xz) ) { \\n\\t\\t\\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\\n\\t\\t\\tfloat t = max ( mini.x, mini.z );\\t\\t\\t\\n\\t\\t\\thit = getColorForPosition( ro, rd, pos, ro+rd*t, -mm*sign(rd), col );\\n\\t\\t}\\n\\t}\\n\\treturn hit;\\n}\\n\\n//----------------------------------------------------------------------\\n// Some really ugly code\\n\\n#define CCOS(a) cos(clamp(a,0.,1.)*1.57079632679)\\n#define CSIN(a) sin(clamp(a,0.,1.)*1.57079632679)\\nvec3 path( const float t ) {\\n\\tfloat tmod = mod( t/SECONDS_IN_ROOM, 8. );\\n\\tfloat tfloor = floor( tmod );\\n\\t\\n\\tvec3 pos = vec3( 4.*ROOM_SIZE*floor(t/(SECONDS_IN_ROOM*8.))+0.5, 0.5, 0.5*ROOM_SIZE+0.5 );\\t\\n\\treturn pos + ROOM_SIZE*vec3(\\n\\t\\tclamp(tmod,0.,1.)+clamp(tmod-4.,0.,1.)+0.5*(2.+CSIN(tmod-1.)-CCOS(tmod-3.)+CSIN(tmod-5.)-CCOS(tmod-7.)), 0.,\\n\\t\\tclamp(tmod-2.,0.,1.)-clamp(tmod-6.,0.,1.)+0.5*(-CCOS(tmod-1.)+CSIN(tmod-3.)+CCOS(tmod-5.)-CSIN(tmod-7.)) );\\n}\\n\\n\\n//----------------------------------------------------------------------\\n// Main\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy / iResolution.xy;\\n    vec2 p = -1.0 + 2.0*q;\\n    p.x *= iResolution.x/ iResolution.y;\\n\\t\\n\\tvec3 ro = path( time );\\n\\tvec3 ta = path( time+0.1 );\\n\\t\\n    rdcenter = rotate( normalize( ta - ro), 0.3*cos(time*0.75) );\\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), rdcenter ));\\n    vec3 vv = normalize(cross(rdcenter,uu));\\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*rdcenter );\\n\\t\\n\\tvec3 col = rd.y>0.?vec3(56./255.):vec3(112./255.);\\n\\tcastRay( ro, rd, col );\\n\\t\\t\\n\\tfragColor = vec4( col, 1.0 );\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsB3zD","date":"1384716411","viewed":16628,"name":"Doom 2","description":"Reconstructing the first level of Doom 2 in a shader. This is, just like my shader 'Wolfenstein' ([url]https://www.shadertoy.com/view/4sfGWX[/url]), an experiment to reconstruct some well-known textures in a textureless shader.","likes":75,"published":"Public API","usePreview":0,"tags":["procedural","textures","doom2"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Doom 2. Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lsB3zD\\n//\\n\\n#define COL(r,g,b) vec3(r/255.,g/255.,b/255.)\\n\\n#define time iTime\\n\\n//----------------------------------------------------------------------\\n// Math functions\\n\\nfloat hash( const float n ) {\\n    return fract(sin(n*14.1234512)*51231.545341231);\\n}\\nfloat hash( const vec2 x ) {\\n\\tfloat n = dot( x, vec2(14.1432,1131.15532) );\\n    return fract(sin(n)*51231.545341231);\\n}\\nfloat crossp( const vec2 a, const vec2 b ) { return a.x*b.y - a.y*b.x; }\\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\\n\\n//----------------------------------------------------------------------\\n// Intersection functions\\n\\nbool intersectWall(const vec3 ro, const vec3 rd, const vec2 a, const vec2 b, const float height, \\n\\t\\t\\t\\t\\t  inout float dist, inout vec2 uv ) {\\n\\tvec2 p = ro.xz;\\tvec2 r = rd.xz;\\n\\tvec2 q = a-p;\\tvec2 s = b-a;\\n\\tfloat rCrossS = crossp(r, s);\\n\\t\\n\\tif( rCrossS == 0.) {\\n\\t\\treturn false;\\n\\t}\\n\\tfloat d = crossp(q, s) / rCrossS;\\n\\tfloat u = crossp(q, r) / rCrossS;\\n\\tfloat he = ro.y+rd.y*d;\\n\\t\\n\\tif(0. <= d && d < dist && 0. <= u && u <= 1. && he*sign(height) < height ) {\\n\\t\\tdist = d;\\n\\t\\tuv = vec2( -u*length(s), height-he );\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\nbool intersectFloor(const vec3 ro, const vec3 rd, const float height, \\n\\t\\t\\t\\t\\tinout float dist, inout vec2 uv ) {\\t\\n\\tif (rd.y==0.0) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(100000.0, d);\\n\\tif( d > 0. && d < dist) {\\n\\t\\tdist = d;\\n\\t\\tuv = ro.xz+dist*rd.xz;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\n//----------------------------------------------------------------------\\n// Material helper functions\\n\\nfloat sat( const float a ) { return clamp(a,0.,1.); }\\nfloat onCircleAA( const vec2 c, const vec2 centre, const float radius, const float aa ) {\\n\\treturn sat( aa*(radius - distance(c,centre)) );\\n}\\nfloat onLineX( const vec2 c, const float x ) {\\n\\treturn step(x,c.x)*step(c.x,x);\\n}\\nfloat onLineY( const vec2 c, const float y ) {\\n\\treturn step(y,c.y)*step(c.y,y);\\n}\\nfloat onBand( const float c, const float mi, const float ma ) {\\n\\treturn step(mi,c)*step(c,ma);\\n}\\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\\n\\treturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\\n}\\nvec3 addKnobAA( const vec2 c, const vec2 centre, const float radius, const float strength, const vec3 col ) {\\n\\tvec2 lv = normalize( centre-c );\\n\\treturn mix( col, col*(1.0+strength*dot(lv,vec2(-0.7071,0.7071))), onCircleAA(c, centre, radius, 4. ) );\\n}\\nfloat onBandAA( const float c, const float mi, const float ma ) {\\n\\treturn sat( (ma-c+1.) )*sat( (c-mi+1.) );\\n}\\nfloat onRectAA( const vec2 c, const vec2 lt, const vec2 rb ) {\\n\\treturn onBandAA( c.x, lt.x, rb.x )*onBandAA( c.y, lt.y, rb.y );\\n}\\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\\n\\tfloat xl = sat( (c.x-lt.x)/size); \\n\\tfloat xr = sat( (rb.x-c.x)/size);\\t\\n\\tfloat yt = sat( (c.y-lt.y)/size); \\n\\tfloat yb = sat( (rb.y-c.y)/size);\\n\\treturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRectAA( c, lt, rb ) );\\n}\\n\\n//----------------------------------------------------------------------\\n// Generate materials!\\n\\nvoid getMaterialColor( const int material, in vec2 uv, out vec3 col ) {\\t\\n\\tuv = floor( uv );\\n\\tfloat huv = hash(uv), huvx = hash(uv.x);\\n\\t\\n\\tif( material == 0 ) { // ceiling GRNLITE1\\n\\t\\tuv = mod(uv, vec2(64.)); vec2 centre = mod(uv,vec2(32.,16.));\\n\\t\\tcol = mix( COL(90.,98.,69.),COL(152.,149.,125.),(0.75*huv+0.25*mod(uv.x,2.)) );\\n\\t\\tcol = mix( col, mix(vec3(243./255.),vec3(169./255.), distance(centre,vec2(16.,8.))/6.5), onCircleAA(centre, vec2(16.,8.), 6.25, 0.75) );\\n\\t} \\n\\telse if( material == 1 ) { // ceiling FLOOR_1\\n\\t\\tuv = mod(uv, vec2(64.)); vec2 uv8 = mod(uv, vec2(32.,7.7));\\n\\t\\tfloat h = huv*huvx;\\n\\t\\tcol = mix( COL(136.,114.,95.), COL(143.,122.,92.), sat(4.*h) );\\t\\n\\t\\tcol = mix( col, COL(175.,126.,89.), sat( 2.*(hash(floor(uv*0.125))+huv-1.35) ) );\\n\\t\\tcol = mix( col, COL(121.,103.,83.), sat( onLineX(uv,0.)+onLineY(uv,63.)) );\\n\\t\\tcol = mix( col, COL(121.,103.,83.), onLineX(uv,31.)*huv );\\n\\t\\tuv8.x = abs(16.-uv8.x);\\n\\t\\tfloat d = min( max( uv8.x-8.,abs(uv8.y-4.) ), abs(distance(uv8,vec2(11.,4.))) )+huv;\\n\\t\\tvec3 fgcol = mix( col, col*sat(((16.-uv8.y)/12.)), step(d,3.) );\\n\\t\\tcol = mix( mix( fgcol, COL(114.,94.,78.), sat(d*(3.5-d)/4.)*step(2.,d) ), col, onRect(uv, vec2(32.,23),vec2(63.,39.) ) );\\n\\t}\\n\\telse if( material == 2 ) { // wall TEKGREN2 & TEKGREN5\\n\\t\\tuv = mod(uv, vec2(128.,128)); vec2 uv64 = mod(uv, vec2(64.,65.) ); vec2 uv24 = mod(uv64, vec2(64.,24.) );\\n\\t\\tfloat h = huv*huvx;\\n\\t\\tcol = mix( vec3(114./255.), vec3(98./255.), sat(2.*h) );\\n\\t\\tcol = mix( col, mix( COL(111.,114.,87.), COL(90.,98.,69.), sat(2.*h) ), sat( 100.*(hash(uv+vec2(523.,53.))*hash(150.-uv.x)-0.15)) );\\t\\n\\t\\tcol = addKnobAA( mod( uv24, vec2(3.,32.) ), vec2(0.,4.5), 1.1, 0.4, col );\\n\\t\\tcol = mix( col, COL(137.,141.,115.), 0.7*sat( onLineX(uv64,1.)+onLineY(uv,1.)+onLineY(uv24,0.)+onLineY(uv24,19.)+onLineY(uv64,59.) ) ); \\n\\t\\tcol = mix( col, COL(73.,81.,55.), sat( onLineX(uv64,0.)+onLineX(uv64,62.) ) ); \\n\\t\\tcol = mix( col, mix(COL(73.,81.,55.),vec3(38./255.),uv24.y-22.), onBand(uv24.y,22.,23.) ); \\n\\t\\tcol = mix( col, mix(COL(73.,81.,55.),vec3(38./255.),uv64.y-63.), onBand(uv64.y,63.,64.) ); \\n\\t\\tcol = mix( col, vec3(38./255.), sat( onLineY(uv,0.)+onLineX(uv64,63.) ) ); \\n\\t\\tcol = mix( col, COL(137.,141.,115.), onRect(uv,vec2(3.),vec2(60.,12.)) ); \\n\\t\\tcol = mix( col, mix( vec3(1.), COL(255.,253.,110.), sat( abs(uv.x-32.)/20.)-0.25*mod(uv.x,2.)), onRect(uv,vec2(4.),vec2(59.,11.)) ); \\n\\t}\\t\\n\\telse if( material == 3 ) { // wall BRONZE2\\n\\t\\tuv = mod(uv, vec2(64.,128)); float s = sin(31.15926*uv.x/64.);\\n\\t\\tcol = mix( vec3(75./255.), vec3(64./255.), huv );\\n\\t\\tcol = mix( col, COL(106.,86.,51.),  sat( 5.*(huv+(s+1.2)*(1.-(uv.y+44.)/64.))) * onBand(uv.y, 0., 30. ) );\\n\\t\\tcol = mix( col, COL(123.,105.,85.), sat( 2.*(0.5*huvx+huv+(s+1.7)*(1.-(uv.y+44.)/64.)-0.5) ) * onBand(uv.y, 0., 30. ) );\\n\\t\\tcol = mix( col, COL(106.,86.,51.),  sat( 5.*(huv+(s+0.7)*(1.-(uv.y+14.)/64.))) * onBand(uv.y, 30., 98. ) );\\n\\t\\tcol = mix( col, COL(123.,105.,85.), sat( 2.*(1.1*huvx+(s+1.7)*(1.-(uv.y+14.)/64.)-0.5) ) * onBand(uv.y, 30., 98. ) );\\n\\t\\tcol = mix( col, COL(7.,59.,20.), sat( huv*uv.y/96.-0.5) );\\n\\t\\tcol = mix( col, COL(106.,86.,51.),  sat( 5.*(huv+(s+1.2)*(1.-(uv.y-40.)/64.))) * onBand(uv.y, 98., 128. ) );\\n\\t\\tcol = mix( col, COL(123.,105.,85.), sat( 2.*(huvx+(s+1.7)*(1.-(uv.y-40.)/64.)-0.5) ) * onBand(uv.y, 98., 128. ) );\\t\\n\\t\\tcol = mix( col, mix(COL(110.,89.,70.),COL(130.,112.,92.),sat((uv.y-3.)/18.)), onRectAA(mod(uv,vec2(16.,128.)),vec2(6.5,1.5),vec2(12.5,21.5)) );\\n\\t\\tcol = addBevel( mod(uv,vec2(16.,128.)),vec2(5.5,-2.5),vec2(12.5,21.5), 2.3, 1., 0.1, 0.7, col );\\n\\t\\tcol = mix( col, addBevel( abs(mod(uv+vec2(0.,-85.),vec2(64.))-vec2(32.,0.)), vec2(15.5,0.5), vec2(34.5,52.5), 1.2, 1., 0.5, -0.7, col ), onBand(uv.y, 30.,97.));\\n\\t\\tcol = mix( col, 0.7*col, sat( onLineY(uv,127.)+onLineX(uv,0.)+onBand(uv.y, 97.,98.)+onBand(uv.y, 29.,30.)) );\\n\\t\\tcol = mix( col, 1.2*col, sat( onBand(uv.y, 98.,99.)+onBand(uv.y, 0.,1.)+onLineX(uv, 63.)) );\\n\\t\\tcol = mix( col, 0.75*col*uv.x, onBand(uv.x, 0., 1.)*onBand(uv.y, 30.,97.) );\\n\\t\\tcol *= 1.0-0.1*huv;\\n\\t}\\t\\n\\telse if( material == 4 ) { // wall STEP2\\n\\t\\tuv = mod(uv, vec2(64.,16.));\\n\\t\\tcol = mix( COL(182.,133.,93.), COL(132.,98.,66.), sat(huv-0.5) );\\n\\t\\tcol = mix( col, COL(129.,111.,79.), sat(1.-(uv.y-4.)/8.) );\\n\\t\\tcol = mix( col, COL(102.,82.,50.), sat((huv+1.)*onRectAA(mod(uv,vec2(32.,16.)), vec2(1.5,9.7), vec2(29.5,13.5))) );\\n\\t\\tcol = mix( col, COL(102.,82.,50.), 0.6*sat((huv+1.)*onRectAA(mod(uv,vec2(8.,16.)), vec2(2.5,3.5), vec2(5.5,6.2))) );\\n\\t\\tcol = mix( col, COL(143.,122.,92.), onLineY(uv,0.) );\\n\\t\\tcol = mix( col, COL(106.,86.,61.), onLineY(uv,2.) );\\n\\t\\tcol *= 1.-0.2*onLineY(uv,3.);\\n\\t}\\n\\telse if( material == 5 ) { // wall PIPE4\\n\\t\\tuv = mod(uv, vec2(128.,64.)); float huv2 = hash( uv*5312. );\\n\\t\\tcol = mix( mix(COL(184.,165.,144.),COL(136.,102.,67.),uv.x/128.), \\n\\t\\t\\t\\t   mix(COL(142.,122.,104.),COL(93.,77.,50.),uv.x/128.), sat(huv+huvx) );\\n\\t\\tcol *= 1.+0.5*sat(hash(uv.y)-0.7);\\n\\t\\tcol *= 1.-0.2*sat(hash(uv.y-1.)-0.7);\\n\\t\\tcol = mix( col, COL(102.,82.,50.), sat(0.2*huv2+3.*(huvx-0.7)) );\\n\\t\\tcol = mix( col, COL(165.,122.,85.), (0.75+0.5*huv2)*sat( onBandAA(uv.x,122.5,123.5)+onBandAA(uv.x,117.5,118.5)+onBandAA(uv.x,108.5,109.5) ) );\\n\\t\\tcol = mix( col, mix(  (1.-sat(0.2*abs(2.8-mod(uv.x,6.))))*mix(COL(175.,126.,89.),COL(143.,107.,71.),0.4*distance( mod(uv,vec2(6.)), vec2 (1.5))), COL(77.,68.,40.), onBandAA(mod(uv.x+1.,6.),0.,1.5)),\\n\\t\\t\\t\\t\\t\\t\\t\\t   (0.75+0.5*huv2)*sat( onBandAA(uv.x,6.5,11.5)+onBandAA(uv.x,54.5,59.5)+onBandAA(uv.x,66.5,70.5)+onBandAA(uv.x,72.5,78.5) ) );\\n\\t\\tcol = mix( col, mix( COL(82.,90.,64.), 1.2*COL(118.,125.,99.), huv*(sat(abs(uv.x-14.)-huv)+sat(abs(uv.x-62.)-huv)) ), onBandAA(uv.x,12.8,13.8) + onBandAA(uv.x,60.8,61.8));\\n\\t\\tcol = mix( col, vec3(0.), 0.3*(onBandAA(uv.y,18.8,21.8)*onBandAA(uv.x,40.8,52.8) + onBandAA(uv.x,0.1,3.7) + onBandAA(uv.x,41.3,44.2) + onBandAA(uv.x,48.9,51.8)+0.6*onBandAA(uv.x,80.1,81.6)));\\n\\t\\tcol = mix( col, mix( 1.2*COL(205.,186.,167.), COL(143.,122.,92.), 0.3*(sat(abs(uv.x-2.)+huv)+sat(abs(uv.x-43.)+huv)+sat(abs(uv.x-51.)+huv)) ), onBandAA(uv.x,0.8,2.8) + onBandAA(uv.x,42.1,43.3) + onBandAA(uv.x,49.8,51.2)+0.6*onBandAA(uv.x,80.8,81.5));\\n\\t\\tcol = mix( col, mix( 1.2*COL(205.,186.,167.), COL(154.,133.,105.), (sat(abs(uv.y-20.5)+huv)) ), onBandAA(uv.y,19.3,21.2)*onBandAA(uv.x,40.8,52.1));\\n\\t\\tfloat d = min( min( min( min( min( min( distance(uv,vec2(6.,39.)), 0.8*distance(uv,vec2(23.,45.)) ), 1.2*distance(uv,vec2(39.,30.)) )\\n\\t\\t\\t\\t\\t  , 1.5*distance(uv,vec2(48.,42.)) ), distance(uv,vec2(90.,32.)) ), 0.8*distance(uv,vec2(98.,50.)) ), 1.15*distance(uv,vec2(120.,44.)) );;\\n\\t\\td *= (1.-0.8*(sat(hash(uv.x+uv.y)-0.6)+sat(huvx-0.6)));\\n\\t\\tcol = mix( col,COL(93.,77.,50.), sat((7.-d)/8.) );\\n\\t\\tcol = mix( col, vec3(0.), pow(sat((5.-d)/6.),1.5) );\\n\\t}\\n\\telse if( material == 6 ) { // floor FLOOR_3_3\\n\\t\\tuv = mod(uv, vec2(64.));\\n\\t\\tcol = mix( COL(147.,126.,108.), COL(175.,152.,134.), sat( 1.5*(huv+hash(uv.x-uv.y)-0.95-uv.y/128.)) );\\n\\t\\tcol = mix( col, COL(175.,152.,134.), sat( 1.5*(huv+hash(uv.x-uv.y*1.1+5.)-1.8+uv.y/64.)) );\\n\\t\\tcol = mix( col, COL(130.,133.,108.), sat( 10.*(huv+hash(uv.x*1.1-uv.y+3.)-1.25)) );\\n\\t\\tcol = mix( col, mix( COL(118.,125.,99.), COL(130.,133.,108.), 1.-huv), sat(5.*(huv-1.5+uv.y/64.)) );\\n\\t\\tcol = mix( col, COL(129.,111.,91.), sat( onLineX(uv,0.)+onLineY(uv,63.) ) );\\n\\t\\tcol *= sat(0.92+huv);\\t\\t\\n\\t} \\n\\telse if( material == 7 ) { // floor FLOOR_0_1\\n\\t\\tuv = mod(uv, vec2(64.)); \\n\\t\\tfloat h = hash(3.*uv.x+uv.y);\\n\\t\\tcol = mix( COL(136.,114.,95.), COL(143.,122.,104.), sat(4.*h*huv) );\\n\\t\\tcol = mix( col, COL(129.,111.,91.), sat(h-0.5) );\\t\\n\\t\\tcol *= 1.+0.05*sat( 0.3+mod(uv.x,2.)*cos(uv.y*0.2)*huv );\\n\\t\\tcol = mix( col, COL(175.,126.,89.), sat( 2.*(hash(floor(uv*0.125))+huv-1.5) ) );\\n\\t\\tvec3 ncol = mix( col, COL(114.,94.,78.), sat( \\n\\t\\t\\t(0.4*huv+0.4)*onRectAA( mod(uv+vec2(0.,33.),vec2(64.)), vec2(6.5,0.5), vec2(36.5,58.5) )\\n\\t\\t\\t\\t\\t\\t -onRectAA( mod(uv+vec2(0.,33.),vec2(64.)), vec2(9.5,3.5), vec2(33.5,55.5) ) ));\\n\\t\\tncol = mix( ncol, COL(114.,94.,78.), sat( (0.6*huv+0.3)*onRectAA( mod(uv+vec2(0.,5.),vec2(64.)), vec2(33.5,0.5), vec2(59.5,60.5) ) ));\\n\\t\\tncol = mix( ncol, col, sat(               0.8*onRectAA( mod(uv+vec2(0.,5.),vec2(64.)), vec2(35.5,2.5), vec2(57.5,58.5) ) ));\\n\\t\\tncol = mix( ncol, COL(121.,103.,81.), sat( (0.8*huv+0.9)*onRectAA( mod(uv+vec2(0.,53.),vec2(64.)), vec2(18.5,0.5), vec2(41.5,22.5) ) ));\\n\\t\\tncol = mix( ncol, col, sat(               onRectAA( mod(uv+vec2(0.,53.),vec2(64.)), vec2(19.5,1.5), vec2(40.5,21.5) ) ));\\n\\t\\tncol = mix( ncol, COL(114.,94.,78. ), sat( (0.8*huv+0.6)*onRectAA( mod(uv+vec2(8.,46.),vec2(64.)), vec2(0.5,0.5), vec2(20.5,36.5) ) ));\\n\\t\\tcol  = mix( ncol, col, sat(               onRectAA( mod(uv+vec2(8.,46.),vec2(64.)), vec2(1.5,1.5), vec2(19.5,35.5) ) ));\\n\\t} else  {\\n\\t\\tcol = vec3(0.5);\\n\\t}\\n}\\n\\n//----------------------------------------------------------------------\\n// Render MAP functions\\n\\nstruct lineDef { vec2 a, b; float h; float l; int m; };\\n\\nvec3 castRay( const vec3 ro, const vec3 rd ) {\\n\\tlineDef ldfs[14];\\n\\tldfs[0]  = lineDef(vec2(192.,-448.), vec2(320.,-320.), 264., 128., 5 );\\n\\tldfs[1]  = lineDef(vec2(320.,-320.), vec2(256.,0.),    264., 128., 5 );\\n\\tldfs[2]  = lineDef(vec2(256.,0.),    vec2(64.,0.),     264., 128., 5 );\\n\\tldfs[4]  = lineDef(vec2(64.,0.),     vec2(0.,0.),       56., 208., 4 );\\n\\tldfs[3]  = lineDef(vec2(0.,448.),    vec2(320.,448.),  128., 224., 2 );\\n\\tldfs[5]  = lineDef(vec2(64.,0.),     vec2(-64.,0.),   -128., 208., 5 );\\n\\tldfs[6]  = lineDef(vec2(192.,-320.), vec2(128.,-320.), 264., 128., 3 );\\n\\tldfs[7]  = lineDef(vec2(128.,-320.), vec2(128.,-256.), 264., 128., 3 );\\n\\tldfs[8]  = lineDef(vec2(192.,0.),    vec2(0.,-320.),    16., 144., 4 );\\n\\tldfs[9]  = lineDef(vec2(160.,0.),    vec2(0.,-256.),    24., 160., 4 );\\n\\tldfs[10] = lineDef(vec2(128.,0.),    vec2(0.,-192.),    32., 176., 4 );\\n\\tldfs[11] = lineDef(vec2(96.,0.),     vec2(0.,-128.),    40., 192., 4 );\\n\\tldfs[12] = lineDef(vec2(64.,0.),     vec2(0.,-64.),     48., 208., 4 );\\n\\tldfs[13] = lineDef(vec2(64.,0.),     vec2(64.,320.),   128., 224., 2 );\\n\\t\\n\\tfloat dist = 999999., curdist; vec2 uv, curuv;\\n\\tvec3 col = vec3( 0. ); float lightning = 128.; int mat = 0;\\n\\n\\t// check walls\\n\\tfor( int i=0; i<14; i++ ) {\\n\\t\\tvec2 a = ldfs[i].a, b = ldfs[i].b; float h=ldfs[i].h; \\t\\t\\n\\t\\tif( intersectWall(ro, rd, a, b, h, dist, uv) || \\n\\t\\t\\tintersectWall(ro, rd, b*vec2(-1.,1.), a*vec2(-1.,1.), h, dist, uv) ) {\\n\\t\\t\\tmat = ldfs[i].m;\\n\\t\\t\\tlightning = ldfs[i].l * (1.-0.2*abs( normalize( (a-b).yx ).y ));\\n\\t\\t}\\n\\t}\\n\\tif( mat == 5 ) { // fix large texture on wall above portal\\n\\t\\tvec3 intersection = ro + rd*dist;\\n\\t\\tif( intersection.z > -0.1 ) {\\n\\t\\t\\tuv = -intersection.xy+vec2(64.,0.);\\n\\t\\t\\tlightning = 0.8*max(128., min(208., 248.-20.*floor(abs(intersection.x)/32.)));\\n\\t\\t}\\n\\t\\tuv *= 0.5;\\n\\t}\\n\\t\\n\\t// check floor and ceiling\\n\\tif( intersectFloor(ro, rd, 264., dist, uv ) ) {\\n\\t\\tmat = 1;\\n\\t\\tlightning =128.;\\n\\t\\tfloat c1=320., c2=196.;\\n\\t\\tfor( int i=4; i>=0; i-- ) {\\n\\t\\t\\tif( abs(uv.x)*(c1/c2)-uv.y < c1 ) {\\n\\t\\t\\t\\tlightning = float(208-i*16);\\n\\t\\t\\t}\\n\\t\\t\\tc1-=64.; c2-=32.;\\n\\t\\t}\\n\\t}\\n\\tif( intersectFloor(ro, rd, 8., dist, uv ) ) {\\n\\t\\tmat = 7;\\n\\t\\tlightning =128.;\\n\\t}\\t\\t\\n\\tfloat c1=64., c2=64., c3=48.;\\n\\tfor( int i=0; i<5; i++ ) {\\n\\t\\tcurdist = dist;\\n\\t\\tif( intersectFloor(ro, rd, c3, curdist, curuv ) && abs(curuv.x)*(c1/c2)-curuv.y < c1 ) {\\n\\t\\t\\tuv = curuv;\\n\\t\\t\\tmat = 7;\\n\\t\\t\\tdist = curdist;\\n\\t\\t\\tlightning = float(208-i*16);\\n\\t\\t}\\n\\t\\tc3-=8.; c1+=64.; c2+=32.;\\n\\t}\\n\\t// and hall\\t\\n\\tcurdist = dist;\\n\\tif( (intersectFloor(ro, rd, 56., curdist, curuv ) || intersectFloor(ro, rd, 128., curdist, curuv ) ) && curuv.y > 0. ) {\\n\\t\\tdist = curdist;\\n\\t\\tuv = curuv;\\n\\t\\tmat = rd.y>0.?0:6;\\n\\t\\tlightning = 224.;\\n\\t}\\n\\t\\n\\tgetMaterialColor( mat, uv, col );\\n\\t\\t\\n\\tcol *= 0.3*pow(2.*lightning/255., 2.5)*sat( 1.-curdist/2000. );\\t\\n\\t// fake 8-bit pallete\\n\\tcol = floor((col)*64.+vec3(0.5))/64.;\\n\\treturn col;\\n}\\n\\n//----------------------------------------------------------------------\\n// Camera path\\n\\nfloat getPathHeight( const float z, const float t ) {\\n\\treturn max( 0.+step(0.,z)*56.+step(z,-448.)*56.+\\n\\t\\tmix(56.,8.,(448.+z)/32.)*step(-448.,z)*step(z,-416.)+\\n\\t\\tmix(8.,56.,(320.+z)/320.)*step(z,0.)*step(-320.,z), 8.) + 56.;\\n}\\nvec2 path( const float t ) {\\n\\treturn vec2(32.*sin(t*0.21), -200.-249.*cos( max(0.,mod(t,30.)-10.)*(3.1415936/10.) ) );\\n}\\n\\n\\n//----------------------------------------------------------------------\\n// Main\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy/iResolution.xy;\\n\\tvec2 p = -1.0 + 2.0*q;\\n    p.x *= iResolution.x/ iResolution.y;\\n\\n\\tvec3 ro; ro.xz = path(time); \\n\\tvec3 ta; ta.xz = path(time+0.1) + vec2(0.,20.);\\n\\tta.y = ro.y = getPathHeight(ro.z, time);\\n\\t\\n    vec3 rdcenter =  rotate( normalize(ta - ro), 0.5*cos(time*0.5) );\\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), rdcenter ));\\n    vec3 vv = normalize(cross(rdcenter,uu));\\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.25*rdcenter );\\n\\t\\n\\tvec3 col = castRay( ro, rd );\\n\\t\\t\\n\\tfragColor = vec4( col, 1.0 );\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MsB3WR","date":"1385938213","viewed":37024,"name":"Misty Lake","description":"A misty lake in the morning. Cloud and noise functions by Inigo Quilez.\\n\\nYou can use your mouse to look around.","likes":311,"published":"Public API","usePreview":0,"tags":["raymarching","reflection","clouds","refraction","water","fog","mountains","lake"]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Misty Lake. Created by Reinder Nijhoff 2013\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MsB3WR\\n//\\n\\n#define BUMPFACTOR 0.1\\n#define EPSILON 0.1\\n#define BUMPDISTANCE 60.\\n\\n#define time (iTime+285.)\\n\\n// Noise functions by inigo quilez \\n\\nfloat noise( const in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\tf = f*f*(3.0-2.0*f);\\n\\t\\n\\tvec2 uv = (p.xy) + f.xy;\\n\\treturn textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\\n}\\n\\nfloat noise( const in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\tf = f*f*(3.0-2.0*f);\\n\\t\\n\\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\\n\\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\\n\\treturn mix( rg.x, rg.y, f.z );\\n}\\n\\nmat2 rot(const in float a) {\\n\\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\\t\\n}\\n\\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\\n\\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\\n                     -0.80,  0.36, -0.48,\\n                     -0.60, -0.48,  0.64 );\\n\\nfloat fbm( in vec3 p ) {\\n    float f = 0.0;\\n    f += 0.5000*noise( p ); p = m3*p*2.02;\\n    f += 0.2500*noise( p ); p = m3*p*2.03;\\n    f += 0.1250*noise( p ); p = m3*p*2.01;\\n    f += 0.0625*noise( p );\\n    return f/0.9375;\\n}\\n\\nfloat hash( in float n ) {\\n    return fract(sin(n)*43758.5453);\\n}\\n\\n// intersection functions\\n\\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {\\t\\n\\tif (rd.y==0.0) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(100000.0, d);\\n\\tif( d > 0. && d < dist ) {\\n\\t\\tdist = d;\\n\\t\\treturn true;\\n    } else {\\n\\t\\treturn false;\\n\\t}\\n}\\n\\n// light direction\\n\\nvec3 lig = normalize(vec3( 0.3,0.5, 0.6));\\n\\nvec3 bgColor( const in vec3 rd ) {\\n\\tfloat sun = clamp( dot(lig,rd), 0.0, 1.0 );\\n\\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\\n\\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\\n\\tcol *= 0.95;\\n\\treturn col;\\n}\\n\\n// coulds functions by inigo quilez\\n\\n#define CLOUDSCALE (500./(64.*0.03))\\n\\nfloat cloudMap( const in vec3 p, const in float ani ) {\\n\\tvec3 r = p/CLOUDSCALE;\\n\\n\\tfloat den = -1.8+cos(r.y*5.-4.3);\\n\\t\\t\\n\\tfloat f;\\n\\tvec3 q = 2.5*r*vec3(0.75,1.0,0.75)  + vec3(1.0,2.0,1.0)*ani*0.15;\\n    f  = 0.50000*noise( q ); q = q*2.02 - vec3(-1.0,1.0,-1.0)*ani*0.15;\\n    f += 0.25000*noise( q ); q = q*2.03 + vec3(1.0,-1.0,1.0)*ani*0.15;\\n    f += 0.12500*noise( q ); q = q*2.01 - vec3(1.0,1.0,-1.0)*ani*0.15;\\n    f += 0.06250*noise( q ); q = q*2.02 + vec3(1.0,1.0,1.0)*ani*0.15;\\n    f += 0.03125*noise( q );\\n\\t\\n\\treturn 0.065*clamp( den + 4.4*f, 0.0, 1.0 );\\n}\\n\\nvec3 raymarchClouds( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in vec3 fgc, const in float startdist, const in float maxdist, const in float ani ) {\\n    // dithering\\t\\n\\tfloat t = startdist+CLOUDSCALE*0.02*hash(rd.x+35.6987221*rd.y+time);//0.1*texture( iChannel0, fragCoord.xy/iChannelResolution[0].x ).x;\\n\\t\\n    // raymarch\\t\\n\\tvec4 sum = vec4( 0.0 );\\n\\tfor( int i=0; i<64; i++ ) {\\n\\t\\tif( sum.a > 0.99 || t > maxdist ) continue;\\n\\t\\t\\n\\t\\tvec3 pos = ro + t*rd;\\n\\t\\tfloat a = cloudMap( pos, ani );\\n\\n        // lighting\\t\\n\\t\\tfloat dif = clamp(0.1 + 0.8*(a - cloudMap( pos + lig*0.15*CLOUDSCALE, ani )), 0., 0.5);\\n\\t\\tvec4 col = vec4( (1.+dif)*fgc, a );\\n\\t\\t// fog\\t\\t\\n\\t//\\tcol.xyz = mix( col.xyz, fgc, 1.0-exp(-0.0000005*t*t) );\\n\\t\\t\\n\\t\\tcol.rgb *= col.a;\\n\\t\\tsum = sum + col*(1.0 - sum.a);\\t\\n\\n        // advance ray with LOD\\n\\t\\tt += (0.03*CLOUDSCALE)+t*0.012;\\n\\t}\\n\\n    // blend with background\\t\\n\\tsum.xyz = mix( bgc, sum.xyz/(sum.w+0.0001), sum.w );\\n\\t\\n\\treturn clamp( sum.xyz, 0.0, 1.0 );\\n}\\n\\n// terrain functions\\nfloat terrainMap( const in vec3 p ) {\\n\\treturn (textureLod( iChannel1, (-p.zx*m2)*0.000046, 0. ).x*600.) * smoothstep( 820., 1000., length(p.xz) ) - 2. + noise(p.xz*0.5)*15.;\\n}\\n\\nvec3 raymarchTerrain( const in vec3 ro, const in vec3 rd, const in vec3 bgc, const in float startdist, inout float dist ) {\\n\\tfloat t = startdist;\\n\\n    // raymarch\\t\\n\\tvec4 sum = vec4( 0.0 );\\n\\tbool hit = false;\\n\\tvec3 col = bgc;\\n\\t\\n\\tfor( int i=0; i<80; i++ ) {\\n\\t\\tif( hit ) break;\\n\\t\\t\\n\\t\\tt += 8. + t/300.;\\n\\t\\tvec3 pos = ro + t*rd;\\n\\t\\t\\n\\t\\tif( pos.y < terrainMap(pos) ) {\\n\\t\\t\\thit = true;\\n\\t\\t}\\t\\t\\n\\t}\\n\\tif( hit ) {\\n\\t\\t// binary search for hit\\t\\t\\n\\t\\tfloat dt = 4.+t/400.;\\n\\t\\tt -= dt;\\n\\t\\t\\n\\t\\tvec3 pos = ro + t*rd;\\t\\n\\t\\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\\t\\t\\n\\t\\tfor( int j=0; j<2; j++ ) {\\n\\t\\t\\tpos = ro + t*rd;\\n\\t\\t\\tdt *= 0.5;\\n\\t\\t\\tt += (0.5 - step( pos.y , terrainMap(pos) )) * dt;\\n\\t\\t}\\n\\t\\tpos = ro + t*rd;\\n\\t\\t\\n\\t\\tvec3 dx = vec3( 100.*EPSILON, 0., 0. );\\n\\t\\tvec3 dz = vec3( 0., 0., 100.*EPSILON );\\n\\t\\t\\n\\t\\tvec3 normal = vec3( 0., 0., 0. );\\n\\t\\tnormal.x = (terrainMap(pos + dx) - terrainMap(pos-dx) ) / (200. * EPSILON);\\n\\t\\tnormal.z = (terrainMap(pos + dz) - terrainMap(pos-dz) ) / (200. * EPSILON);\\n\\t\\tnormal.y = 1.;\\n\\t\\tnormal = normalize( normal );\\t\\t\\n\\n\\t\\tcol = vec3(0.2) + 0.7*texture( iChannel2, pos.xz * 0.01 ).xyz * \\n\\t\\t\\t\\t   vec3(1.,.9,0.6);\\n\\t\\t\\n\\t\\tfloat veg = 0.3*fbm(pos*0.2)+normal.y;\\n\\t\\t\\t\\t\\t\\n\\t\\tif( veg > 0.75 ) {\\n\\t\\t\\tcol = vec3( 0.45, 0.6, 0.3 )*(0.5+0.5*fbm(pos*0.5))*0.6;\\n\\t\\t} else \\n\\t\\tif( veg > 0.66 ) {\\n\\t\\t\\tcol = col*0.6+vec3( 0.4, 0.5, 0.3 )*(0.5+0.5*fbm(pos*0.25))*0.3;\\n\\t\\t}\\n\\t\\tcol *= vec3(0.5, 0.52, 0.65)*vec3(1.,.9,0.8);\\n\\t\\t\\n\\t\\tvec3 brdf = col;\\n\\t\\t\\n\\t\\tfloat diff = clamp( dot( normal, -lig ), 0., 1.);\\n\\t\\t\\n\\t\\tcol = brdf*diff*vec3(1.0,.6,0.1);\\n\\t\\tcol += brdf*clamp( dot( normal, lig ), 0., 1.)*vec3(0.8,.6,0.5)*0.8;\\n\\t\\tcol += brdf*clamp( dot( normal, vec3(0.,1.,0.) ), 0., 1.)*vec3(0.8,.8,1.)*0.2;\\n\\t\\t\\n\\t\\tdist = t;\\n\\t\\tt -= pos.y*3.5;\\n\\t\\tcol = mix( col, bgc, 1.0-exp(-0.0000005*t*t) );\\n\\t\\t\\n\\t}\\n\\treturn col;\\n}\\n\\nfloat waterMap( vec2 pos ) {\\n\\tvec2 posm = pos * m2;\\n\\t\\n\\treturn abs( fbm( vec3( 8.*posm, time ))-0.5 )* 0.1;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy / iResolution.xy;\\n    vec2 p = -1.0 + 2.0*q;\\n    p.x *= iResolution.x/ iResolution.y;\\n\\t\\n\\t// camera parameters\\n\\tvec3 ro = vec3(0.0, 0.5, 0.0);\\n\\tvec3 ta = vec3(0.0, 0.45,1.0);\\n\\tif (iMouse.z>=1.) {\\n\\t\\tta.xz *= rot( (iMouse.x/iResolution.x-.5)*7. );\\n\\t}\\n\\t\\t\\n\\tta.xz *= rot( mod(iTime * 0.05, 6.2831852) );\\n    \\n\\t// build ray\\n    vec3 ww = normalize( ta - ro);\\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\\n    vec3 vv = normalize(cross(ww,uu));\\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\\n\\n\\tfloat fresnel, refldist = 5000., maxdist = 5000.;\\n\\tbool reflected = false;\\n\\tvec3 normal, col = bgColor( rd );\\n\\tvec3 roo = ro, rdo = rd, bgc = col;\\n\\t\\n\\tif( intersectPlane( ro, rd, 0., refldist ) && refldist < 200. ) {\\n\\t\\tro += refldist*rd;\\t\\n\\t\\tvec2 coord = ro.xz;\\n\\t\\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, refldist) );\\n\\t\\t\\t\\t\\n\\t\\tvec2 dx = vec2( EPSILON, 0. );\\n\\t\\tvec2 dz = vec2( 0., EPSILON );\\n\\t\\t\\n\\t\\tnormal = vec3( 0., 1., 0. );\\n\\t\\tnormal.x = -bumpfactor * (waterMap(coord + dx) - waterMap(coord-dx) ) / (2. * EPSILON);\\n\\t\\tnormal.z = -bumpfactor * (waterMap(coord + dz) - waterMap(coord-dz) ) / (2. * EPSILON);\\n\\t\\tnormal = normalize( normal );\\t\\t\\n\\t\\t\\n\\t\\tfloat ndotr = dot(normal,rd);\\n\\t\\tfresnel = pow(1.0-abs(ndotr),5.);\\n\\n\\t\\trd = reflect( rd, normal);\\n\\n\\t\\treflected = true;\\n\\t\\tbgc = col = bgColor( rd );\\n\\t}\\n\\n\\tcol = raymarchTerrain( ro, rd, col, reflected?(800.-refldist):800., maxdist );\\n    col = raymarchClouds( ro, rd, col, bgc, reflected?max(0.,min(150.,(150.-refldist))):150., maxdist, time*0.05 );\\n\\t\\n\\tif( reflected ) {\\n\\t\\tcol = mix( col.xyz, bgc, 1.0-exp(-0.0000005*refldist*refldist) );\\n\\t\\tcol *= fresnel*0.9;\\t\\t\\n\\t\\tvec3 refr = refract( rdo, normal, 1./1.3330 );\\n\\t\\tintersectPlane( ro, refr, -2., refldist );\\n\\t\\tcol += mix( texture( iChannel2, (roo+refldist*refr).xz*1.3 ).xyz * \\n\\t\\t\\t\\t   vec3(1.,.9,0.6), vec3(1.,.9,0.8)*0.5, clamp( refldist / 3., 0., 1.) ) \\n\\t\\t\\t   * (1.-fresnel)*0.125;\\n\\t}\\n\\t\\n\\tcol = pow( col, vec3(0.7) );\\n\\t\\n\\t// contrast, saturation and vignetting\\t\\n\\tcol = col*col*(3.0-2.0*col);\\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.5 );\\n \\tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\\n\\t\\n    fragColor = vec4( col, 1.0 );\\n}\\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XsSSRW","date":"1409422111","viewed":19975,"name":"Abandoned base","description":"My entry to the in-official, nonexistent st mine compo :) If you like shiny things, define 'GOLD' at line 3. Use your mouse to look around.","likes":203,"published":"Public API","usePreview":0,"tags":["raymarching","distancefield","tunnel","water","reflections"]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Abandoned base. Created by Reinder Nijhoff 2014\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XsSSRW\\n//\\n\\n// #define GOLD\\n#define BUMPMAP\\n#define MARCHSTEPS 128\\n#define MARCHSTEPSREFLECTION 64\\n#define SPHERE\\n\\n//----------------------------------------------------------------------\\nconst vec2 dropPosition = vec2(1.05,2.1);\\nconst vec3 backgroundColor = vec3(0.9,0.5,0.2);\\n#define time iTime\\n#define stime2 sin(time*2.)\\n#define ctime2 cos(time*2.)\\n\\n//----------------------------------------------------------------------\\n// noises\\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\n\\nfloat noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    float n = p.x + p.y*157.0;\\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\\n}\\n\\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\\n\\nfloat fbm( vec2 p ) {\\n    float f = 0.0;\\n    f += 0.5000*noise( p ); p = m2*p*2.02;\\n    f += 0.2500*noise( p ); p = m2*p*2.03;\\n    f += 0.1250*noise( p ); p = m2*p*2.01;\\n    f += 0.0625*noise( p );\\n    \\n    return f/0.9375;\\n}\\n\\nmat2 rot(const in float a) {\\n\\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\\t\\n}\\n\\n//----------------------------------------------------------------------\\n// distance primitives\\n\\nfloat sdBox( in vec3 p, in vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdSphere( in vec3 p, in float s ) {\\n    return length(p)-s;\\n}\\n\\nfloat sdCylinder( in vec3 p, in vec2 h ) {\\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdPipe( in vec3 p, in vec3 h ) {\\n    return length(h.xy-p.xy) - h.z;\\n}\\n\\nfloat sdPPipe( in vec3 p, in vec3 h ) {\\n    return length(h.xy-p.xy) - h.z - 0.02*(max(sin(p.z*20.)-0.8,0.));\\n}\\n\\n//----------------------------------------------------------------------\\n// distance operators\\n\\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\\nvec2  opU( vec2  d2, vec2  d1 ) { return mix(d1,d2,step(d2.x,d1.x)); }//( d2.x<d1.x)? d2:d1; }\\nvec2  opS( vec2  d2, vec2  d1 ) { return mix(-d1,d2,step(-d1.x,d2.x)); }//(-d1.x>d2.x)?-d1:d2; }\\n\\n//----------------------------------------------------------------------\\n// Map functions\\n\\n#ifdef SPHERE\\nvec3 sP;\\n#endif\\n\\nfloat xoffset( float z) { \\n    return 2.1*sin(z*0.1);\\n}\\n\\nvec2 getSectorId( float z ) {\\n    float id = floor( (z+6.)/12.);\\n    return vec2( id, hash(id) );\\n}\\n\\nfloat map( vec3 p ) {\\n    float zorig = p.z;\\n    p = vec3( p.x+xoffset(p.z), p.y-2., mod( p.z + 6., 12. ) - 6.);\\n    \\n    float x = p.x*2., y = p.y-0.8, z = p.z;\\n    float d =  -sdBox( vec3((x+y)*0.7071, (y-x)*0.7071, z), vec3(3.8,3.8,20.) );\\n\\n\\td = opS( d, sdBox( p, vec3( 2.5, 2., 5.75 ) )  ); \\n    d = opU( d, sdPPipe( vec3(abs(p.x),p.y,p.z), vec3( 2.2, -1.7, 0.25 ) ) );\\n    d = opU( d, sdPipe( vec3(p.x,abs(p.y-0.2),p.z), vec3( 2.4, 1.5, 0.1 ) ) ); \\n    d = opU( d, sdPipe( vec3(p.x,p.y+0.6*cos(p.z*3.1415926/12.),p.z), vec3( -2.4, 1.8, 0.12 ) ) );\\n    \\n    d = opU( d, 2.2-p.y );\\n    float l = distance( p.xz, dropPosition );\\n\\tp.y += 0.003*sin(40.*l-6.*time)*exp(-4.*l);\\n    \\n    d = opU( d, p.y+2.03 );  \\n    d = opU( d,  sdSphere( vec3( p.x, p.y-2.3, p.z*0.3), 0.2) );\\n    \\n    if( getSectorId(zorig).y > 0.75 ) {\\n        d = opS( d,  sdCylinder( vec3(p.x, p.y-9., p.z), vec2(1.5,10.) ) );\\n\\n        vec3 pr = vec3( stime2*p.x+ctime2*p.z, p.y-2.4, stime2*p.z-ctime2*p.x);\\n        d = opU( d, sdBox( pr, vec3(3.0,0.1,0.1) ) );\\n        d = opU( d, sdBox( pr, vec3(0.1,0.1,3.0) ) );\\n    } \\n#ifdef SPHERE\\n    d = opU( d,  sdSphere( vec3( p.x, p.y, zorig)-sP, 0.2) );\\n#endif    \\n\\treturn d;\\n}\\n\\nfloat mapMaterial( vec3 p ) {\\n    float zorig = p.z;\\n    p = vec3( p.x+xoffset(p.z), p.y-2., mod( p.z + 6., 12. ) - 6.);\\n    \\n    float x = p.x*2., y = p.y-0.8, z = p.z;\\n    vec2 d = vec2( -sdBox( vec3((x+y)*0.7071, (y-x)*0.7071, z), vec3(3.8,3.8,20.) ), 5.);\\n\\n\\td = opS( d, vec2( sdBox( p, vec3( 2.5, 2., 5.75 ) ), 3. ) );\\n    d = opU( d, vec2( sdPPipe( vec3(abs(p.x),p.y,p.z), vec3( 2.2, -1.7, 0.25 ) ), 1. ) );    \\n    d = opU( d, vec2( sdPipe( vec3(p.x,abs(p.y-0.2),p.z), vec3( 2.4, 1.5, 0.1 ) ), 4. ) );\\n    d = opU( d, vec2( sdPipe( vec3(p.x,p.y+0.6*cos(p.z*3.1415926/12.),p.z), vec3( -2.4, 1.8, 0.12 ) ), 4. ) );\\n    \\n\\n    d = opU( d, vec2( 2.2-p.y, 5. ) );\\n    d = opU( d, vec2( p.y+2.03, 2. ) );  \\n    d = opU( d, vec2( sdSphere( vec3( p.x, p.y-2.3, p.z*0.3), 0.2), 6.) );\\n    \\n    if( getSectorId(zorig).y > 0.75 ) {\\n        d = opS( d, vec2( sdCylinder( vec3(p.x, p.y-4., p.z), vec2(1.5,2.) ), 5.) );\\n\\n        vec3 pr = vec3( stime2*p.x+ctime2*p.z, p.y-2.4, stime2*p.z-ctime2*p.x);\\n        d = opU( d, vec2( sdBox( pr, vec3(3.0,0.1,0.1) ), 4.) );\\n        d = opU( d, vec2( sdBox( pr, vec3(0.1,0.1,3.0) ), 4.) );\\n    } \\n    \\n#ifdef SPHERE\\n    d = opU( d,  vec2( sdSphere( vec3( p.x, p.y, zorig)-sP, 0.2), 7.) );\\n#endif\\n    \\n\\treturn abs(d.y);\\n}\\n\\n//----------------------------------------------------------------------\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    const vec2 e = vec2(1.0,-1.0)*0.005;\\n\\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \\n\\t\\t\\t\\t\\t    e.yyx*map( pos + e.yyx )   + \\n\\t\\t\\t\\t\\t    e.yxy*map( pos + e.yxy )   + \\n\\t\\t\\t\\t\\t    e.xxx*map( pos + e.xxx )   );  \\n    \\n#ifdef BUMPMAP\\n    vec3 p = pos * 20.;\\n    if( abs(pos.x+xoffset(pos.z))>2.48 )n = normalize( n + 0.1*vec3(0.,fbm(p.yz)-0.5,fbm(p.zy)-0.5));\\n#endif\\n    \\n    return n;\\n}\\n\\nvec3 int1, int2;\\n\\nfloat intersect( in vec3 ro, in vec3 rd ) {\\n\\tconst float maxd = 60.0;\\n\\tconst float precis = 0.001;\\n    float h = precis*2.0;\\n    float t = 0.;\\n    int1.z = -1.;\\n    \\n\\tfor( int i=0; i < MARCHSTEPS; i++ ) {\\n        if( h < precis ) {\\n            int1 = ro+rd*t;\\n            break;\\n        } \\n        h = map( ro+rd*t );\\n        t += h;\\n    }\\n    if( int1.z < 0. ) return -1.;\\n\\n    ro = ro + rd*t;\\n    vec3 nor = calcNormal(ro);           \\n    rd = reflect( rd, nor );\\n    ro += 0.1 * nor;\\n    t = 0.0;\\n    h = precis*2.0;\\n    \\n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\\n        if( h < precis ) {\\n            int2 = ro+rd*t;\\n            return 1.;\\n        }   \\n        h = map( ro+rd*t );\\n        t += h;\\n    }\\n\\n    return 0.;\\n}\\n\\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k ) {\\n\\tfloat res = 1.0;\\n    float t = mint;\\n    for( int i=0; i<16; i++ ) {\\n\\t\\tif( t>maxt ) break;\\n        float h = map( ro + rd*t );\\n        res = min( res, k*h/t );\\n        t += 0.03 + h;\\n    }\\n    return clamp( res, 0.0, 1.0 );\\n\\n}\\n\\nfloat calcOcc( in vec3 pos, in vec3 nor ) {\\n\\tfloat totao = 0.0;\\n    float sca = 1.0;\\n    for( int i=0; i<5; i++ )\\n    {\\n        float h = 0.02 + float(i)/4.0;\\n        float d = map( pos + h*nor );\\n        totao += clamp(h-d,0.0,1.0)*sca;\\n        sca *= 0.4;\\n    }\\n    return clamp( 1.0 - 2.0*totao, 0.0, 1.0 );\\n}\\n\\n\\n//----------------------------------------------------------------------\\n// shade\\n\\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\\n{\\n\\tvec4 x = texture( sam, p.yz );\\n\\tvec4 y = texture( sam, p.zx );\\n\\tvec4 z = texture( sam, p.xy );\\n\\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\\n}\\n\\nfloat calcLightning( in vec3 pos, in vec3 light, in vec3 nor, in float maxDist, in bool shadow ) {\\n    float sh = 1.;\\n    vec3 lig = ( light-pos );\\n    float im = length( lig );\\n\\tlig /= im;\\n   \\tif(shadow) sh = softshadow( pos, lig, 1.02, im, 32.0  );\\n    sh /= im;\\n    sh *= clamp(dot(nor,lig),0.,1.);\\n    return sh * (1.-smoothstep(0.,maxDist,im));\\n}\\n\\nvec3 shade( in vec3 ro, in vec3 pos, in bool shadow, in float m, in float r ) {\\n    vec3 light, col = vec3(0.);\\n    vec3 nor = calcNormal(pos);\\n    \\n\\tvec2 id = getSectorId(pos.z);\\n\\n    float occ = calcOcc( pos, nor );\\n    float dist, sh = 1., xo = xoffset(pos.z);\\n\\n    float rc = hash(id.x+43.);\\n    float gc = hash(id.x+153.);\\n    vec3 lc = normalize(vec3( max(rc,gc), min(rc,gc), 0.1 ) );\\n    \\n    if( id.y > 0.75 ) {\\n    \\tlight = vec3( -xo, 6.5, id*12. );\\n        light.xz += vec2( hash(id.x+56423.), hash(id.x+124.) ) - 0.5;\\n        sh =  8.;\\n        dist = 8.;\\n    } else {\\n\\t    light = vec3( -xo, 3.9, id*12. );\\n        sh = 3.;\\n        dist = 5.3;\\n        if( hash(id.x+234.) < 0.15 ) lc *= 1.-clamp( 10.*(fbm( vec2(time*10., id.x) )-2.5*id.y), 0., 1.);\\n        if( pos.y > 4. ) sh*=0.5;\\n    }\\n    \\n    sh *=  calcLightning( pos, light, nor, dist, shadow );\\n    \\n       \\n    if( m < 6.5 ) col = texcube( iChannel0, pos*0.5, nor ).xyz;\\n    if( m == 1. ) col *= 0.05;\\n    if( m == 4. && pos.y > 2. ) col *= vec3(0.1,0.,0.);\\n    if( m == 4. && pos.y < 2. ) col *= vec3(0.1,0.4,1.2);\\n    \\n    if( m == 5. ) col *= (1.+0.5*fbm(pos.yz*2.))*vec3(0.2,0.1,0.05);\\n    if( m == 2. ) col *= vec3(0.8,0.6,0.4);\\n    \\n    col *= lc * occ * sh;  \\n    \\n    if( m == 6. ) col = mix( 0.1*col, col*fbm(pos.xz*10.) + 0.8*lc, \\n                           (1.-smoothstep( 4.15, 4.2,pos.y)) *\\n                           smoothstep( 0.01, 0.04,abs(mod(pos.z+0.15,0.3)-0.15)) *\\n                           smoothstep( 0.01, 0.02,abs(pos.x+xo)));\\n\\n    col *= clamp(1.-2.*r, 0.65, 1.);\\n    \\n\\tcol = mix(  0.05*backgroundColor, col, exp( -0.04*distance(pos, ro) ) );\\n  \\n\\n    return col;\\n}\\n\\n//----------------------------------------------------------------------\\n// main\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \\n    vec2 q = fragCoord.xy / iResolution.xy;\\n\\tvec2 p = -1.0 + 2.0*q;\\n\\tp.x *= iResolution.x / iResolution.y;\\n       \\n    if (q.y < .12 || q.y >= .88) {\\n\\t\\tfragColor=vec4(0.,0.,0.,1.);\\n\\t\\treturn;\\n\\t}\\n    \\n    // camera\\n    float o = 0.2*noise(vec2(time,0.));\\n    float z = 2.*time+o;\\n    float x = -0.95*xoffset(z);\\n\\tvec3 ro = vec3(x,1.7+0.02*sin(time*1.13*2.*3.1415926+o), z-1.);\\n    vec3 ta = vec3(x,1.7, z+5.);\\n\\t\\n#ifdef SPHERE\\n\\tsP = vec3(sin(time), 1.6*cos(time*0.4), ro.z+9.+6.*sin(time*0.15) );\\n//    ta = mix(ta,sP+vec3(0.,2.,0.),0.2);\\n#endif\\n    \\n    if (iMouse.z>=1.) {\\n\\t\\tta.yz *= rot( -(0.5-iMouse.y/iResolution.y)*0.15 );\\n\\t\\tta.xz *= rot( -(0.5-iMouse.x/iResolution.x)*0.5 );\\n\\t}\\n    \\n    vec3 ww = normalize( ta - ro );\\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\\n    vec3 vv = normalize( cross(uu,ww));\\n\\tvec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\\n    \\n    vec3 col = 0.035*backgroundColor;\\n\\n    // raymarch\\n    float ints = intersect(ro ,rd );\\n    if(  ints > -0.5 ) {\\n        float m = mapMaterial(int1);        \\n   \\n#ifdef GOLD\\n\\t\\tfloat r = .8;\\n#else        \\n        float xo = xoffset(int1.z);\\n    \\tvec3 p = vec3( int1.x+xo, int1.y-2., mod( int1.z + 6., 12. ) - 6.);\\n        float l = m == 2.?exp(-2.*distance( p.xz, dropPosition )):0.;\\n        \\n        float r = 0.6 * clamp(2.*(fbm( int1.xz )-0.6+l), 0.0125, 1.)*clamp(2.-int1.y, 0., 1.);\\n        if(m == 1.) r = 0.05+0.3 * fbm( int1.xz * 20. );\\n         if(m == 7.) r = .8;       \\n        \\n        if(abs(int1.x+xo) > 2.49) {\\n            r = fbm(int1.yz*0.5)*0.4*\\n            clamp(2.*(fbm( int1.yz*vec2(3.2,24.)+vec2(0.5*time,0.) )-0.5+l), 0.0, 1.)\\n            *clamp(0.5*int1.y, 0., 1.);\\n        }\\n        if(m == 4.) { r = 0.1; }\\n#endif\\n        col = shade( ro, int1.xyz, true, m, r );\\n        \\n        if( ints > 0.5 ) {\\n            col += r * shade( int1.xyz, int2.xyz, false, mapMaterial(int2), 0. );\\n        }\\n\\t}\\n    \\n    // gamma\\n\\tcol = pow( clamp(col*2.,0.0,1.0), vec3(0.4545) );\\n\\tcol *= 1.2*vec3(1.,0.99,0.95);   \\n\\tcol = clamp(1.06*col-0.03, 0., 1.);   \\n\\n    fragColor = vec4( col, 1.0 );\\n}\\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"//----------------------------------------------------------------------\\n// noises\\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\n\\nfloat noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    float n = p.x + p.y*157.0;\\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\\n}\\n\\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\\n\\nfloat fbm( vec2 p ) {\\n    float f = 0.0;\\n    f += 0.5000*noise( p ); p = m2*p*2.32;\\n    f += 0.2500*noise( p ); p = m2*p*2.23;\\n    f += 0.1250*noise( p ); p = m2*p*2.31;\\n    f += 0.0625*noise( p ); p = m2*p*2.21;\\n    f += 0.03125*noise( p );\\n  \\n    return f;\\n}\\n\\n//----------------------------------------------------------------------\\n// Wind function by Dave Hoskins https://www.shadertoy.com/view/4ssXW2\\n\\nvec2 Hash( vec2 n)\\n{\\n\\tvec4 p = texture( iChannel0, n*vec2(.78271, .32837), -100.0 );\\n    return (p.xy + p.zw) * .5; \\n}\\n\\n\\n//--------------------------------------------------------------------------\\nvec2 Noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\\n    return res-.5;\\n}\\n\\n//--------------------------------------------------------------------------\\nvec2 FBM( vec2 p ) {\\n    vec2 f;\\n\\tf  = 0.5000\\t * Noise(p); p = p * 2.32;\\n\\tf += 0.2500  * Noise(p); p = p * 2.23;\\n\\tf += 0.1250  * Noise(p); p = p * 2.31;\\n    f += 0.0625  * Noise(p); p = p * 2.28;\\n    f += 0.03125 * Noise(p);\\n    return f;\\n}\\n\\n//--------------------------------------------------------------------------\\nvec2 Wind(float n) {\\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\\n    \\n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\\n    \\n\\treturn noise;\\n}\\n\\n//----------------------------------------------------------------------\\n\\nvec2 getSectorId( float z ) {\\n    float id = floor( (z+6.)/12.);\\n    return vec2( id, hash(id) );\\n}\\n\\nfloat soundLampExist(in float z) {\\n    vec2 id = getSectorId(z);\\n    if( hash(id.x+234.) < 0.15 && id.y < 0.75) return 1.;\\n\\treturn 0.;\\n}\\n\\nfloat soundCeilExist(in float z) { \\n    vec2 id = getSectorId(z);\\n    if( id.y < 0.75) return 0.;\\n\\treturn 1.;\\n}\\n\\nvec2 soundLamp(in float t) {\\n    float l = 1. - clamp(2.*fbm( vec2(t*10., 2.) ), 0., 1.);\\n\\treturn 0.1*vec2( hash(t*0.001), hash(t*0.001+0.1) ) * l;\\n}\\n\\nvec2 soundCeil(in float t) {\\n\\treturn (Wind(t*0.025) + Wind(t*4.)*0.15) * (0.75+0.2*sin(t*8.));\\n}\\n\\nvec2 soundStep(in float t) {\\n    float o = 0.2*noise(vec2(t,0.));\\n    float i = fract(t*1.23+o);\\n    \\n    return Wind(t*0.025) * clamp(i*10.,0.,1.) * clamp(1.-i*6., 0., 1.);\\n}\\n\\nvec2 getSound(in vec2 sl, in vec2 sc, in float z) {\\n    return 0.9*soundLampExist(z)*sl + 0.2*soundCeilExist(z)*sc;\\n}\\n\\nvec2 mixSounds(in float t, in float z) {\\n    float zm = floor( (z+6.)/12. ) * 12.;\\n    \\n    vec2 sound = vec2(0.);\\n    vec2 sl = soundLamp(t);\\n    vec2 sc = soundCeil(t);\\n    \\n    sound += getSound(sl, sc, zm-24.) * pow( mix(1., 0., clamp( abs(zm-24. - z)/24., 0., 1. ) ), 2.);\\n    sound += getSound(sl, sc, zm+24.) * pow( mix(1., 0., clamp( abs(zm+24. - z)/24., 0., 1. ) ), 2.);\\n    sound += getSound(sl, sc, zm-12.) * pow( mix(1., 0., clamp( abs(zm-12. - z)/24., 0., 1. ) ), 2.);\\n    sound += getSound(sl, sc, zm+12.) * pow( mix(1., 0., clamp( abs(zm+12. - z)/24., 0., 1. ) ), 2.);\\n    sound += getSound(sl, sc, zm)     * pow( mix(1., 0., clamp( abs(zm - z)/24., 0., 1. ) ), 2.);\\n    \\n    return sound + soundStep(t);    \\n}\\n\\nvec2 getSounds(in float t, in float z) {\\n    vec2 m2 = mixSounds(t, z); \\n    \\n    return 6.*m2;\\n}\\n\\nvec2 mainSound( in int samp,float time) {\\n    float z = time*2.;\\n\\treturn getSounds(time, z);\\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"MdjXDV","date":"1416338272","viewed":2260,"name":"Folding","description":"I was hoping that 'folding' the input domain of the distance function would lead to some elegant math. Unfortunately, the math isn't that elegant at all, and also it isn't stable for large folding-angles (hence the 'clipping hack' at lines 90 to 99).","likes":15,"published":"Public API","usePreview":0,"tags":["distancefields","folding","paper","inputdomain"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Folding. Created by Reinder Nijhoff 2014\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MdjXDV\\n//\\n\\n#define MARCHSTEPS 250\\n#define PAPERHEIGHT 0.002\\n#define PI 3.1415926\\n\\nfloat time;\\n\\n//----------------------------------------------------------------------\\n\\nvec3 RotateY( const in vec3 vPos, const in float fAngle ) {\\n    float s = sin(fAngle);\\n    float c = cos(fAngle);\\n   \\n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\\n   \\n    return vResult;\\n}\\n   \\nvec3 RotateZ( const in vec3 vPos, const in float fAngle ) {\\n    float s = sin(fAngle);\\n    float c = cos(fAngle);\\n   \\n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\\n   \\n    return vResult;\\n}\\n\\n//----------------------------------------------------------------------\\n// distance primitives\\n\\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\\n\\nfloat sdBox( in vec3 p, in vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\n//----------------------------------------------------------------------\\n// Map functions\\n\\nvec3 fold( const in vec3 p, in float offset, const in float rot, in float a, const bool left ) {    \\n    a = clamp( a, -PI, PI );\\n    float b = PI-a;   \\n    vec3 rp = p;\\n\\n    if( !left ) offset = -offset;\\n    \\n\\trp.x -= offset;\\n    rp = RotateY( rp, rot );\\n    \\n\\tfloat angle = atan( rp.y, rp.x * (left?-1.:1.) );\\n     \\n    if( angle < 0. ) {\\n        if(  angle >  - b * 0.5 ) {\\n            rp = RotateZ( rp, a * (left?-1.:1.) );\\n        }\\n    } else {\\n        if( angle - a < b * 0.5 ) {\\n\\t        rp = RotateZ( rp, a * (left?-1.:1.) );\\n        }\\n    }\\n    \\n    rp = RotateY( rp, -rot );      \\n    rp += vec3(offset,0.,0.);\\n    \\n   \\n    return rp;\\n}\\n\\nfloat timedAngle( const in float starttime, const in float totaltime, const in float angle ) {\\n\\tfloat i = clamp( time - starttime, 0., totaltime );\\n    return 3.1415926 * angle * i / totaltime;\\n}\\n\\nfloat map( in vec3 p ) {\\n    \\n\\t// folding input domain\\n    p = fold( p, 0.,    0.,  \\t\\t   timedAngle( 6., 2., 0.25), false );\\n    p = fold( p, 0.,    0.,  \\t\\t   timedAngle(10., 2., 0.25), true );\\n    p = fold( p, -0.25,  0., \\t\\t   timedAngle( 8., 2.,-0.25), false  );\\n    p = fold( p, -0.25,  0., \\t\\t   timedAngle(12., 2.,-0.25), true  );\\n    \\n    if( time < 6.  ) \\n    \\tp = fold( p, -1.4, PI*0.25,  timedAngle( 4., 2., -0.8 ) , true );\\n    if( time < 4.  ) \\n\\t\\tp = fold( p, -1.4, -PI*0.25, timedAngle( 2., 2., -0.8 ) , false );\\n    \\n    // just one paper plane\\n    float d = sdBox( p, vec3( 1., PAPERHEIGHT, 1.4) );\\n    \\n    if( time >= 6.  ) { // clip the plane hack :(\\n        vec3 po = p + vec3( 1.53, 0., 2.707 ); po = RotateY( po, PI*0.25 );\\n        d = opS( d, sdBox( po, vec3( 2., 1., 2. ) ) );\\n    } \\n    \\n    if( time >= 4.  ) { // clip the plane hack :(\\n        vec3 po = p + vec3( -1.53, 0., 2.707 ); po = RotateY( po, PI*0.25 );\\n        d = opS( d, sdBox( po, vec3( 2., 1., 2. ) ) );\\n    } \\n    \\n\\treturn d;\\n}\\n\\n//----------------------------------------------------------------------\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    const vec2 e = vec2(1.0,-1.0)*0.0025;\\n\\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \\n\\t\\t\\t\\t\\t    e.yyx*map( pos + e.yyx )   + \\n\\t\\t\\t\\t\\t    e.yxy*map( pos + e.yxy )   + \\n\\t\\t\\t\\t\\t    e.xxx*map( pos + e.xxx )   );  \\n    return n;\\n}\\n\\nvec2 intersect( in vec3 ro, in vec3 rd ) {\\n\\tconst float maxd = 60.0;\\n\\tconst float precis = 0.001;\\n    float d = precis*2.0;\\n    float t = 0.;\\n    float m = 1.;\\n    \\n    for( int i=0; i<MARCHSTEPS; i++ ) {\\n\\t    d = 0.2 * map( ro+rd*t );\\n\\t\\tt+=d;\\n        if( d<precis||t>maxd ) break;\\n    \\n    }\\n\\n    if( t>maxd ) m=-1.0;\\n    return vec2( t, m );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \\n    time = mod( iTime + 8., 32. );\\n    vec2 q = fragCoord.xy / iResolution.xy;\\n\\tvec2 p = -1.0 + 2.0*q;\\n\\tp.x *= iResolution.x / iResolution.y;\\n        \\n    if (q.y < .12 || q.y >= .88) {\\n\\t\\tfragColor=vec4(vec4(0.0));\\n\\t\\treturn;\\n\\t}\\n    \\n    if ( time > 16. ) { time = 32.-time; }\\n    \\n    //-----------------------------------------------------\\n    // camera\\n    //-----------------------------------------------------\\n\\n\\tvec3 ro = vec3(0.,1.75 + 0.25*sin( iTime * 0.42 ), 3.);\\n    ro = RotateY( ro, iTime*0.05 );\\n    vec3 ta = vec3( 0. ,0., 0. );\\n\\n    vec3 ww = normalize( ta - ro );\\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\\n    vec3 vv = normalize( cross(uu,ww));\\n\\tvec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\\n    \\n    \\n     vec3 col = vec3(0.01);\\n\\n    // raymarch\\n    vec2 ints = intersect(ro ,rd );\\n    if(  ints.y > -0.5 ) {\\n        vec3 i = ro + ints.x * rd;\\n        vec3 nor =  calcNormal( i );\\n    \\tcol = vec3(1.) * (0.1+0.9 * clamp(dot( nor, normalize(vec3(0.5, 0.8, 0.2))),0.,1.));\\n\\t}\\n    \\n    // gamma\\n\\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\\n\\n\\n    fragColor = vec4( col, 1.0 );\\n}\\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xtf3zn","date":"1417961720","viewed":62225,"name":"Tokyo","description":"Tokyo by night in the rain. The car model is made by Eiffie (Shiny Toy': https://www.shadertoy.com/view/ldsGWB). I have never been in Tokyo btw.","likes":293,"published":"Public API","usePreview":0,"tags":["raymarching","reflection","rain","city","car"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Reinder Nijhoff 2014\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/Xtf3zn\\n//\\n// Tokyo by night in the rain. The car model is made by Eiffie\\n// (Shiny Toy': https://www.shadertoy.com/view/ldsGWB). \\n// I have never been in Tokyo btw.\\n\\n#define BUMPMAP\\n#define MARCHSTEPS 128\\n#define MARCHSTEPSREFLECTION 48\\n#define LIGHTINTENSITY 5.\\n\\n//----------------------------------------------------------------------\\n\\nconst vec3 backgroundColor = vec3(0.2,0.4,0.6) * 0.09;\\n#define time (iTime + 90.)\\n\\n//----------------------------------------------------------------------\\n// noises\\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*687.3123);\\n}\\n\\nfloat noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    float n = p.x + p.y*157.0;\\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\\n}\\n\\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\\n\\nfloat fbm( vec2 p ) {\\n    float f = 0.0;\\n    f += 0.5000*noise( p ); p = m2*p*2.02;\\n    f += 0.2500*noise( p ); p = m2*p*2.03;\\n    f += 0.1250*noise( p ); p = m2*p*2.01;\\n//    f += 0.0625*noise( p );\\n    \\n    return f/0.9375;\\n}\\n\\n//----------------------------------------------------------------------\\n// distance primitives\\n\\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\\n  return length(max(abs(p)-b,0.0))-r;\\n}\\n\\nfloat sdBox( in vec3 p, in vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdSphere( in vec3 p, in float s ) {\\n    return length(p)-s;\\n}\\n\\nfloat sdCylinder( in vec3 p, in vec2 h ) {\\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\n//----------------------------------------------------------------------\\n// distance operators\\n\\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; } //from iq\\n\\n//----------------------------------------------------------------------\\n// Map functions\\n\\n// car model is made by Eiffie\\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\\n\\nfloat mapCar(in vec3 p0){ \\n\\tvec3 p=p0+vec3(0.0,1.24,0.0);\\n\\tfloat r=length(p.yz);\\n\\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\\n\\td=max(d,p.z-1.0);\\n\\tp=p0+vec3(0.0,-0.22,0.39);\\n\\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\\n\\tr=length(p.yz);\\n\\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\\n\\td=max(d,-max(p.x-0.165,r-0.24));\\n\\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\\n\\td=min(d,d2);\\n\\n\\treturn d;\\n}\\n\\nfloat dL; // minimal distance to light\\n\\nfloat map( const in vec3 p ) {\\n\\tvec3 pd = p;\\n    float d;\\n    \\n    pd.x = abs( pd.x );\\n    pd.z *= -sign( p.x );\\n    \\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\\n    float lh = hash( floor( pd.z/13. ) );\\n    \\n    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );\\n    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );\\n    \\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );\\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );\\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );\\n   \\n    if( lh > 0.5 ) {\\n\\t    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );\\n    }\\n    \\n    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );\\n\\td = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); \\n    \\n    d = opS( d, -(p.x+8.) );\\n    d = opU( d, pd.y );\\n\\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\\n    \\n    // car\\n    if( ch > 0.75 ) {\\n        pdc.x += (ch-0.75)*4.;\\n\\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );\\n\\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );\\n\\n        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );\\n \\t}\\n    \\n    d = opU( d, 13.-pd.x );\\n    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );\\n    d = opU( d, dL );\\n    \\n\\treturn d;\\n}\\n\\n//----------------------------------------------------------------------\\n\\nvec3 calcNormalSimple( in vec3 pos ) {   \\n    const vec2 e = vec2(1.0,-1.0)*0.005;\\n\\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \\n\\t\\t\\t\\t\\t    e.yyx*map( pos + e.yyx )   + \\n\\t\\t\\t\\t\\t    e.yxy*map( pos + e.yxy )   + \\n\\t\\t\\t\\t\\t    e.xxx*map( pos + e.xxx )   );  \\n    return n;\\n}\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    vec3 n = calcNormalSimple( pos );\\n    if( pos.y > 0.12 ) return n;\\n\\n#ifdef BUMPMAP\\n    vec2 oc = floor( vec2(pos.x+floor( pos.z * 4. )*0.25, pos.z) * vec2( 2., 4. ) );\\n\\n    if( abs(pos.x)<8. ) {\\n\\t\\toc = pos.xz;\\n    }\\n    \\n     vec3 p = pos * 250.;\\n   \\t vec3 xn = 0.05*vec3(noise(p.xz)-0.5,0.,noise(p.zx)-0.5);\\n     xn += 0.1*vec3(fbm(oc.xy)-0.5,0.,fbm(oc.yx)-0.5);\\n    \\n    n = normalize( xn + n );\\n#endif\\n    \\n    return n;\\n}\\n\\nvec3 int1, int2, nor1;\\nvec4 lint1, lint2;\\n\\nfloat intersect( in vec3 ro, in vec3 rd ) {\\n\\tconst float precis = 0.001;\\n    float h = precis*2.0;\\n    float t = 0.;\\n    int1 = int2 = vec3( -500. );\\n    lint1 = lint2 = vec4( -500. );\\n    float mld = 100.;\\n    \\n\\tfor( int i=0; i < MARCHSTEPS; i++ ) {\\n        h = map( ro+rd*t );\\n\\t\\tif(dL < mld){\\n\\t\\t\\tmld=dL;\\n            lint1.xyz = ro+rd*t;\\n\\t\\t\\tlint1.w = abs(dL);\\n\\t\\t}\\n        if( h < precis ) {\\n            int1.xyz = ro+rd*t;\\n            break;\\n        } \\n        t += max(h, precis*2.);\\n    }\\n    \\n    if( int1.z < -400. || t > 300.) {\\n        // check intersection with plane y = -0.1;\\n        float d = -(ro.y + 0.1)/rd.y;\\n\\t\\tif( d > 0. ) {\\n\\t\\t\\tint1.xyz = ro+rd*d;\\n\\t    } else {\\n        \\treturn -1.;\\n    \\t}\\n    }\\n    \\n    ro = ro + rd*t;\\n    nor1 = calcNormal(ro);\\n    ro += 0.01*nor1;\\n    rd = reflect( rd, nor1 );\\n    t = 0.0;\\n    h = precis*2.0;\\n    mld = 100.;\\n    \\n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\\n        h = map( ro+rd*t );\\n\\t\\tif(dL < mld){\\n\\t\\t\\tmld=dL;            \\n            lint2.xyz = ro+rd*t;\\n\\t\\t\\tlint2.w = abs(dL);\\n\\t\\t}\\n        if( h < precis ) {\\n   \\t\\t\\tint2.xyz = ro+rd*t;\\n            return 1.;\\n        }   \\n        t += max(h, precis*2.);\\n    }\\n\\n    return 0.;\\n}\\n\\n//----------------------------------------------------------------------\\n// shade\\n\\nvec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {\\n    vec3  col = vec3(0.5);\\n    \\n    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );\\n    if( pos.y < 0.01 ) {\\n        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );\\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );\\n    }    \\n    \\n    float sh = clamp( dot( nor, normalize( vec3( -0.3, 0.3, -0.5 ) ) ), 0., 1.);\\n  \\tcol *= (sh * backgroundColor);  \\n \\n    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows\\n        float ha = hash(  133.1234*floor( pos.y / 3. ) + floor( (pos.z) / 3. ) );\\n        if( ha > 0.95) {\\n            col = ( (ha-0.95)*10.) * vec3( 1., 0.7, 0.4 );\\n        }\\n    }\\n    \\n\\tcol = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );\\n  \\n    return col;\\n}\\n\\nvec3 getLightColor( in vec3 pos ) {\\n    vec3 lcol = vec3( 1., .7, .5 );\\n    \\n\\tvec3 pd = pos;\\n    pd.x = abs( pd.x );\\n    pd.z *= -sign( pos.x );\\n    \\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\\n\\n    if( ch > 0.75 ) { // car\\n        pdc.x += (ch-0.75)*4.;\\n        if(  sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ), 0.25) < 2. ) {\\n            lcol = vec3( 1., 0.05, 0.01 );\\n        }\\n    }\\n    if( pd.y > 2. && abs(pd.x) > 10. && pd.y < 5. ) {\\n        float fl = floor( pd.z/13. );\\n        lcol = 0.4*lcol+0.5*vec3( hash( .1562+fl ), hash( .423134+fl ), 0. );\\n    }\\n    if(  abs(pd.x) > 10. && pd.y > 5. ) {\\n        float fl = floor( pd.z/2. );\\n        lcol = 0.5*lcol+0.5*vec3( hash( .1562+fl ),  hash( .923134+fl ), hash( .423134+fl ) );\\n    }\\n   \\n    return lcol;\\n}\\n\\nfloat randomStart(vec2 co){return 0.8+0.2*hash(dot(co,vec2(123.42,117.853))*412.453);}\\n\\n//----------------------------------------------------------------------\\n// main\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \\n    vec2 q = fragCoord.xy / iResolution.xy;\\n\\tvec2 p = -1.0 + 2.0*q;\\n\\tp.x *= iResolution.x / iResolution.y;\\n        \\n    if (q.y < .12 || q.y >= .88) {\\n\\t\\tfragColor=vec4(0.,0.,0.,1.);\\n\\t\\treturn;\\n    } else {\\n    \\n        // camera\\n        float z = time;\\n        float x = -10.9+1.*sin(time*0.2);\\n        vec3 ro = vec3(x,  1.3+.3*cos(time*0.26), z-1.);\\n        vec3 ta = vec3(-8.,1.3+.4*cos(time*0.26), z+4.+cos(time*0.04));\\n\\n        vec3 ww = normalize( ta - ro );\\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\\n        vec3 vv = normalize( cross(uu,ww));\\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\\n\\n        vec3 col = backgroundColor;\\n\\n        // raymarch\\n        float ints = intersect(ro+randomStart(p)*rd ,rd );\\n        if(  ints > -0.5 ) {\\n\\n            // calculate reflectance\\n            float r = 0.09;     \\t        \\n            if( int1.y > 0.129 ) r = 0.025 * hash(  133.1234*floor( int1.y / 3. ) + floor( int1.z / 3. ) );\\n            if( abs(int1.x) < 8. ) {\\n                if( int1.y < 0.01 ) { // road\\n                    r = 0.007*fbm(int1.xz);\\n                } else { // car\\n                    r = 0.02;\\n                }\\n            }\\n            if( abs( int1.x ) < 0.1 ) r *= 4.;\\n            if( abs( abs( int1.x )-7.4 ) < 0.1 ) r *= 4.;\\n\\n            r *= 2.;\\n\\n            col = shade( ro, int1.xyz, nor1 );\\n\\n            if( ints > 0.5 ) {\\n                col += r * shade( int1.xyz, int2.xyz, calcNormalSimple(int2.xyz) );\\n            }  \\n            if( lint2.w > 0. ) {            \\n                col += (r*LIGHTINTENSITY*exp(-lint2.w*7.0)) * getLightColor(lint2.xyz);\\n            } \\n        } \\n\\n        // Rain (by Dave Hoskins)\\n        vec2 st = 256. * ( p* vec2(.5, .01)+vec2(time*.13-q.y*.6, time*.13) );\\n        float f = noise( st ) * noise( st*0.773) * 1.55;\\n        f = 0.25+ clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\\n\\n        if( lint1.w > 0. ) {\\n            col += (f*LIGHTINTENSITY*exp(-lint1.w*7.0)) * getLightColor(lint1.xyz);\\n        }  \\n\\n        col += 0.25*f*(0.2+backgroundColor);\\n\\n        // post processing\\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\\n        col *= 1.2*vec3(1.,0.99,0.95);   \\n        col = clamp(1.06*col-0.03, 0., 1.);  \\n        q.y = (q.y-.12)*(1./0.76);\\n        col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ); \\n\\n        fragColor = vec4( col, 1.0 );\\n    }\\n}\\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MtfGR4","date":"1419015939","viewed":8757,"name":"Bidirectional path tracing","description":"Yesterday, I found out about bidirectional path tracing. I didn't read the articles, but looked at the images and I tried to implement something myself. Therefore, I think most of the math will be incorrect - but it looks nice. Only diffuse lighting.","likes":54,"published":"Public API","usePreview":0,"tags":["box","tracing","cornell","path","bidirectional"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bidirectional path tracing. Created by Reinder Nijhoff 2014\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtfGR4\\n//\\n\\n#define eps 0.0001\\n#define LIGHTPATHLENGTH 2\\n#define EYEPATHLENGTH 3\\n#define MAXPATHLENGTH 4\\n#define SAMPLES 12\\n\\n#define FULLBOX\\n\\n#define DOF\\n#define ANIMATENOISE\\n#define MOTIONBLUR\\n\\n#define MOTIONBLURFPS 12.\\n\\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*1.3\\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\\n\\nstruct LightPathNode {\\n    vec3 color;\\n    vec3 position;\\n    vec3 normal;\\n};\\n    \\n\\nfloat hash1(inout float seed) {\\n    return fract(sin(seed += 0.1)*43758.5453123);\\n}\\n\\nvec2 hash2(inout float seed) {\\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\\n}\\n\\nvec3 hash3(inout float seed) {\\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\\n}\\n\\n//-----------------------------------------------------\\n// Intersection functions (by iq)\\n//-----------------------------------------------------\\n\\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\\n    return (pos-sph.xyz)/sph.w;\\n}\\n\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n\\tvec3 oc = ro - sph.xyz;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - sph.w*sph.w;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return -1.0;\\n\\treturn -b - sqrt( h );\\n}\\n\\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\\n    return obj.xyz;\\n}\\n\\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\\n}\\n\\n//-----------------------------------------------------\\n// scene\\n//-----------------------------------------------------\\n\\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\\n  \\tvec2 rv2 = hash2(seed);\\n    \\n\\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\\n\\tvec3  vv = normalize( cross( uu, n ) );\\n\\t\\n\\tfloat ra = sqrt(rv2.y);\\n\\tfloat rx = ra*cos(6.2831*rv2.x); \\n\\tfloat ry = ra*sin(6.2831*rv2.x);\\n\\tfloat rz = sqrt( 1.0-rv2.y );\\n\\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\\n    \\n    return normalize( rr );\\n}\\n\\nvec3 randomSphereDirection(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(2.,6.28318530718)-vec2(1,0);\\n    float phi = h.y;\\n\\treturn vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\nvec3 randomHemisphereDirection( const vec3 n, inout float seed ) {\\n\\tvec3 dr = randomSphereDirection(seed);\\n\\treturn dot(dr,n) * dr;\\n}\\n\\n//-----------------------------------------------------\\n// renderer\\n//-----------------------------------------------------\\n\\nvec4 lightSphere;\\nLightPathNode lpNodes[LIGHTPATHLENGTH];\\n\\nvoid initLightSphere( float time ) {\\n\\tlightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7),0.5);\\n}\\n\\nvec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\\n\\tvec2 res = vec2( 1e20, -1.0 );\\n    float t;\\n\\t\\n\\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = vec3( 0., 1., 0.); }\\n\\tt = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = vec3( 0., 0.,-1.); }\\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\\n#ifdef FULLBOX\\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = vec3( 0., -1., 0.); }\\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3(-1., 0., 0.); }\\n#endif\\n\\n\\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 0. ); normal = nSphere( ro+t*rd, vec4( 1.5,1.0, 2.7,1.0) ); }\\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = nSphere( ro+t*rd, vec4( 4.0,1.0, 4.0,1.0) ); }\\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 4.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\\n\\t\\t\\t\\t\\t  \\n    return res;\\t\\t\\t\\t\\t  \\n}\\n\\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\\n    float t;\\n\\t\\n\\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }\\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\\n\\n    return false; // optimisation: planes don't cast shadows in this scene\\n}\\n\\nvec3 calcColor( in float mat ) {\\n\\tvec3 nor = vec3(0.0);\\n\\t\\n\\tif( mat<4.5 ) nor = LIGHTCOLOR;\\n\\tif( mat<3.5 ) nor = WHITECOLOR;\\n    if( mat<2.5 ) nor = GREENCOLOR;\\n\\tif( mat<1.5 ) nor = REDCOLOR;\\n\\tif( mat<0.5 ) nor = WHITECOLOR;\\n\\t\\t\\t\\t\\t  \\n    return nor;\\t\\t\\t\\t\\t  \\n}\\n\\n//-----------------------------------------------------\\n// lightpath\\n//-----------------------------------------------------\\n\\nvoid constructLightPath(inout float seed) {\\n    vec3 ro = normalize( hash3(seed)-vec3(0.5) );\\n    vec3 rd = randomHemisphereDirection( ro, seed );\\n    ro = lightSphere.xyz + ro*0.5;\\n    vec3 color = LIGHTCOLOR;\\n    \\n    lpNodes[0].position = ro;\\n    lpNodes[0].color = color;\\n    lpNodes[0].normal = rd;\\n    \\n    for( int i=1; i<LIGHTPATHLENGTH; ++i ) {\\n        lpNodes[i].position = lpNodes[i].color = lpNodes[i].normal = vec3(0.);\\n    }\\n    \\n    for( int i=1; i<LIGHTPATHLENGTH; i++ ) {\\n\\t\\tvec3 normal;\\n        vec2 res = intersect( ro, rd, normal );\\n        if( res.y > -0.5 && res.y < 4. ) {\\n            ro = ro + rd*res.x;\\n            color *= calcColor( res.y );\\n            lpNodes[i].position = ro;\\n            lpNodes[i].color = color;\\n            lpNodes[i].normal = normal;\\n\\n            rd = cosWeightedRandomHemisphereDirection( normal, seed );\\n        } else break;\\n    }\\n}\\n\\n//-----------------------------------------------------\\n// eyepath\\n//-----------------------------------------------------\\n\\nvec3 traceEyePath( in vec3 ro, in vec3 rd, inout float seed ) {\\n    vec3 col = vec3(0.);\\n    vec3 basecol = vec3(1.);\\n    \\n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\\n        vec3 normal;\\n        \\n        vec2 res = intersect( ro, rd, normal );\\n        if( res.y < -0.5 ) return col;\\n        if( res.y > 3.5 ) {\\n            return col + basecol*LIGHTCOLOR / float( j+1 ); \\n        }\\n        \\n        ro = ro + res.x * rd;\\n        rd = cosWeightedRandomHemisphereDirection( normal, seed );\\n        \\n        basecol *= calcColor( res.y );\\n        \\n\\t    for( int i=0; i<LIGHTPATHLENGTH; ++i ) {\\n            if( i+j >= MAXPATHLENGTH ) continue;\\n            \\n            vec3 lp = lpNodes[i].position - ro;\\n            vec3 lpn = normalize( lp );\\n            vec3 lc = lpNodes[i].color;\\n            \\n            if( !intersectShadow(ro, lpn, length(lp)-eps) ) {\\n                col += clamp( dot( lpn, normal ), 0., 1.) * lc * basecol\\n                    * clamp(  dot( lpNodes[i].normal, -lpn ), 0., 1.)\\n                    * clamp( 1./dot(lp,lp), 0., 1. )\\n                    / float( i+j+1 );\\n            }\\n        }\\n    }    \\n    return col;\\n}\\n\\n//-----------------------------------------------------\\n// main\\n//-----------------------------------------------------\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy / iResolution.xy;\\n    \\n    //-----------------------------------------------------\\n    // camera\\n    //-----------------------------------------------------\\n\\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\\n    p.x *= iResolution.x/iResolution.y;\\n\\n#ifdef ANIMATENOISE\\n    float seed = p.x + fract(p.y * 18753.43121412313) + fract(12.12345314312*iTime);\\n#else\\n    float seed = p.x + fract(p.y * 18753.43121412313);\\n#endif\\n    \\n    vec3 ro = vec3(2.78, 2.73, -8.00);\\n    vec3 ta = vec3(2.78, 2.73,  0.00);\\n    vec3 ww = normalize( ta - ro );\\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\\n    vec3 vv = normalize( cross(uu,ww));\\n\\n    //-----------------------------------------------------\\n    // render\\n    //-----------------------------------------------------\\n\\n    vec3 col = vec3(0.0);\\n    vec3 tot = vec3(0.0);\\n    vec3 uvw = vec3(0.0);\\n\\n    for( int a=0; a<SAMPLES; a++ ) {\\n        \\n        vec2 rpof = 4.*(hash2(seed)-vec2(0.5)) / iResolution.xy;\\n\\t    vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\\n        \\n#ifdef DOF\\n\\t    vec3 fp = ro + rd * 12.0;\\n   \\t\\tvec3 rof = ro + (uu*(hash1(seed)-0.5) + vv*(hash1(seed)-0.5))*0.125;\\n    \\trd = normalize( fp - rof );\\n#else\\n        vec3 rof = ro;\\n#endif        \\n        \\n#ifdef MOTIONBLUR\\n        initLightSphere( iTime + hash1(seed) / MOTIONBLURFPS );\\n#else\\n        initLightSphere( iTime );        \\n#endif\\n        \\n        constructLightPath(seed);\\n        col = traceEyePath( rof, rd, seed );\\n\\n        tot += col;\\n        \\n        seed = mod( seed*1.1234567893490423, 13. );\\n    }\\n    \\n    tot /= float(SAMPLES);\\n\\n\\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\\n\\n    fragColor = vec4( tot, 1.0 );\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4tl3z4","date":"1419368177","viewed":13879,"name":"Simple path tracer","description":"This shader shows the difference between a path tracer with, and without, direct light sampling.","likes":134,"published":"Public API","usePreview":0,"tags":["light","sampling","tracer","path","direct"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple path tracer. Created by Reinder Nijhoff 2014\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4tl3z4\\n//\\n\\n#define eps 0.0001\\n#define EYEPATHLENGTH 4\\n#define SAMPLES 12\\n\\n#define SHOWSPLITLINE\\n#define FULLBOX\\n\\n#define DOF\\n#define ANIMATENOISE\\n#define MOTIONBLUR\\n\\n#define MOTIONBLURFPS 12.\\n\\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*1.3\\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\\n\\n\\nfloat hash1(inout float seed) {\\n    return fract(sin(seed += 0.1)*43758.5453123);\\n}\\n\\nvec2 hash2(inout float seed) {\\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\\n}\\n\\nvec3 hash3(inout float seed) {\\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\\n}\\n\\n//-----------------------------------------------------\\n// Intersection functions (by iq)\\n//-----------------------------------------------------\\n\\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\\n    return (pos-sph.xyz)/sph.w;\\n}\\n\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n    vec3 oc = ro - sph.xyz;\\n    float b = dot(oc, rd);\\n    float c = dot(oc, oc) - sph.w * sph.w;\\n    float h = b * b - c;\\n    if (h < 0.0) return -1.0;\\n\\n\\tfloat s = sqrt(h);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\treturn t1 < 0.0 ? t2 : t1;\\n}\\n\\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\\n    return obj.xyz;\\n}\\n\\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\\n}\\n\\n//-----------------------------------------------------\\n// scene\\n//-----------------------------------------------------\\n\\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n    \\n\\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\\n\\tvec3  vv = cross( uu, n );\\n\\t\\n\\tfloat ra = sqrt(r.y);\\n\\tfloat rx = ra*cos(6.2831*r.x); \\n\\tfloat ry = ra*sin(6.2831*r.x);\\n\\tfloat rz = sqrt( 1.0-r.y );\\n\\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\\n    \\n    return normalize( rr );\\n}\\n\\nvec3 randomSphereDirection(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(2.,6.28318530718)-vec2(1,0);\\n    float phi = h.y;\\n\\treturn vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\nvec3 randomHemisphereDirection( const vec3 n, inout float seed ) {\\n\\tvec3 dr = randomSphereDirection(seed);\\n\\treturn dot(dr,n) * dr;\\n}\\n\\n//-----------------------------------------------------\\n// light\\n//-----------------------------------------------------\\n\\nvec4 lightSphere;\\n\\nvoid initLightSphere( float time ) {\\n\\tlightSphere = vec4( 3.0+2.*sin(time),2.8+2.*sin(time*0.9),3.0+4.*cos(time*0.7), .5 );\\n}\\n\\nvec3 sampleLight( const in vec3 ro, inout float seed ) {\\n    vec3 n = randomSphereDirection( seed ) * lightSphere.w;\\n    return lightSphere.xyz + n;\\n}\\n\\n//-----------------------------------------------------\\n// scene\\n//-----------------------------------------------------\\n\\nvec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\\n\\tvec2 res = vec2( 1e20, -1.0 );\\n    float t;\\n\\t\\n\\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 1., 0.); }\\n\\tt = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 0.,-1.); }\\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\\n#ifdef FULLBOX\\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., -1., 0.); }\\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 3. ); normal = vec3(-1., 0., 0.); }\\n#endif\\n\\n\\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = nSphere( ro+t*rd, vec4( 1.5,1.0, 2.7,1.0) ); }\\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 6. ); normal = nSphere( ro+t*rd, vec4( 4.0,1.0, 4.0,1.0) ); }\\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 0.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\\n\\t\\t\\t\\t\\t  \\n    return res;\\t\\t\\t\\t\\t  \\n}\\n\\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\\n    float t;\\n\\t\\n\\tt = iSphere( ro, rd, vec4( 1.5,1.0, 2.7,1.0) );  if( t>eps && t<dist ) { return true; }\\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\\n\\n    return false; // optimisation: planes don't cast shadows in this scene\\n}\\n\\n//-----------------------------------------------------\\n// materials\\n//-----------------------------------------------------\\n\\nvec3 matColor( const in float mat ) {\\n\\tvec3 nor = vec3(0., 0.95, 0.);\\n\\t\\n\\tif( mat<3.5 ) nor = REDCOLOR;\\n    if( mat<2.5 ) nor = GREENCOLOR;\\n\\tif( mat<1.5 ) nor = WHITECOLOR;\\n\\tif( mat<0.5 ) nor = LIGHTCOLOR;\\n\\t\\t\\t\\t\\t  \\n    return nor;\\t\\t\\t\\t\\t  \\n}\\n\\nbool matIsSpecular( const in float mat ) {\\n    return mat > 4.5;\\n}\\n\\nbool matIsLight( const in float mat ) {\\n    return mat < 0.5;\\n}\\n\\n//-----------------------------------------------------\\n// brdf\\n//-----------------------------------------------------\\n\\nvec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce, inout float seed ) {\\n    specularBounce = false;\\n    \\n    vec3 r = cosWeightedRandomHemisphereDirection( n, seed );\\n    if(  !matIsSpecular( m ) ) {\\n        return r;\\n    } else {\\n        specularBounce = true;\\n        \\n        float n1, n2, ndotr = dot(rd,n);\\n        \\n        if( ndotr > 0. ) {\\n            n1 = 1.0; \\n            n2 = 1.5;\\n            n = -n;\\n        } else {\\n            n1 = 1.5;\\n            n2 = 1.0; \\n        }\\n                \\n        float r0 = (n1-n2)/(n1+n2); r0 *= r0;\\n\\t\\tfloat fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);\\n        \\n        vec3 ref =  refract( rd, n, n2/n1 );        \\n        if( ref == vec3(0) || hash1(seed) < fresnel ) {\\n            ref = reflect( rd, n );\\n        } \\n        \\n        return ref;\\n\\t}\\n}\\n\\n//-----------------------------------------------------\\n// eyepath\\n//-----------------------------------------------------\\n\\nvec3 traceEyePath( in vec3 ro, in vec3 rd, const in bool directLightSampling, inout float seed ) {\\n    vec3 tcol = vec3(0.);\\n    vec3 fcol  = vec3(1.);\\n    \\n    bool specularBounce = true;\\n    \\n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\\n        vec3 normal;\\n        \\n        vec2 res = intersect( ro, rd, normal );\\n        if( res.y < -0.5 ) {\\n            return tcol;\\n        }\\n        \\n        if( matIsLight( res.y ) ) {\\n            if( directLightSampling ) {\\n            \\tif( specularBounce ) tcol += fcol*LIGHTCOLOR;\\n            } else {\\n                tcol += fcol*LIGHTCOLOR;\\n            }\\n            return tcol;\\n        }\\n        \\n        ro = ro + res.x * rd;\\n        rd = getBRDFRay( normal, rd, res.y, specularBounce, seed );\\n            \\n        if(!specularBounce || dot(rd,normal) < 0.) {  \\n        \\tfcol *= matColor( res.y );\\n        }\\n        \\n        if( directLightSampling ) {\\n        \\tvec3 ld = sampleLight( ro, seed ) - ro;\\n\\t\\t\\tvec3 nld = normalize(ld);\\n            if( !specularBounce && j < EYEPATHLENGTH-1 && !intersectShadow( ro, nld, length(ld)) ) {\\n\\n                float cos_a_max = sqrt(1. - clamp(lightSphere.w * lightSphere.w / dot(lightSphere.xyz-ro, lightSphere.xyz-ro), 0., 1.));\\n                float weight = 2. * (1. - cos_a_max);\\n\\n                tcol += (fcol * LIGHTCOLOR) * (weight * clamp(dot( nld, normal ), 0., 1.));\\n            }\\n        }\\n    }    \\n    return tcol;\\n}\\n\\n//-----------------------------------------------------\\n// main\\n//-----------------------------------------------------\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy / iResolution.xy;\\n    \\n\\tfloat splitCoord = (iMouse.x == 0.0) ? iResolution.x/2. + iResolution.x*cos(iTime*.5) : iMouse.x;\\n    bool directLightSampling = fragCoord.x < splitCoord;\\n    \\n    //-----------------------------------------------------\\n    // camera\\n    //-----------------------------------------------------\\n\\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\\n    p.x *= iResolution.x/iResolution.y;\\n\\n#ifdef ANIMATENOISE\\n    float seed = p.x + p.y * 3.43121412313 + fract(1.12345314312*iTime);\\n#else\\n    float seed = p.x + p.y * 3.43121412313;\\n#endif\\n    \\n    vec3 ro = vec3(2.78, 2.73, -8.00);\\n    vec3 ta = vec3(2.78, 2.73,  0.00);\\n    vec3 ww = normalize( ta - ro );\\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\\n    vec3 vv = normalize( cross(uu,ww));\\n\\n    //-----------------------------------------------------\\n    // render\\n    //-----------------------------------------------------\\n\\n    vec3 col = vec3(0.0);\\n    vec3 tot = vec3(0.0);\\n    vec3 uvw = vec3(0.0);\\n    \\n    for( int a=0; a<SAMPLES; a++ ) {\\n\\n        vec2 rpof = 2.*(hash2(seed)-vec2(0.5)) / iResolution.y;\\n\\t    vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\\n        \\n#ifdef DOF\\n\\t    vec3 fp = ro + rd * 12.0;\\n   \\t\\tvec3 rof = ro + (uu*(hash1(seed)-0.5) + vv*(hash1(seed)-0.5))*0.125;\\n    \\trd = normalize( fp - rof );\\n#else\\n        vec3 rof = ro;\\n#endif        \\n        \\n#ifdef MOTIONBLUR\\n        initLightSphere( iTime + hash1(seed) / MOTIONBLURFPS );\\n#else\\n        initLightSphere( iTime );        \\n#endif\\n        \\n        col = traceEyePath( rof, rd, directLightSampling, seed );\\n\\n        tot += col;\\n        \\n        seed = mod( seed*1.1234567893490423, 13. );\\n    }\\n    \\n    tot /= float(SAMPLES);\\n    \\n#ifdef SHOWSPLITLINE\\n\\tif (abs(fragCoord.x - splitCoord) < 1.0) {\\n\\t\\ttot.x = 1.0;\\n\\t}\\n#endif\\n    \\n\\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\\n\\n    fragColor = vec4( tot, 1.0 );\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4lfGWr","date":"1420563049","viewed":10469,"name":"Bidirectional path tracer 2","description":"My second try of creating a bidirectional path tracer. I really should read those articles :( (all weights of the paths are guessed)\\nThe shader shows a scene with indirect lighting, using a bidirectional path tracer and a classical path tracer.","likes":70,"published":"Public API","usePreview":0,"tags":["lighting","indirect","tracer","path","bidirectional"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bidirectional path tracer 2. Created by Reinder Nijhoff 2014\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4lfGWr\\n//\\n\\n#define eps 0.00001\\n#define LIGHTPATHLENGTH 2\\n#define EYEPATHLENGTH 3\\n#define SAMPLES 8\\n\\n#define SHOWSPLITLINE\\n#define FULLBOX\\n\\n#define DOF\\n#define ANIMATENOISE\\n#define MOTIONBLUR\\n\\n#define MOTIONBLURFPS 12.\\n\\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*200.\\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\\n\\nfloat hash1(inout float seed) {\\n    return fract(sin(seed += 0.1)*43758.5453123);\\n}\\n\\nvec2 hash2(inout float seed) {\\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\\n}\\n\\nvec3 hash3(inout float seed) {\\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\\n}\\n\\n//-----------------------------------------------------\\n// Intersection functions (by iq)\\n//-----------------------------------------------------\\n\\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\\n    return (pos-sph.xyz)/sph.w;\\n}\\n\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n    vec3 oc = ro - sph.xyz;\\n    float b = dot(oc, rd);\\n    float c = dot(oc, oc) - sph.w * sph.w;\\n    float h = b * b - c;\\n    if (h < 0.0) return -1.0;\\n\\n\\tfloat s = sqrt(h);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\treturn t1 < 0.0 ? t2 : t1;\\n}\\n\\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\\n    return obj.xyz;\\n}\\n\\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\\n}\\n\\n//-----------------------------------------------------\\n// scene\\n//-----------------------------------------------------\\n\\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n    \\n\\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\\n\\tvec3  vv = cross( uu, n );\\n\\t\\n\\tfloat ra = sqrt(r.y);\\n\\tfloat rx = ra*cos(6.2831*r.x); \\n\\tfloat ry = ra*sin(6.2831*r.x);\\n\\tfloat rz = sqrt( 1.0-r.y );\\n\\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\\n    \\n    return normalize( rr );\\n}\\n\\nvec3 randomSphereDirection(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(2.,6.28318530718)-vec2(1,0);\\n    float phi = h.y;\\n\\treturn vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\nvec3 randomHemisphereDirection( const vec3 n, inout float seed ) {\\n\\tvec3 dr = randomSphereDirection(seed);\\n\\treturn dot(dr,n) * dr;\\n}\\n\\n//-----------------------------------------------------\\n// light\\n//-----------------------------------------------------\\n\\nconst vec4 lightSphere = vec4( 3.0,7.5,2.5, .5 );\\nvec4 movingSphere;\\n\\nvoid initMovingSphere( float time ) {\\n\\tmovingSphere = vec4( 1.+abs(1.0*sin(time*1.3)), 1.+abs(2.0*sin(time)), 7.-abs(6.*cos(time*0.4)), 1.0);\\n}\\n\\nvec3 sampleLight( const in vec3 ro, inout float seed ) {\\n    vec3 n = randomSphereDirection(seed) * lightSphere.w;\\n    return lightSphere.xyz + n;\\n}\\n\\n//-----------------------------------------------------\\n// scene\\n//-----------------------------------------------------\\n\\nvec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\\n\\tvec2 res = vec2( 1e20, -1.0 );\\n    float t;\\n\\t\\n\\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 1., 0.); }\\n\\tt = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 0.,-1.); }\\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\\n#ifdef FULLBOX\\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x && ro.z+rd.z*t < 5.5 ) { res = vec2( t, 1. ); normal = vec3( 0.,-1., 0.); }\\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 3. ); normal = vec3(-1., 0., 0.); }\\n#endif\\n\\n\\tt = iSphere( ro, rd, movingSphere             ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = nSphere( ro+t*rd, movingSphere ); }\\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 5. ); normal = nSphere( ro+t*rd, vec4( 4.0,1.0, 4.0,1.0) ); }\\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 0.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\\n\\t\\t\\t\\t\\t  \\n    return res;\\t\\t\\t\\t\\t  \\n}\\n\\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\\n    float t;\\n\\t\\n\\tt = iSphere( ro, rd, movingSphere            );  if( t>eps && t<dist ) { return true; }\\n    t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\\n#ifdef FULLBOX    \\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<dist && ro.z+rd.z*t < 5.5 ) { return true; }\\n#endif\\n    return false; // optimisation: other planes don't cast shadows in this scene\\n}\\n\\n//-----------------------------------------------------\\n// materials\\n//-----------------------------------------------------\\n\\nvec3 matColor( const in float mat ) {\\n\\tvec3 nor = vec3(0., 0.95, 0.);\\n\\t\\n\\tif( mat<3.5 ) nor = REDCOLOR;\\n    if( mat<2.5 ) nor = GREENCOLOR;\\n\\tif( mat<1.5 ) nor = WHITECOLOR;\\n\\tif( mat<0.5 ) nor = LIGHTCOLOR;\\n\\t\\t\\t\\t\\t  \\n    return nor;\\t\\t\\t\\t\\t  \\n}\\n\\nbool matIsSpecular( const in float mat ) {\\n    return mat > 4.5;\\n}\\n\\nbool matIsLight( const in float mat ) {\\n    return mat < 0.5;\\n}\\n\\n//-----------------------------------------------------\\n// brdf\\n//-----------------------------------------------------\\n\\nvec3 getBRDFRay( in vec3 n, const in vec3 rd, const in float m, inout bool specularBounce, inout float seed ) {\\n    specularBounce = false;\\n    \\n    vec3 r = cosWeightedRandomHemisphereDirection( n, seed );\\n    if(  !matIsSpecular( m ) ) {\\n        return r;\\n    } else {\\n        specularBounce = true;\\n        \\n        float n1, n2, ndotr = dot(rd,n);\\n        \\n        if( ndotr > 0. ) {\\n            n1 = 1./1.5; n2 = 1.;\\n            n = -n;\\n        } else {\\n            n2 = 1./1.5; n1 = 1.;\\n        }\\n                \\n        float r0 = (n1-n2)/(n1+n2); r0 *= r0;\\n\\t\\tfloat fresnel = r0 + (1.-r0) * pow(1.0-abs(ndotr),5.);\\n        \\n        vec3 ref = refract( rd, n, n2/n1 );        \\n        if( ref == vec3(0) || hash1(seed) < fresnel || m > 6.5 ) {\\n            ref = reflect( rd, n );\\n        }\\n        \\n        return ref; // normalize( ref + 0.1 * r );\\n\\t}\\n}\\n\\n//-----------------------------------------------------\\n// lightpath\\n//-----------------------------------------------------\\n\\nstruct LightPathNode {\\n    vec3 color;\\n    vec3 position;\\n    vec3 normal;\\n};\\n\\nLightPathNode lpNodes[LIGHTPATHLENGTH];\\n\\nvoid constructLightPath( inout float seed ) {\\n    vec3 ro = randomSphereDirection( seed );\\n    vec3 rd = cosWeightedRandomHemisphereDirection( ro, seed );\\n    ro = lightSphere.xyz - ro*lightSphere.w;\\n    vec3 color = LIGHTCOLOR;\\n \\n    for( int i=0; i<LIGHTPATHLENGTH; ++i ) {\\n        lpNodes[i].position = lpNodes[i].color = lpNodes[i].normal = vec3(0.);\\n    }\\n    \\n    bool specularBounce;\\n    float w = 0.;\\n    \\n    for( int i=0; i<LIGHTPATHLENGTH; i++ ) {\\n\\t\\tvec3 normal;\\n        vec2 res = intersect( ro, rd, normal );\\n        \\n        if( res.y > 0.5 && dot( rd, normal ) < 0. ) {\\n            ro = ro + rd*res.x;            \\n            color *= matColor( res.y );\\n            \\n            lpNodes[i].position = ro;\\n            if( !matIsSpecular( res.y ) ) lpNodes[i].color = color;// * clamp( dot( normal, -rd ), 0., 1.);\\n            lpNodes[i].normal = normal;\\n            \\n            rd = getBRDFRay( normal, rd, res.y, specularBounce, seed );\\n        } else break;\\n    }\\n}\\n\\n//-----------------------------------------------------\\n// eyepath\\n//-----------------------------------------------------\\n\\nfloat getWeightForPath( int e, int l ) {\\n    return float(e + l + 2);\\n}\\n\\nvec3 traceEyePath( in vec3 ro, in vec3 rd, const in bool bidirectTrace, inout float seed ) {\\n    vec3 tcol = vec3(0.);\\n    vec3 fcol  = vec3(1.);\\n    \\n    bool specularBounce = true; \\n\\tint jdiff = 0;\\n    \\n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\\n        vec3 normal;\\n        \\n        vec2 res = intersect( ro, rd, normal );\\n        if( res.y < -0.5 ) {\\n            return tcol;\\n        }\\n        \\n        if( matIsLight( res.y ) ) {\\n            if( bidirectTrace ) {\\n            \\tif( specularBounce ) tcol += fcol*LIGHTCOLOR;\\n            } else {\\n               tcol += fcol*LIGHTCOLOR;\\n            }\\n            return tcol; // the light has no diffuse component, therefore we can return col\\n        }\\n        \\n        ro = ro + res.x * rd;   \\n        vec3 rdi = rd;\\n        rd = getBRDFRay( normal, rd, res.y, specularBounce, seed );\\n            \\n        if(!specularBounce || dot(rd,normal) < 0.) {  \\n        \\tfcol *= matColor( res.y );\\n        }\\n        \\n        if( bidirectTrace  ) {\\n\\t\\t    vec3 ld = sampleLight( ro, seed ) - ro;       \\n            \\n            // path of (j+1) eyepath-nodes, and 1 lightpath-node ( = direct light sampling )\\n            vec3 nld = normalize(ld);\\n            if( !specularBounce &&  !intersectShadow( ro, nld, length(ld)) ) {\\n                float cos_a_max = sqrt(1. - clamp(lightSphere.w * lightSphere.w / dot(lightSphere.xyz-ro, lightSphere.xyz-ro), 0., 1.));\\n                float weight = 2. * (1. - cos_a_max);\\n\\n                tcol += (fcol * LIGHTCOLOR) * (weight * clamp(dot( nld, normal ), 0., 1.))\\n                    / getWeightForPath(jdiff,-1);\\n            }\\n\\n            \\n            if( !matIsSpecular( res.y ) ) {\\n                for( int i=0; i<LIGHTPATHLENGTH; ++i ) {\\n                    // path of (j+1) eyepath-nodes, and i+2 lightpath-nodes.\\n                    vec3 lp = lpNodes[i].position - ro;\\n                    vec3 lpn = normalize( lp );\\n                    vec3 lc = lpNodes[i].color;\\n\\n                    if( !intersectShadow(ro, lpn, length(lp)) ) {\\n                        // weight for going from (j+1)th eyepath-node to (i+2)th lightpath-node\\n                        \\n                        // IS THIS CORRECT ???\\n                        \\n                        float weight = \\n                                 clamp( dot( lpn, normal ), 0.0, 1.) \\n                               * clamp( dot( -lpn, lpNodes[i].normal ), 0., 1.)\\n                               * clamp(1. / dot(lp, lp), 0., 1.)\\n                            ;\\n\\n                        tcol += lc * fcol * weight / getWeightForPath(jdiff,i);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if( !specularBounce) jdiff++; else jdiff = 0;\\n    }  \\n    \\n    return tcol;\\n}\\n\\n//-----------------------------------------------------\\n// main\\n//-----------------------------------------------------\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy / iResolution.xy;\\n    \\n\\tfloat splitCoord = (iMouse.x == 0.0) ? iResolution.x/2. + iResolution.x*cos(iTime*.5) : iMouse.x;\\n    bool bidirectTrace = fragCoord.x < splitCoord;\\n    \\n    //-----------------------------------------------------\\n    // camera\\n    //-----------------------------------------------------\\n\\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\\n    p.x *= iResolution.x/iResolution.y;\\n\\n#ifdef ANIMATENOISE\\n    float seed = p.x + p.y * 3.43121412313 + fract(1.12345314312*iTime);\\n#else\\n    float seed = p.x + p.y * 3.43121412313;\\n#endif\\n    \\n    vec3 ro = vec3(2.78, 2.73, -8.00);\\n    vec3 ta = vec3(2.78, 2.73,  0.00);\\n    vec3 ww = normalize( ta - ro );\\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\\n    vec3 vv = normalize( cross(uu,ww));\\n\\n    //-----------------------------------------------------\\n    // render\\n    //-----------------------------------------------------\\n\\n    vec3 col = vec3(0.0);\\n    vec3 tot = vec3(0.0);\\n    vec3 uvw = vec3(0.0);\\n    \\n    for( int a=0; a<SAMPLES; a++ ) {\\n\\n        vec2 rpof = 4.*(hash2(seed)-vec2(0.5)) / iResolution.xy;\\n\\t    vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\\n        \\n#ifdef DOF\\n\\t    vec3 fp = ro + rd * 12.0;\\n   \\t\\tvec3 rof = ro + (uu*(hash1(seed)-0.5) + vv*(hash1(seed)-0.5))*0.125;\\n    \\trd = normalize( fp - rof );\\n#else\\n        vec3 rof = ro;\\n#endif        \\n        \\n#ifdef MOTIONBLUR\\n        initMovingSphere( iTime + hash1(seed) / MOTIONBLURFPS );\\n#else\\n        initMovingSphere( iTime );        \\n#endif\\n        \\n        if( bidirectTrace ) {\\n            constructLightPath( seed );\\n        }\\n        \\n        col = traceEyePath( rof, rd, bidirectTrace, seed );\\n\\n        tot += col;\\n        \\n        seed = mod( seed*1.1234567893490423, 13. );\\n    }\\n    \\n    tot /= float(SAMPLES);\\n    \\n#ifdef SHOWSPLITLINE\\n\\tif (abs(fragCoord.x - splitCoord) < 1.0) {\\n\\t\\ttot.x = 1.0;\\n\\t}\\n#endif\\n    \\n\\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\\n\\n    fragColor = vec4( tot, 1.0 );\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xls3WM","date":"1422520157","viewed":2916,"name":"[2TC 15] Toxic lake","description":"I am just one day at home between two holidays, so I don't have the time to really participate in this contest :(. This shader is based on  https://www.shadertoy.com/view/4ls3D4 by Dave_Hoskins. I have added fbm and color. ","likes":41,"published":"Public API","usePreview":0,"tags":["3d","raymarching","fbm","2tc15"]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Created by Reinder Nijhoff 2015\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// Based on https://www.shadertoy.com/view/4ls3D4 by Dave_Hoskins\\n\\n#define n b = .5*(b + texture(iChannel0, (c.xy + vec2(37, 17) * floor(c.z)) / 256.).x); c *= .4;\\n\\nvoid mainImage( out vec4 f, in vec2 w ) {\\n    vec3 p = vec3(w.xy / iResolution.xy - .5, .2), \\n\\td = p, a = p, b = p-p, c;\\n\\n    for(int i = 0; i<99; i++) {\\n        c = p; c.z += iTime * 5.;\\n        n\\n        n\\n        n\\n        a += (1. - a) * b.x * abs(p.y) / 4e2;\\n        p += d;\\n    }\\n    f = vec4(1. - a*a,1);\\n}\\n\\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4tsGD7","date":"1422535702","viewed":6720,"name":"[2TC 15] Minecraft","description":"A voxel landscape in two tweets (280 chars). (Remake of this shader: [url]https://www.shadertoy.com/view/4ds3WS[/url])","likes":25,"published":"Public API","usePreview":0,"tags":["3d","raymarching","voxel","2tc15"]},"renderpass":[{"inputs":[],"outputs":[],"code":"// [2TC 15] Minecraft. Created by Reinder Nijhoff 2015\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4tsGD7\\n// \\n\\nvoid mainImage( out vec4 z, in vec2 w ) {\\n    vec3 d = vec3(w,1)/iResolution-.5, p, c, f, g=d, o, y=vec3(1,2,0);\\n \\to.y = 3.*cos((o.x=.3)*(o.z=iDate.w));\\n\\n    for( float i=.0; i<9.; i+=.01 ) {\\n        f = fract(c = o += d*i*.01), p = floor( c )*.3;\\n        if( cos(p.z) + sin(p.x) > ++p.y ) {\\n\\t    \\tg = (f.y-.04*cos((c.x+c.z)*40.)>.8?y:f.y*y.yxz) / i;\\n            break;\\n        }\\n    }\\n    z.xyz = g;\\n}\\n\\n/*\\n\\n// original:\\n\\n\\nvoid main() {\\n    vec3 d = gl_fragCoord.xyw/iResolution-.5, p, c, f, g=d, o, y=vec3(1,2,0);\\n \\to.y = 3.*cos((o.x=.3)*(o.z=iDate.w));\\n\\n    for( float i=.0; i<9.; i+=.01 ) {\\n        f = fract(c = o += d*i*.01), p = floor( c )*.3;\\n        if( cos(p.z) + sin(p.x) > ++p.y ) {\\n\\t    \\tg = (f.y-.04*cos((c.x+c.z)*40.)>.8?y:f.y*y.yxz) / i;\\n            break;\\n        }\\n    }\\n    gl_fragColor.xyz = g;\\n}\\n\\n*/","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MtlGWM","date":"1422556895","viewed":5755,"name":"[2TC 15] Psychedelic Sand Dunes","description":"Psychedelic sand dunes in two tweets. Based on my shader [2TC 15] Minecraft ([url]https://www.shadertoy.com/view/4tsGD7[/url]).\\nThere are some chars left, so please give suggestions to improve this one!","likes":70,"published":"Public API","usePreview":0,"tags":["3d","raymarching","2tc15","dunes"]},"renderpass":[{"inputs":[],"outputs":[],"code":"// [2TC 15] Psychedelic Sand Dunes. Created by Reinder Nijhoff 2015\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtlGWM\\n//\\n\\nvoid mainImage( out vec4 f, in vec2 w ) {\\n    vec3 d = vec3(w.xy,1)/iResolution-.5, p=d-d, o=d;\\n \\t\\n    o.z+=iDate.w*4.;\\n    float i=.0;\\n    \\n    for( ; i<9. && cos(p.z) - abs(sin(p.x*.7+cos(p.z))) < ++p.y; i+=.01 ) \\n        p = (o += d*i*.05)*.3;\\n\\n    f.xyz = mix( (3.+p.y) * vec3(.6,.3,0), d, i/9.);\\n}\\n\\n/* or, in 218 char:\\n\\nvoid main() {\\n    vec3 d = gl_fragCoord.xyw/iResolution-.5, p, c, g=d, o=d;\\n\\n    for( float i=.0; i<9.; i+=.01 ) {\\n        p = (c = o += d*i*.05)*.3;\\n        if(  abs(sin(p.x+cos(p.z+iDate.w))) > p.y+2. ) {\\n\\t    \\tg = mix( (3.+p.y) * vec3(.6,.3,0), d, i/9.);\\n            break;\\n        }\\n    }\\n    gl_fragColor.xyz = g;\\n}\\n\\n*/","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ltjGRz","date":"1426806534","viewed":7374,"name":"[NV15] Space","description":"Space - winner of the 'best visuals' category of the Shadertoy Hackathon @ NVSCENE 2015.\\n\\nSee [url=https://www.shadertoy.com/view/4tjGRh]4tjGRh[/url] for the updated shader with space-to-surface flight.","likes":65,"published":"Public API","usePreview":0,"tags":["space"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [NV15] Space. Created by Reinder Nijhoff 2015\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/ltjGRz\\n//\\n\\n#define SHOW_ASTEROIDS\\n//#define HIGH_QUALITY\\n\\nconst float PI = 3.14159265359;\\nconst float DEG_TO_RAD = (PI / 180.0);\\nconst float MAX = 10000.0;\\n\\nconst float EARTH_RADIUS = 1000.;\\nconst float EARTH_ATMOSPHERE = 10.;\\nconst float RING_INNER_RADIUS = 1500.;\\nconst float RING_OUTER_RADIUS = 2300.;\\nconst float RING_DETAIL_DISTANCE = 40.;\\nconst float RING_HEIGHT = 2.;\\nconst float RING_VOXEL_STEP_SIZE = .03;\\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\\nconst vec3  RING_COLOR_2 = vec3(0.51,0.41,0.32) * 0.2;\\n\\nconst int   ASTEROID_NUM_STEPS = 10;\\nconst float ASTEROID_TRESHOLD \\t= 0.001;\\nconst float ASTEROID_EPSILON \\t= 1e-6;\\nconst float ASTEROID_DISPLACEMENT = 0.1;\\n\\n#ifdef HIGH_QUALITY\\nconst int   RING_VOXEL_STEPS = 60;\\nconst float ASTEROID_MAX_DISTANCE = 2.7; \\nconst float ASTEROID_RADIUS = 0.12;\\n#else\\nconst int   RING_VOXEL_STEPS = 26;\\nconst float ASTEROID_MAX_DISTANCE = 1.; // RING_VOXEL_STEPS * RING_VOXEL_STEP_SIZE\\nconst float ASTEROID_RADIUS = 0.13;\\n#endif\\n\\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\\nconst vec3 SUN_COLOR = vec3(1.0, .7, .55)*.2;\\n\\n//-----------------------------------------------------\\n// Noise functions\\n//-----------------------------------------------------\\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\nfloat hash( vec2 p ) {\\n\\tfloat h = dot(p,vec2(127.1,311.7));\\t\\n    return fract(sin(h)*43758.5453123);\\n}\\nfloat hash( vec3 p ) {\\n\\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\\t\\n    return fract(sin(h)*43758.5453123);\\n}\\nvec3 hash31(float p) {\\n\\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\\t\\n    return fract(sin(h)*43758.543123);\\n}\\nvec3 hash33( vec3 p) {\\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\\n}\\nfloat noise( in float p ) {    \\n    float i = floor( p );\\n    float f = fract( p );\\t\\n\\tfloat u = f*f*(3.0-2.0*f);\\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\\n}\\nfloat noise( in vec2 p ) {    \\n    vec2 i = floor( p );\\n    vec2 f = fract( p );\\t\\n\\tvec2 u = f*f*(3.0-2.0*f);\\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \\n                     hash( i + vec2(1.0,0.0) ), u.x),\\n                mix( hash( i + vec2(0.0,1.0) ), \\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\\n}\\nfloat noise( in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    float n = p.x + p.y*157.0 + 113.0*p.z;\\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\\n}\\n\\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\\n\\nfloat fbm( vec2 p ) {\\n    float f = 0.0;\\n    f += 0.5000*noise( p ); p = m2*p*2.02;\\n    f += 0.2500*noise( p ); p = m2*p*2.03;\\n    f += 0.1250*noise( p ); p = m2*p*2.01;\\n    f += 0.0625*noise( p );\\n    \\n    return f/0.9375;\\n}\\n\\n// fBm\\nfloat fbm3(vec3 p, float a, float f) {\\n    return noise(p);\\n}\\n\\nfloat fbm3_high(vec3 p, float a, float f) {\\n    float ret = 0.0;    \\n    float amp = 1.0;\\n    float frq = 1.0;\\n    for(int i = 0; i < 4; i++) {\\n        float n = pow(noise(p * frq),2.0);\\n        ret += n * amp;\\n        frq *= f;\\n        amp *= a * (pow(n,0.2));\\n    }\\n    return ret;\\n}\\n\\n//-----------------------------------------------------\\n// Lightning functions\\n//-----------------------------------------------------\\n\\nfloat diffuse(vec3 n,vec3 l) { \\n    return clamp(dot(n,l),0.,1.);\\n}\\n\\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\\n}\\n\\n//-----------------------------------------------------\\n// Math functions\\n//-----------------------------------------------------\\n\\nvec2 rotate(float angle, vec2 v) {\\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\\n}\\n\\nfloat boolSub(float a,float b) { \\n    return max(a,-b); \\n}\\nfloat sphere(vec3 p,float r) {\\n\\treturn length(p)-r;\\n}\\n\\n//-----------------------------------------------------\\n// Intersection functions (by iq)\\n//-----------------------------------------------------\\n\\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\\n    return (pos-sph.xyz)/sph.w;\\n}\\n\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n\\tvec3 oc = ro - sph.xyz;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - sph.w*sph.w;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return -1.0;\\n\\treturn -b - sqrt( h );\\n}\\n\\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\\n    return obj.xyz;\\n}\\n\\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\\n}\\n\\n\\n//-----------------------------------------------------\\n// Wet stone by TDM\\n// \\n// https://www.shadertoy.com/view/ldSSzV\\n//-----------------------------------------------------\\n\\nfloat rock( const in vec3 p, const in vec3 id ) {  \\n    float d = sphere(p,ASTEROID_RADIUS);    \\n    for(int i = 0; i < 7; i++) {\\n        float ii = float(i)+id.x;\\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\\n    \\td = boolSub(d,sphere(p+v*r,r * 0.8));       \\n    }\\n    return d;\\n}\\n\\nfloat map( const in vec3 p, const in vec3 id) {\\n    float d = rock(p, id) + fbm3(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\\n    return d;\\n}\\n\\nfloat map_detailed( const in vec3 p, const in vec3 id) {\\n    float d = rock(p, id) + fbm3_high(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\\n    return d;\\n}\\n\\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\\n    float xyangle = (id.x-.5)*iTime*2.;\\n    ro.xy = rotate( xyangle, ro.xy );\\n    \\n    float yzangle = (id.y-.5)*iTime*2.;\\n    ro.yz = rotate( yzangle, ro.yz );\\n}\\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\\n    float yzangle = (id.y-.5)*iTime*2.;\\n    ro.yz = rotate( -yzangle, ro.yz );\\n\\n    float xyangle = (id.x-.5)*iTime*2.;\\n    ro.xy = rotate( -xyangle, ro.xy );  \\n}\\n// tracing\\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\\n    asteroidTransForm( p, id );\\n    \\n    vec3 n;\\n    n.x = map_detailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\\n    n.y = map_detailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\\n    n.z = map_detailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\\n    n = normalize(n-map_detailed(p, id));\\n    \\n    asteroidUnTransForm( n, id );\\n    return n;\\n}\\n\\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\\n\\n    asteroidTransForm( ori, id );\\n    asteroidTransForm( dir, id );\\n    \\n    vec2 td = vec2(0.0);\\n    for(int i = 0; i < ASTEROID_NUM_STEPS; i++) {\\n        vec3 p = ori + dir * td.x;\\n        td.y = map(p, id);\\n        if(td.y < ASTEROID_TRESHOLD) break;\\n        td.x += (td.y-ASTEROID_TRESHOLD) * 0.9;\\n    }\\n    return td;\\n}\\n\\n// stone\\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\\n   vec3 color = RING_COLOR_1;\\n        \\n\\tfloat fresnel = .5*pow(1.0-abs(dot(n,e)),5.);\\n    color = mix( diffuse(n,l)*color*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0),fresnel);    \\n    \\n    return color;\\n}\\n\\n\\n//-----------------------------------------------------\\n// Ring (by me ;))\\n//-----------------------------------------------------\\n\\nvec3 ringShadowColor( const in vec3 ro ) {\\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\\n        return vec3(0.);\\n    }\\n    return vec3(1.);\\n}\\n\\nbool ringMap( const in vec3 ro ) {\\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\\n}\\n\\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \\n// find startpoint \\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\\n   \\n    if( d1 < 0. && d2 < 0. ) return vec4( 0. );\\n    \\n    float d = min( max(d1,0.), max(d2,0.) );\\n    \\n    if( d > ASTEROID_MAX_DISTANCE ) return vec4( 0. );\\n    \\n    vec3 ros = ro + rd*d;\\n    \\n    // avoid precision problems..\\n    vec2 mroxy = mod(ros.xy, vec2(5.));\\n    vec2 roxy = ros.xy - mroxy;\\n    ros.xy -= roxy;\\n    \\n    ros /= RING_VOXEL_STEP_SIZE;\\n    \\n\\tvec3 pos = floor(ros);\\n\\tvec3 ri = 1.0/rd;\\n\\tvec3 rs = sign(rd);\\n\\tvec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\\n\\t\\n    float alpha = 0., dint;\\n\\tvec3 offset = vec3(0.), id, asteroidro;\\n    vec2 asteroid;\\n    \\n\\tfor( int i=0; i<RING_VOXEL_STEPS; i++ ) {\\n\\t\\tif( ringMap(pos) ) {\\n            id = hash33(pos);\\n            offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\\n            dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\\n            \\n#ifdef SHOW_ASTEROIDS   \\n            if( dint > 0. ) {\\n                asteroidro = ros+rd*dint-(pos+offset);\\n    \\t        asteroid = asteroidSpheretracing( asteroidro, rd, id );\\n\\t\\t\\t\\t\\n                if( asteroid.y < .1 ) {\\n\\t                alpha = 1.;\\n        \\t    \\tbreak;\\t    \\n                }\\n            }\\n#else\\n        if( dint > 0. ) {\\n            alpha = 1.;\\n            break;\\t    \\n        }\\n#endif\\n        }\\n\\t\\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\\n\\t\\tdis += mm * rs * ri;\\n        pos += mm * rs;\\n\\t}\\n    \\n    if( alpha > 0. ) {\\n        \\n#ifdef SHOW_ASTEROIDS            \\n        vec3 intersection = ros + rd*(asteroid.x+dint);\\n        vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\\n#else\\n        vec3 intersection = ros + rd*dint;\\n        vec3 n = nSphere( intersection, vec4(pos+offset, ASTEROID_RADIUS) );     \\n#endif\\n        vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\\n\\n        intersection *= RING_VOXEL_STEP_SIZE;\\n        intersection.xy += roxy;\\n        col *= ringShadowColor( intersection );\\n         \\n\\t    return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\\n    }\\n    \\n\\treturn vec4(0.);\\n}\\n\\n//-----------------------------------------------------\\n// Ring (by me ;))\\n//-----------------------------------------------------\\n\\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\\n    // intersect plane\\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\\n    \\n    if( d > 0. && d < maxd ) {\\n        maxd = d;\\n\\t    vec3 intersection = ro + rd*d;\\n        float l = length(intersection.xy);\\n        \\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\\n            \\n            col *= ringShadowColor( intersection );\\n    \\t\\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\\n\\t\\t\\tcol *= SUN_COLOR;\\n            return vec4( col, dens );\\n        }\\n    }\\n    return vec4(0.);\\n}\\n\\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\\n    vec4 far = renderRingFar( ro, rd, maxd );\\n\\t\\n    float l = length( ro.xy );\\n    \\n    // detail needed ?\\n    \\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\\n     \\t\\n\\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\\n        far.xyz *= detail;    \\n    }\\n    \\n\\t// are asteroids neaded ?\\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\\n        \\n        vec4 near = renderRingNear( ro, rd );\\n        far = mix( far, near, near.w );\\n        maxd=0.;\\n    }\\n    \\n    return far;\\n}\\n\\n//-----------------------------------------------------\\n// Planet (by me ;))\\n//-----------------------------------------------------\\n\\nvec4 renderStars( const in vec3 rd ) {\\n\\tvec3 rds = rd;\\n\\tvec3 col = vec3(0);\\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\\n    \\n    vec2 xy = vec2(rds.y * v, rds.x * v);\\n    float s = noise(rds*134.);\\n //   s += noise_3(rds*370.);\\n    s += noise(rds*470.);\\n    s = pow(s,19.0) * 0.00001;\\n    if (s > 0.5) {\\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \\n        col += backStars;\\n    }\\n\\treturn   vec4( col, 1 ); \\n} \\n\\n//-----------------------------------------------------\\n// Planet (by me ;))\\n//-----------------------------------------------------\\n\\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, inout float maxd ) {\\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\\n                      \\n\\tif( d < 0. || d > maxd) {\\n        return vec4(0);\\n\\t}\\n    maxd = d;\\n    vec3 col = vec3( .2, 7., 4. ) * 0.4;\\n    \\n    col *= diffuse( normalize( ro+rd*d ), SUN_DIRECTION ) * SUN_COLOR;\\n                 \\n    float m = MAX;\\n    col *= (1. - renderRingFar( ro+rd*d, SUN_DIRECTION, m ).w );\\n    \\n \\treturn vec4( col, 1 ); \\n}\\n\\n//-----------------------------------------------------\\n// Atmospheric Scattering by GLtracy\\n// \\n// https://www.shadertoy.com/view/lslXDr\\n//-----------------------------------------------------\\n\\n// scatter const\\nconst float K_R = 0.166;\\nconst float K_M = 0.0025;\\nconst float E = 14.3; \\t\\t\\t\\t\\t\\t// light intensity\\nconst vec3  C_R = vec3( 0.3, 0.7, 1.0 ); \\t// 1 / wavelength ^ 4\\nconst float G_M = -0.85;\\t\\t\\t\\t\\t// Mie g\\n\\nconst float SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\\nconst float SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\\n\\nconst int NUM_OUT_SCATTER = 8;\\nconst float FNUM_OUT_SCATTER = 8.0;\\n\\nconst int NUM_IN_SCATTER = 8;\\nconst float FNUM_IN_SCATTER = 8.0;\\n\\n\\n// ray intersects sphere\\n// e = -b +/- sqrt( b^2 - c )\\nvec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {\\n\\tfloat b = dot( p, dir );\\n\\tfloat c = dot( p, p ) - r * r;\\n\\t\\n\\tfloat d = b * b - c;\\n\\tif ( d < 0.0 ) {\\n\\t\\treturn vec2( MAX, -MAX );\\n\\t}\\n\\td = sqrt( d );\\n\\t\\n\\treturn vec2( -b - d, -b + d );\\n}\\n\\n// Mie\\n// g : ( -0.75, -0.999 )\\n//      3 * ( 1 - g^2 )               1 + c^2\\n// F = ----------------- * -------------------------------\\n//      2 * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\\nfloat phase_mie( float g, float c, float cc ) {\\n\\tfloat gg = g * g;\\n\\t\\n\\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\\n\\n\\tfloat b = 1.0 + gg - 2.0 * g * c;\\n\\tb *= sqrt( b );\\n\\tb *= 2.0 + gg;\\t\\n\\t\\n\\treturn 1.5 * a / b;\\n}\\n\\n// Reyleigh\\n// g : 0\\n// F = 3/4 * ( 1 + c^2 )\\nfloat phase_reyleigh( float cc ) {\\n\\treturn 0.75 * ( 1.0 + cc );\\n}\\n\\nfloat density( vec3 p ){\\n\\treturn exp( -( length( p ) - EARTH_RADIUS ) * SCALE_H );\\n}\\n\\nfloat optic( vec3 p, vec3 q ) {\\n\\tvec3 step = ( q - p ) / FNUM_OUT_SCATTER;\\n\\tvec3 v = p + step * 0.5;\\n\\t\\n\\tfloat sum = 0.0;\\n\\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\\n\\t\\tsum += density( v );\\n\\t\\tv += step;\\n\\t}\\n\\tsum *= length( step ) * SCALE_L;\\n\\t\\n\\treturn sum;\\n}\\n\\nvec4 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\\n\\tfloat len = ( e.y - e.x ) / FNUM_IN_SCATTER;\\n\\tvec3 step = dir * len;\\n\\tvec3 p = o + dir * e.x;\\n\\tvec3 v = p + dir * ( len * 0.5 );\\n\\n    float sumdensity = 0.;\\n\\tvec3 sum = vec3( 0.0 );\\n\\n    for ( int i = 0; i < NUM_IN_SCATTER; i++ ) {\\n\\t\\tvec2 f = ray_vs_sphere( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\\n\\t\\tvec3 u = v + l * f.y;\\n\\t\\t\\n\\t\\tfloat n = ( optic( p, v ) + optic( v, u ) ) * ( PI * 4.0 );\\n\\t\\t\\n        float dens = density( v );\\n        \\n\\t    float m = MAX;\\n\\t\\tsum += dens * exp( -n * ( K_R * C_R + K_M ) ) \\n    \\t\\t* (1. - renderRingFar( u, SUN_DIRECTION, m ).w );\\n        \\n\\t\\tsumdensity += dens;\\n        \\n\\t\\tv += step;\\n\\t}\\n\\tsum *= len * SCALE_L;\\n\\t\\n\\tfloat c  = dot( dir, -l );\\n\\tfloat cc = c * c;\\n\\t\\n\\treturn vec4( sum * ( K_R * C_R * phase_reyleigh( cc ) + K_M * phase_mie( G_M, c, cc ) ) * E, sumdensity * len * SCALE_L);\\n}\\n\\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {\\n\\tvec2 e = ray_vs_sphere( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\\n\\tif ( e.x > e.y ) {\\n        d = MAX;\\n\\t\\treturn vec4(0.);\\n\\t}\\n\\t\\n\\tvec2 f = ray_vs_sphere( ro, rd, EARTH_RADIUS + 3. );\\n\\te.y = min( e.y, f.x );\\n\\td = e.y;\\n    \\n    return in_scatter( ro, rd, e, SUN_DIRECTION );\\n}\\n\\n//-----------------------------------------------------\\n// Lens flare by musk\\n//\\n// https://www.shadertoy.com/view/4sX3Rs\\n//-----------------------------------------------------\\n\\nvec3 lensflare(vec2 uv,vec2 pos) {\\n\\tvec2 main = uv-pos;\\n\\tvec2 uvd = uv*(length(uv));\\n\\t\\n\\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\\n\\t\\n\\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\\n\\n\\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\\n\\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\\n\\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\\n\\t\\n\\tvec2 uvx = mix(uv,uvd,-0.5);\\n\\t\\n\\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\\n\\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\\n\\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\\n\\t\\n\\tvec3 c = vec3(.0);\\n\\t\\n\\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\\n\\tc = c*.5 - vec3(length(uvd)*.05);\\n\\tc+=vec3(f0);\\n\\t\\n\\treturn c;\\n}\\n\\n//-----------------------------------------------------\\n// cameraPath\\n//-----------------------------------------------------\\n\\nvec3 pro, pta, pup;\\nfloat dro, dta, dup;\\n\\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\\n\\n    if( t >= prevt && t <= prevt+duration ) {\\n    \\tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\\n    }\\n    \\n    prev = dest;\\n    prevt += duration;\\n}\\n\\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\\n    t = mod( t, 66. );\\n    \\n    dro = dta = dup = 0.;\\n    \\n    pro = ro = vec3(-6300. ,-5000. ,1500. );\\n    pta = ta = vec3(    0. ,    0. ,   0. );\\n    pup = up = vec3(    0. ,    0.2,   1. ); \\n \\n  \\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \\n    \\n//    camint( ro, t, 5., vec3(-3300. , 1000. , 200. ), pro, dro );\\n//    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\\n//    camint( up, t, 6., vec3(    0. ,  -0.3,    1. ), pup, dup ); \\n    \\n    camint( ro, t, 8., vec3(-2000. , 1600. , 200. ), pro, dro );\\n    camint( ta, t, 5., vec3(    0. ,  700. ,-100. ), pta, dta );\\n    camint( up, t, 4., vec3(    0. ,  -0.3,    1. ), pup, dup ); \\n    \\n\\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\\n\\n    camint( ro, t, 15., vec3(-1354.95 , 1795.11 , 1.19 ), pro, dro );\\n    camint( ta, t, 19., vec3(    0. , 100. ,   600. ), pta, dta );\\n    camint( up, t, 14., vec3(    0. ,  0.3,    1. ), pup, dup );\\n    \\n    \\n    camint( ro, t, 7., vec3(-1354.93 , 1795.51 , 1.4 ), pro, dro );\\n    camint( ta, t, 7., vec3(    0. , 0. , 0. ), pta, dta );\\n    camint( up, t, 7., vec3(    0. ,  0.25,    1. ), pup, dup );\\n    \\n    \\n    camint( ro, t, 7., vec3(2900.5 , 3102. , 200.5 ), pro, dro );\\n    camint( ta, t, 7., vec3(    0. , 0. , 0. ), pta, dta );\\n    camint( up, t, 6., vec3(    0. ,  0.2,    1. ), pup, dup );\\n    \\n    camint( ro, t, 11., vec3(4102. , -2900. , 450. ), pro, dro );\\n    camint( ta, t, 11., vec3(    0. ,   -100. ,   0. ), pta, dta );\\n    camint( up, t, 18., vec3(    0. ,    0.15,   1. ), pup, dup ); \\n    \\n    camint( ro, t, 10., vec3(-6300. ,-5000. , 1500. ), pro, dro );\\n    camint( ta, t, 10., vec3(    0. ,    0. ,   0. ), pta, dta );\\n    camint( up, t, 3., vec3(    0. ,    0.2,   1. ), pup, dup ); \\n    \\n    up = normalize( up );\\n}\\n\\n//-----------------------------------------------------\\n// mainImage\\n//-----------------------------------------------------\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 uv = fragCoord.xy / iResolution.xy;\\n    \\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\\n    p.x *= iResolution.x/iResolution.y;\\n    \\n    // black bands\\n    vec2 bandy = vec2(.1,.9);\\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\\n        fragColor = vec4(0.,0.,0.,1.);\\n        return;\\n    }\\n    \\n    // camera\\n\\tvec3 ro, ta, up;\\n    cameraPath( iTime*.7, ro, ta, up );\\n      \\n    vec3 ww = normalize( ta - ro );\\n    vec3 uu = normalize( cross(ww,up) );\\n    vec3 vv = normalize( cross(uu,ww));\\n\\tvec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\\n    \\n    float maxd = MAX;  \\n\\tvec3 col = renderStars( rd ).xyz;\\n    \\n    vec4 planet = renderPlanet( ro, rd, maxd );       \\n    if( planet.w > 0. ) col.xyz = planet.xyz;\\n    \\n    float atmosphered = MAX;\\n    vec4 atmosphere = renderAtmospheric( ro, rd, atmosphered );\\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \\n\\n    vec4 ring = renderRing( ro, rd, maxd );\\n    if( ring.w > 0. && atmosphered < maxd ) {\\n\\t    ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \\n    }\\n    col = col * (1.-ring.w ) + ring.xyz;\\n    \\n    // post processing\\n\\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\\n\\tcol *= vec3(1.,0.99,0.95);   \\n\\tcol = clamp(1.06*col-0.03, 0., 1.);      \\n    \\n    \\n\\tvec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\\n\\tfloat flare = dot( SUN_DIRECTION, normalize(ta-ro) );\\n\\tcol += vec3(1.4,1.2,1.0)*lensflare(p, sunuv)*clamp( flare+.3, 0., 1.);\\n    \\n    fragColor = vec4( col ,1.0);\\n}\\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"\\n//----------------------------------------------------------------------\\n// Wind function by Dave Hoskins https://www.shadertoy.com/view/4ssXW2\\n\\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\nvec2 Hash( vec2 p) {\\n    return vec2( hash(p.x), hash(p.y) );\\n}\\n\\n//--------------------------------------------------------------------------\\nvec2 Noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\\n    return res-.5;\\n}\\n\\n//--------------------------------------------------------------------------\\nvec2 FBM( vec2 p ) {\\n    vec2 f;\\n\\tf  = 0.5000\\t * Noise(p); p = p * 2.32;\\n\\tf += 0.2500  * Noise(p); p = p * 2.23;\\n\\tf += 0.1250  * Noise(p); p = p * 2.31;\\n    f += 0.0625  * Noise(p); p = p * 2.28;\\n    f += 0.03125 * Noise(p);\\n    return f;\\n}\\n\\n//--------------------------------------------------------------------------\\nvec2 Wind(float n) {\\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\\n    \\n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\\n    \\n\\treturn noise;\\n}\\n\\n//----------------------------------------------------------------------\\n\\n\\n\\nvec2 mainSound( in int samp,float time) {\\n    //16 - 38\\n //   time -= 7.5;\\n    time *= .7;\\n    float vol = 1.-smoothstep(14.,16.5, time);\\n    vol += smoothstep(34.5,38., time);\\n    vol = vol*.8+.2;\\n    \\n\\treturn Wind(time*.05) * vol;\\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"4tjGRh","date":"1427737621","viewed":134114,"name":"Planet Shadertoy","description":"A seamless space-to-surface flight. This is a tribute to all the great shaders on Shadertoy! Use chrome without angle (or a Mac) and run this shader on med, or high settings (line 4 or 5) to get the full shader and the detail I was aiming for.","likes":505,"published":"Public API","usePreview":1,"tags":["terrain","sea","space","ocean","planet","shadertoy","vr","asteroids"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Planet Shadertoy. Created by Reinder Nijhoff 2015\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4tjGRh\\n//\\n// It uses code from the following shaders:\\n//\\n// Wet stone by TDM\\n// Atmospheric Scattering by GLtracy\\n// Seascape by TDM\\n// Elevated and Terrain Tubes by IQ\\n// LLamels by Eiffie\\n// Lens flare by Musk\\n// \\n\\n//#define HIGH_QUALITY\\n//#define MED_QUALITY\\n//#define LOW_QUALITY\\n#define VERY_LOW_QUALITY\\n\\nconst float PI = 3.14159265359;\\nconst float DEG_TO_RAD = (PI / 180.0);\\nconst float MAX = 10000.0;\\n\\nconst float EARTH_RADIUS = 1000.;\\nconst float EARTH_ATMOSPHERE = 5.;\\nconst float EARTH_CLOUDS = 1.;\\n\\nconst float RING_INNER_RADIUS = 1500.;\\nconst float RING_OUTER_RADIUS = 2300.;\\nconst float RING_HEIGHT = 2.;\\n\\n#ifdef HIGH_QUALITY\\n    const int   SEA_NUM_STEPS = 7;\\n    const int\\tTERRAIN_NUM_STEPS = 140;\\n    const int   ASTEROID_NUM_STEPS = 11;\\n\\tconst int\\tASTEROID_NUM_BOOL_SUB = 7;\\n    const int   RING_VOXEL_STEPS = 25;\\n    const float ASTEROID_MAX_DISTANCE = 1.1; \\n\\tconst int   FBM_STEPS = 4;\\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\\n\\n    #define DISPLAY_LLAMEL\\n    #define DISPLAY_CLOUDS\\n    #define DISPLAY_CLOUDS_DETAIL\\n    #define DISPLAY_TERRAIN_DETAIL\\n#endif\\n\\n#ifdef MED_QUALITY\\n    const int   SEA_NUM_STEPS = 6;\\n    const int\\tTERRAIN_NUM_STEPS = 100;\\n    const int   ASTEROID_NUM_STEPS = 10;\\n\\tconst int\\tASTEROID_NUM_BOOL_SUB = 6;\\n    const int   RING_VOXEL_STEPS = 24;\\n    const float ASTEROID_MAX_DISTANCE = 1.; \\n\\tconst int   FBM_STEPS = 4;\\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\\n    #define DISPLAY_CLOUDS\\n    #define DISPLAY_TERRAIN_DETAIL\\n    #define DISPLAY_CLOUDS_DETAIL\\n#endif\\n\\n#ifdef LOW_QUALITY\\n    const int   SEA_NUM_STEPS = 5;\\n    const int\\tTERRAIN_NUM_STEPS = 75;\\n    const int   ASTEROID_NUM_STEPS = 9;\\n\\tconst int\\tASTEROID_NUM_BOOL_SUB = 5;\\n    const int   RING_VOXEL_STEPS = 20;\\n    const float ASTEROID_MAX_DISTANCE = .85; \\n\\tconst int   FBM_STEPS = 3;\\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\\n#endif\\n\\n#ifdef VERY_LOW_QUALITY\\n    const int   SEA_NUM_STEPS = 4;\\n    const int\\tTERRAIN_NUM_STEPS = 60;\\n    const int   ASTEROID_NUM_STEPS = 7;\\n\\tconst int\\tASTEROID_NUM_BOOL_SUB = 4;\\n    const int   RING_VOXEL_STEPS = 16;\\n    const float ASTEROID_MAX_DISTANCE = .67; \\n\\tconst int   FBM_STEPS = 3;\\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\\n\\t#define HIDE_TERRAIN\\n#endif\\n\\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\\n\\nfloat time;\\n\\n//-----------------------------------------------------\\n// Noise functions\\n//-----------------------------------------------------\\n\\nfloat hash( const in float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\nfloat hash( const in vec2 p ) {\\n\\tfloat h = dot(p,vec2(127.1,311.7));\\t\\n    return fract(sin(h)*43758.5453123);\\n}\\nfloat hash( const in vec3 p ) {\\n\\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\\t\\n    return fract(sin(h)*43758.5453123);\\n}\\nvec3 hash31( const in float p) {\\n\\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\\t\\n    return fract(sin(h)*43758.543123);\\n}\\nvec3 hash33( const in vec3 p) {\\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\\n}\\n\\nfloat noise( const in  float p ) {    \\n    float i = floor( p );\\n    float f = fract( p );\\t\\n\\tfloat u = f*f*(3.0-2.0*f);\\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\\n}\\n\\nfloat noise( const in  vec2 p ) {    \\n    vec2 i = floor( p );\\n    vec2 f = fract( p );\\t\\n\\tvec2 u = f*f*(3.0-2.0*f);\\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \\n                     hash( i + vec2(1.0,0.0) ), u.x),\\n                mix( hash( i + vec2(0.0,1.0) ), \\n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\\n}\\nfloat noise( const in  vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    float n = p.x + p.y*157.0 + 113.0*p.z;\\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\\n}\\n\\nfloat tri( const in vec2 p ) {\\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\\n   \\n}\\n\\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\\n\\nfloat fbm( in vec2 p ) {\\n    float f = 0.0;\\n    f += 0.5000*noise( p ); p = m2*p*2.02;\\n    f += 0.2500*noise( p ); p = m2*p*2.03;\\n    f += 0.1250*noise( p ); \\n    \\n#ifndef LOW_QUALITY\\n#ifndef VERY_LOW_QUALITY\\n    p = m2*p*2.01;\\n    f += 0.0625*noise( p );\\n#endif\\n#endif\\n    return f/0.9375;\\n}\\n\\nfloat fbm( const in vec3 p, const in float a, const in float f) {\\n    float ret = 0.0;    \\n    float amp = 1.0;\\n    float frq = 1.0;\\n    for(int i = 0; i < FBM_STEPS; i++) {\\n        float n = pow(noise(p * frq),2.0);\\n        ret += n * amp;\\n        frq *= f;\\n        amp *= a * (pow(n,0.2));\\n    }\\n    return ret;\\n}\\n\\n//-----------------------------------------------------\\n// Lightning functions\\n//-----------------------------------------------------\\n\\nfloat diffuse( const in vec3 n, const in vec3 l) { \\n    return clamp(dot(n,l),0.,1.);\\n}\\n\\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \\n    float nrm = (s + 8.0) / (3.1415 * 8.0);\\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\\n}\\n\\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\\n}\\n\\n//-----------------------------------------------------\\n// Math functions\\n//-----------------------------------------------------\\n\\nvec2 rotate(float angle, vec2 v) {\\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\\n}\\n\\nfloat boolSub(float a,float b) { \\n    return max(a,-b); \\n}\\nfloat sphere(vec3 p,float r) {\\n\\treturn length(p)-r;\\n}\\n\\n//-----------------------------------------------------\\n// Intersection functions (by iq)\\n//-----------------------------------------------------\\n\\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\\n    return (pos-sph.xyz)/sph.w;\\n}\\n\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n\\tvec3 oc = ro - sph.xyz;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - sph.w*sph.w;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return -1.0;\\n\\treturn -b - sqrt( h );\\n}\\n\\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\\n\\tfloat b = dot( p, dir );\\n\\tfloat c = dot( p, p ) - r * r;\\n\\tfloat d = b * b - c;\\n\\tif ( d < 0.0 ) return -MAX;\\n\\treturn -b + sqrt( d );\\n}\\n\\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\\n\\tfloat b = dot( p, dir );\\n\\tfloat c = dot( p, p ) - r * r;\\n\\tfloat d = b * b - c;\\n\\tif ( d < 0.0 ) return vec2( MAX, -MAX );\\n\\td = sqrt( d );\\n\\treturn vec2( -b - d, -b + d );\\n}\\n\\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\\n    return obj.xyz;\\n}\\n\\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\\n}\\n\\n//-----------------------------------------------------\\n// Wet stone by TDM\\n// \\n// https://www.shadertoy.com/view/ldSSzV\\n//-----------------------------------------------------\\n\\nconst float ASTEROID_TRESHOLD \\t= 0.001;\\nconst float ASTEROID_EPSILON \\t= 1e-6;\\nconst float ASTEROID_DISPLACEMENT = 0.1;\\nconst float ASTEROID_RADIUS = 0.13;\\n\\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\\n\\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \\n    float d = sphere(p,ASTEROID_RADIUS);    \\n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\\n        float ii = float(i)+id.x;\\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\\n    \\td = boolSub(d,sphere(p+v*r,r * 0.8));       \\n    }\\n    return d;\\n}\\n\\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\\n    return d;\\n}\\n\\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\\n    return d;\\n}\\n\\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\\n    float xyangle = (id.x-.5)*time*2.;\\n    ro.xy = rotate( xyangle, ro.xy );\\n    \\n    float yzangle = (id.y-.5)*time*2.;\\n    ro.yz = rotate( yzangle, ro.yz );\\n}\\n\\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\\n    float yzangle = (id.y-.5)*time*2.;\\n    ro.yz = rotate( -yzangle, ro.yz );\\n\\n    float xyangle = (id.x-.5)*time*2.;\\n    ro.xy = rotate( -xyangle, ro.xy );  \\n}\\n\\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\\n    asteroidTransForm( p, id );\\n    \\n    vec3 n;\\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\\n    n = normalize(n-asteroidMapDetailed(p, id));\\n    \\n    asteroidUnTransForm( n, id );\\n    return n;\\n}\\n\\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\\n    asteroidTransForm( ori, id );\\n    asteroidTransForm( dir, id );\\n    \\n    vec2 td = vec2(0,1);\\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\\n        td.y = asteroidMap(ori + dir * td.x, id);\\n        td.x += td.y;\\n    }\\n    return td;\\n}\\n\\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\\n\\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \\n}\\n\\n//-----------------------------------------------------\\n// Ring (by me ;))\\n//-----------------------------------------------------\\n\\nconst float RING_DETAIL_DISTANCE = 40.;\\nconst float RING_VOXEL_STEP_SIZE = .03;\\n\\nvec3 ringShadowColor( const in vec3 ro ) {\\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\\n        return vec3(0.);\\n    }\\n    return vec3(1.);\\n}\\n\\nbool ringMap( const in vec3 ro ) {\\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\\n}\\n\\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \\n// find startpoint \\n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\\n    \\n    float d = min( max(d1,0.), max(d2,0.) );\\n   \\n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\\n        return vec4( 0. );\\n    } else {\\n        vec3 ros = ro + rd*d;\\n\\n        // avoid precision problems..\\n        vec2 mroxy = mod(ros.xy, vec2(10.));\\n        vec2 roxy = ros.xy - mroxy;\\n        ros.xy -= roxy;\\n        ros /= RING_VOXEL_STEP_SIZE;\\n        //ros.xy -= vec2(.013,.112)*time*.5;\\n\\n        vec3 pos = floor(ros);\\n        vec3 ri = 1.0/rd;\\n        vec3 rs = sign(rd);\\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\\n\\n        float alpha = 0., dint;\\n        vec3 offset = vec3(0), id, asteroidro;\\n        vec2 asteroid = vec2(0);\\n\\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\\n            if( ringMap(pos) ) {\\n                id = hash33(pos);\\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\\n\\n                if( dint > 0. ) {\\n                    asteroidro = ros+rd*dint-(pos+offset);\\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\\n\\n                    if( asteroid.y < .1 ) {\\n                        alpha = 1.;\\n                        break;\\t    \\n                    }\\n                }\\n\\n            }\\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\\n            dis += mm * rs * ri;\\n            pos += mm * rs;\\n        }\\n\\n        if( alpha > 0. ) {       \\n            vec3 intersection = ros + rd*(asteroid.x+dint);\\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\\n\\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\\n\\n            intersection *= RING_VOXEL_STEP_SIZE;\\n            intersection.xy += roxy;\\n          //  col *= ringShadowColor( intersection );\\n\\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\\n        } else {\\n            return vec4(0.);\\n        }\\n    }\\n}\\n\\n//-----------------------------------------------------\\n// Ring (by me ;))\\n//-----------------------------------------------------\\n\\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\\n    // intersect plane\\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\\n    \\n    if( d > 0. ) {\\n\\t    vec3 intersection = ro + rd*d;\\n        float l = length(intersection.xy);\\n        \\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\\n        } else {\\n            return 0.;\\n        }\\n    } else {\\n\\t    return 0.;\\n    }\\n}\\n\\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\\n    // intersect plane\\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\\n    \\n    if( d > 0. && d < maxd ) {\\n        maxd = d;\\n\\t    vec3 intersection = ro + rd*d;\\n        float l = length(intersection.xy);\\n        \\n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\\n            \\n            col *= ringShadowColor( intersection );\\n    \\t\\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\\n\\t\\t\\tcol *= SUN_COLOR;\\n            return vec4( col, dens );\\n        } else {\\n            return vec4(0.);\\n        }\\n    } else {\\n\\t    return vec4(0.);\\n    }\\n}\\n\\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\\n    vec4 far = renderRingFar( ro, rd, maxd );\\n    float l = length( ro.xy );\\n\\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \\n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \\n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\\n     \\t\\n\\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\\n        far.xyz *= detail;    \\n    }\\n    \\n\\t// are asteroids neaded ?\\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \\n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \\n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\\n        \\n        vec4 near = renderRingNear( ro, rd );\\n        far = mix( far, near, near.w );\\n        maxd=0.;\\n    }\\n            \\n    return far;\\n}\\n\\n//-----------------------------------------------------\\n// Stars (by me ;))\\n//-----------------------------------------------------\\n\\nvec4 renderStars( const in vec3 rd ) {\\n\\tvec3 rds = rd;\\n\\tvec3 col = vec3(0);\\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\\n    \\n    vec2 xy = vec2(rds.y * v, rds.x * v);\\n    float s = noise(rds*134.);\\n    \\n    s += noise(rds*470.);\\n    s = pow(s,19.0) * 0.00001;\\n    if (s > 0.5) {\\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \\n        col += backStars;\\n    }\\n\\treturn   vec4( col, 1 ); \\n} \\n\\n//-----------------------------------------------------\\n// Atmospheric Scattering by GLtracy\\n// \\n// https://www.shadertoy.com/view/lslXDr\\n//-----------------------------------------------------\\n\\nconst float ATMOSPHERE_K_R = 0.166;\\nconst float ATMOSPHERE_K_M = 0.0025;\\nconst float ATMOSPHERE_E = 12.3;\\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\\nconst float ATMOSPHERE_G_M = -0.85;\\n\\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\\n\\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\\n\\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\\n\\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\\n\\tfloat gg = g * g;\\n\\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\\n\\tfloat b = 1.0 + gg - 2.0 * g * c;\\n    \\n\\tb *= sqrt( b );\\n\\tb *= 2.0 + gg;\\t\\n\\t\\n\\treturn 1.5 * a / b;\\n}\\n\\nfloat atmosphericPhaseReyleigh( float cc ) {\\n\\treturn 0.75 * ( 1.0 + cc );\\n}\\n\\nfloat atmosphericDensity( vec3 p ){\\n\\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\\n}\\n\\nfloat atmosphericOptic( vec3 p, vec3 q ) {\\n\\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\\n\\tvec3 v = p + step * 0.5;\\n\\t\\n\\tfloat sum = 0.0;\\n\\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\\n\\t\\tsum += atmosphericDensity( v );\\n\\t\\tv += step;\\n\\t}\\n\\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\\n\\t\\n\\treturn sum;\\n}\\n\\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\\n\\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\\n\\tvec3 step = dir * len;\\n\\tvec3 p = o + dir * e.x;\\n\\tvec3 v = p + dir * ( len * 0.5 );\\n\\n    float sumdensity = 0.;\\n\\tvec3 sum = vec3( 0.0 );\\n\\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\\n\\t\\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\\n\\t\\tfloat dens = atmosphericDensity( v );\\n  \\n\\t    float m = MAX;\\n\\t\\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \\n    \\t\\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\\n \\t\\tsumdensity += dens;\\n        \\n\\t\\tv += step;\\n\\t}\\n\\tsum *= len * ATMOSPHERE_SCALE_L;\\n\\t\\n\\tfloat c  = dot( dir, -l );\\n\\tfloat cc = c * c;\\n\\t\\n\\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \\n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \\n                \\t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\\n}\\n\\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\\n\\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\\n\\tvec3 v = p + step * 0.5;\\n\\t\\n\\tfloat sum = 0.0;\\n\\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\\n\\t\\tsum += atmosphericDensity( v );\\n\\t\\tv += step;\\n\\t}\\n\\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\\n\\t\\n\\treturn sum;\\n}\\n\\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\\n\\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\\n\\tvec3 step = dir * len;\\n\\tvec3 p = o + dir * e.x;\\n\\tvec3 v = p + dir * ( len * 0.5 );\\n\\n\\tvec3 sum = vec3( 0.0 );\\n\\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\\n\\t\\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\\n\\t\\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\\n\\t    float m = MAX;\\n\\t\\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\\n\\t\\tv += step;\\n\\t}\\n\\tsum *= len * ATMOSPHERE_SCALE_L;\\n\\t\\n\\tfloat c  = dot( dir, -l );\\n\\tfloat cc = c * c;\\n\\t\\n\\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \\n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\\n}\\n\\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \\n    // inside or outside atmosphere?\\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\\n\\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\\n        \\n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\\n        if( d < e.y ) {\\n            e.y = d;\\n        }\\n\\t\\td = e.y;\\n\\t    e.x = 0.;\\n        \\n\\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\\n\\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\\n\\t\\t}\\n    } else {\\n    \\tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\\n        \\n        if ( e.x > e.y ) {\\n        \\td = MAX;\\n\\t\\t\\treturn vec4(0.);\\n\\t\\t}\\n\\t\\td = e.y = min( e.y, f.x );\\n    }\\n\\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\\n}\\n\\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\\n    e.x = 0.;\\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\\n}\\n\\n//-----------------------------------------------------\\n// Seascape by TDM\\n// \\n// https://www.shadertoy.com/view/Ms2SD1\\n//-----------------------------------------------------\\n\\nconst int   SEA_ITER_GEOMETRY = 3;\\nconst int   SEA_ITER_FRAGMENT = 5;\\n\\nconst float SEA_EPSILON\\t= 1e-3;\\n#define       SEA_EPSILON_NRM\\t(0.1 / iResolution.x)\\nconst float SEA_HEIGHT = 0.6;\\nconst float SEA_CHOPPY = 4.0;\\nconst float SEA_SPEED = 0.8;\\nconst float SEA_FREQ = 0.16;\\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\\nfloat       SEA_TIME;\\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\\n\\nfloat seaOctave( in vec2 uv, const in float choppy) {\\n    uv += noise(uv);        \\n    vec2 wv = 1.0-abs(sin(uv));\\n    vec2 swv = abs(cos(uv));    \\n    wv = mix(wv,swv,wv);\\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\\n}\\n\\nfloat seaMap(const in vec3 p) {\\n    float freq = SEA_FREQ;\\n    float amp = SEA_HEIGHT;\\n    float choppy = SEA_CHOPPY;\\n    vec2 uv = p.xz; uv.x *= 0.75;\\n    \\n    float d, h = 0.0;    \\n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \\n    \\td = seaOctave((uv+SEA_TIME)*freq,choppy);\\n    \\td += seaOctave((uv-SEA_TIME)*freq,choppy);\\n        h += d * amp;        \\n    \\tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\\n        choppy = mix(choppy,1.0,0.2);\\n    }\\n    return p.y - h;\\n}\\n\\nfloat seaMapHigh(const in vec3 p) {\\n    float freq = SEA_FREQ;\\n    float amp = SEA_HEIGHT;\\n    float choppy = SEA_CHOPPY;\\n    vec2 uv = p.xz; uv.x *= 0.75;\\n    \\n    float d, h = 0.0;    \\n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \\n    \\td = seaOctave((uv+SEA_TIME)*freq,choppy);\\n    \\td += seaOctave((uv-SEA_TIME)*freq,choppy);\\n        h += d * amp;        \\n    \\tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\\n        choppy = mix(choppy,1.0,0.2);\\n    }\\n    return p.y - h;\\n}\\n\\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \\n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \\n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \\n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\\n    \\n    color += upc*SEA_WATER_COLOR * (att * 0.18);\\n    color += sunc * vec3(specular(n,l,eye,60.0));\\n    \\n    return color;\\n}\\n\\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\\n    vec3 n;\\n    n.y = seaMapHigh(p);    \\n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\\n    n.y = eps;\\n    return normalize(n);\\n}\\n\\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \\n    float tm = 0.0;\\n    float tx = 1000.0;    \\n    float hx = seaMap(ori + dir * tx);\\n    if(hx > 0.0) return tx;   \\n    float hm = seaMap(ori + dir * tm);    \\n    float tmid = 0.0;\\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\\n        tmid = mix(tm,tx, hm/(hm-hx));                   \\n        p = ori + dir * tmid;                   \\n    \\tfloat hmid = seaMap(p);\\n\\t\\tif(hmid < 0.0) {\\n        \\ttx = tmid;\\n            hx = hmid;\\n        } else {\\n            tm = tmid;\\n            hm = hmid;\\n        }\\n    }\\n    return tmid;\\n}\\n\\nvec3 seaTransform( in vec3 x ) {\\n    x.yz = rotate( 0.8, x.yz );\\n    return x;\\n}\\n\\nvec3 seaUntransform( in vec3 x ) {\\n    x.yz = rotate( -0.8, x.yz );\\n    return x;\\n}\\n\\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \\n    vec3 p,\\n    rom = seaTransform(ro),\\n    rdm = seaTransform(rd);\\n    \\n    rom.y -= EARTH_RADIUS;\\n    rom *= 1000.;\\n    rom.xz += vec2(3.1,.2)*time;\\n\\n    SEA_TIME = time * SEA_SPEED;\\n    \\n    seaHeightMapTracing(rom,rdm,p);\\n    float squareddist = dot(p - rom, p-rom );\\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\\n    \\n    n = seaUntransform(n);\\n    \\n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\\n}\\n\\n//-----------------------------------------------------\\n// Terrain based on Elevated and Terrain Tubes by IQ\\n//\\n// https://www.shadertoy.com/view/MdX3Rr\\n// https://www.shadertoy.com/view/4sjXzG\\n//-----------------------------------------------------\\n\\n#ifndef HIDE_TERRAIN\\n\\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\\n\\nfloat terrainLow( vec2 p ) {\\n    p *= 0.0013;\\n\\n    float s = 1.0;\\n\\tfloat t = 0.0;\\n\\tfor( int i=0; i<2; i++ ) {\\n        t += s*tri( p );\\n\\t\\ts *= 0.5 + 0.1*t;\\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\\n\\t}\\n\\treturn t*33.0;\\n}\\n\\nfloat terrainMed( vec2 p ) {\\n    p *= 0.0013;\\n\\n    float s = 1.0;\\n\\tfloat t = 0.0;\\n\\tfor( int i=0; i<6; i++ ) {\\n        t += s*tri( p );\\n\\t\\ts *= 0.5 + 0.1*t;\\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\\n\\t}\\n            \\n    return t*33.0;\\n}\\n\\nfloat terrainHigh( vec2 p ) {\\n    vec2 q = p;\\n    p *= 0.0013;\\n\\n    float s = 1.0;\\n\\tfloat t = 0.0;\\n\\tfor( int i=0; i<7; i++ ) {\\n        t += s*tri( p );\\n\\t\\ts *= 0.5 + 0.1*t;\\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\\n\\t}\\n    \\n    t += t*0.015*fbm( q );\\n\\treturn t*33.0;\\n}\\n\\nfloat terrainMap( const in vec3 pos ) {\\n\\treturn pos.y - terrainMed(pos.xz);  \\n}\\n\\nfloat terrainMapH( const in vec3 pos ) {\\n    float y = terrainHigh(pos.xz);\\n    float h = pos.y - y;\\n    return h;\\n}\\n\\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\\n    float t = tmin;\\n\\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\\n        vec3 pos = ro + t*rd;\\n        float res = terrainMap( pos );\\n        if( res<(0.001*t) || t>tmax  ) break;\\n        t += res*.9;\\n\\t}\\n\\n\\treturn t;\\n}\\n\\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\\n\\tvec2  eps = vec2(150.0,0.0);\\n    float h1 = terrainMed( ro.xz );\\n    float h2 = terrainLow( ro.xz );\\n    \\n    float d1 = 10.0;\\n    float d2 = 80.0;\\n    float d3 = 200.0;\\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\\n\\n    return min(min(s1,s2),s3);\\n}\\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\\n\\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \\n\\t\\t\\t\\t\\t  e.yyx*terrainMapH( pos + e.yyx ) + \\n\\t\\t\\t\\t\\t  e.yxy*terrainMapH( pos + e.yxy ) + \\n\\t\\t\\t\\t\\t  e.xxx*terrainMapH( pos + e.xxx ) );\\n}\\n\\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\\n\\tfloat e = 0.005*t;\\n    vec2  eps = vec2(e,0.0);\\n    float h = terrainMed( pos.xz );\\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\\n}\\n\\nvec3 terrainTransform( in vec3 x ) {\\n    x.zy = rotate( -.83, x.zy );\\n    return x;\\n}\\n\\nvec3 terrainUntransform( in vec3 x ) {\\n    x.zy = rotate( .83, x.zy );\\n    return x;\\n}\\n\\n\\nfloat llamelTime;\\nconst float llamelScale = 5.;\\n\\nvec3 llamelPosition() {\\n    llamelTime = time*2.5;\\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\\n    return vec3( pos.x, terrainMed( pos ), pos.y );\\n}\\n\\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \\n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\\n\\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\\n    float dif = diffuse( n, sunDirection );\\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\\n    float sha = terrainCalcShadow( pos, sunDirection );\\n    float amb = clamp( n.y,0.0,1.0);\\n        \\n    vec3 lin  = vec3(0.0);\\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\\n    lin += 0.2*amb*upc;\\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\\n}\\n\\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\\n    vec3 nor = terrainCalcNormalHigh( pos, t );\\n    vec3 sor = terrainCalcNormalMed( pos, t );\\n        \\n    float spec = 0.005;\\n\\n#ifdef DISPLAY_TERRAIN_DETAIL\\n    float no = noise(5.*fbm(1.11*pos.xz));\\n#else\\n    const float no = 0.;\\n#endif\\n    float r = .5+.5*fbm(.95*pos.xz);\\n\\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\\n\\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\\n    col *= .88+.12*no;\\n        \\n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\\n    float sf = fwidth(s) * 1.5;\\n    s = smoothstep(0.84-sf, 0.84+sf, s );\\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\\n\\n   \\tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\\n\\n#ifdef DISPLAY_LLAMEL\\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\\n#endif\\n    \\n    return col;\\n}\\n\\nvec3 terrainTransformRo( const in vec3 ro ) {\\n    vec3 rom = terrainTransform(ro);\\n    rom.y -= EARTH_RADIUS - 100.;\\n    rom.xz *= 5.;\\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \\n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\\n    return rom;\\n}\\n\\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \\n    vec3 p,\\n    rom = terrainTransformRo(ro),\\n    rdm = terrainTransform(rd);\\n        \\n    float tmin = 10.0;\\n    float tmax = 3200.0;\\n    \\n    float res = terrainIntersect( rom, rdm, tmin, tmax );\\n    \\n    if( res > tmax ) {\\n        res = -1.;\\n    } else {\\n        vec3 pos =  rom+rdm*res;\\n        n = terrainCalcNormalMed( pos, res );\\n        n = terrainUntransform( n );\\n        \\n        intersection = ro+rd*res/100.;\\n    }\\n    return vec4(res, rom+rdm*res);\\n}\\n\\n#endif\\n\\n//-----------------------------------------------------\\n// LLamels by Eiffie\\n//\\n// https://www.shadertoy.com/view/ltsGz4\\n//-----------------------------------------------------\\n#ifdef DISPLAY_LLAMEL\\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\\n}\\n\\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\\n\\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\\n\\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\\n\\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\\n\\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\\n\\tu=p-j0;q=j1-j0;\\n\\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\\n\\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\\n\\tu=p-j1;q=j2-j1;\\n\\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\\n\\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\\n\\tu=p-j2;q=j3-j2;\\n\\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\\n\\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\\n}\\n\\nfloat llamelMap(in vec3 p) {\\n\\tconst vec3 rt=vec3(0.0,0.0,1.0);\\t\\n\\tp.y += 0.25*llamelScale;\\n    p.xz -= 0.5*llamelScale;\\n    p.xz = vec2(-p.z, p.x);\\n    vec3 pori = p;\\n        \\n    p /= llamelScale;\\n    \\n\\tvec2 c=floor(p.xz);\\n\\tp.xz=fract(p.xz)-vec2(0.5);\\n    p.y -= p.x*.04*llamelScale;\\n\\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\\n\\n    float b=0.83-abs(p.z);\\n\\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\\n\\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\\n\\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\\n\\tp.y-=0.03;\\n\\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\\n\\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\\n\\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\\n\\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\\n\\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\\n\\ta=max(abs(p.z),p.y)+0.05;\\n\\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\\n}\\n\\nvec3 llamelGetNormal( in vec3 ro ) {\\n    vec2 e = vec2(1.0,-1.0)*0.001;\\n\\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \\n\\t\\t\\t\\t\\t  e.yyx*llamelMap( ro + e.yyx ) + \\n\\t\\t\\t\\t\\t  e.yxy*llamelMap( ro + e.yxy ) + \\n\\t\\t\\t\\t\\t  e.xxx*llamelMap( ro + e.xxx ) );\\n}\\n\\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\\n    ro -= llamelPosition();\\n\\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\\n\\tfor(int i=0;i<36;i++){\\n\\t\\tt+=d=llamelMap(ro+rd*t);\\n\\t\\tif(d<dm){dm=d;tm=t;}\\n\\t\\tif(t>1000.0 || d<0.00001)break;\\n\\t}\\n\\tdm=max(0.0,dm);\\n    if( dm < .02 ) {\\n        vec3 col = vec3(0.45,.30,0.15)*.2;\\n        vec3 pos = ro + rd*tm;\\n        vec3 nor = llamelGetNormal( pos );\\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \\n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\\n    }\\n    \\n    return vec4(0.);\\n}\\n#endif\\n\\n//-----------------------------------------------------\\n// Clouds (by me ;))\\n//-----------------------------------------------------\\n\\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \\n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\\n\\tvec3 intersection = ro+rd*d;\\n    vec3 cint = intersection*0.009;\\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\\n\\n    cint.xy = rotate( rot, cint.xy );\\n\\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\\n\\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\\n\\n#ifdef DISPLAY_CLOUDS_DETAIL\\n    if( d < 200. ) {\\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\\n    }\\n#endif\\n\\n    shadow = clamp(1.-clouds, 0., 1.);\\n\\n    clouds = clamp(clouds, 0., 1.);\\n    clouds *= clouds;\\n    clouds *= smoothstep(0.,0.4,d);\\n\\n    vec3 clbasecolor = vec3(1.);\\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\\n    clcol += .3*clbasecolor*sunColor;\\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \\n    \\n    return vec4( clcol, clouds );\\n}\\n\\n//-----------------------------------------------------\\n// Planet (by me ;))\\n//-----------------------------------------------------\\n\\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\\n\\n    vec3 intersection = ro + rd*d;\\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\\n    vec4 res;\\n\\n#ifndef HIDE_TERRAIN\\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \\n        \\t\\t\\t\\t\\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\\n#endif\\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \\n    float mixDetailColor = 0.;\\n        \\n\\tif( d < 0. || d > maxd) {\\n#ifndef HIDE_TERRAIN\\n        if( renderTerrainDetail ) {\\n       \\t\\tintersection = ro;\\n            n = normalize( ro );\\n        } else { \\t       \\n\\t        return vec4(0);\\n        }\\n#else \\n      \\treturn vec4(0.);\\n#endif\\n\\t}\\n    if( d > 0. ) {\\n\\t    maxd = d;\\n    }\\n    float att = 0.;\\n    \\n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\\n    \\n    float dm = MAX, e = 0.;\\n    vec3 col, detailCol, nDetail;\\n    \\n    // normal and intersection \\n#ifndef HIDE_TERRAIN\\n    if( renderTerrainDetail ) {   \\n        res = renderTerrain( ro, rd, intersection, nDetail );\\n        if( res.x < 0. && d < 0. ) {\\n\\t        return vec4(0);\\n        }\\n        if( res.x >= 0. ) {\\n            maxd = pow(res.x/4000.,4.)*50.;\\n            e = -10.;\\n        }\\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\\n    } else \\n#endif        \\n    if( renderSeaDetail ) {    \\n        float attsea, mf = smoothstep(.5,1.,d);\\n\\n        renderSea( ro, rd, nDetail, attsea );\\n\\n        n = normalize(mix( nDetail, n, mf ));\\n        att = mix( attsea, att, mf );\\n    } else {\\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\\n#ifndef HIDE_TERRAIN\\n        if( d < 1500. ) {\\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\\n        }\\n#endif  \\n    }\\n    \\n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \\n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \\n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \\n                 \\n    // color  \\n#ifndef HIDE_TERRAIN\\n    if(renderTerrainDetail ) {\\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\\n\\t\\td = 0.;\\n    }   \\n#endif\\n     \\n    if( mixDetailColor < 1. ) {\\n        if( e < .45 ) {\\n            // sea\\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \\n        } else {\\n            // planet (land) far\\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\\n\\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\\n            vec3 landColor2 = RING_COLOR_1 * land2;\\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\\n\\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\\n#ifdef HIGH_QUALITY\\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\\n#endif\\n        }\\n    }\\n    \\n    if( mixDetailColor > 0. ) {\\n        col = mix( col, detailCol, mixDetailColor );\\n    }\\n        \\n#ifdef DISPLAY_LLAMEL\\n    if(renderTerrainDetail ) {\\n        vec3 rom = terrainTransformRo(ro),\\n        rdm = terrainTransform(rd);\\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\\n        if( d > 0. ) {\\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\\n            col = mix(col, llamel.rgb, llamel.a);\\n        }\\n    }\\n#endif\\n    \\n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\\n    if( d > 0. ) { \\n        float shadow;\\n\\t\\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\\n        col *= shadow; \\n        col = mix( col, clouds.rgb, clouds.w );\\n    }\\n    \\n    float m = MAX;\\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\\n\\n \\treturn vec4( col, 1. ); \\n}\\n\\n//-----------------------------------------------------\\n// Lens flare by musk\\n//\\n// https://www.shadertoy.com/view/4sX3Rs\\n//-----------------------------------------------------\\n\\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\\n\\tvec2 main = uv-pos;\\n\\tvec2 uvd = uv*(length(uv));\\n\\t\\n\\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\\n\\t\\n\\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\\n\\n\\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\\n\\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\\n\\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\\n\\t\\n\\tvec2 uvx = mix(uv,uvd,-0.5);\\n\\t\\n\\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\\n\\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\\n\\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\\n\\t\\n\\tvec3 c = vec3(.0);\\n\\t\\n\\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\\n\\tc = c*.5 - vec3(length(uvd)*.05);\\n\\tc+=vec3(f0);\\n\\t\\n\\treturn c;\\n}\\n\\n//-----------------------------------------------------\\n// cameraPath\\n//-----------------------------------------------------\\n\\nvec3 pro, pta, pup;\\nfloat dro, dta, dup;\\n\\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\\n    if( t >= prevt && t <= prevt+duration ) {\\n    \\tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\\n    }\\n    prev = dest;\\n    prevt += duration;\\n}\\n\\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\\n#ifndef HIDE_TERRAIN\\n    time = t = mod( t, 92. );\\n#else\\n    time = t = mod( t, 66. );\\n#endif\\n    dro = dta = dup = 0.;\\n\\n    pro = ro = vec3(900. ,7000. ,1500. );\\n    pta = ta = vec3(    0. ,    0. ,   0. );\\n    pup = up = vec3(    0. ,    0.4,   1. ); \\n   \\n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \\n \\n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\\n\\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\\n    \\n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\\n    \\n    camint( ro, t, 7.,roe, pro, dro );\\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\\n    camint( up, t, 6., upe, pup, dup );\\n        \\n    camint( ro, t, 17.,roe, pro, dro );\\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\\n    \\n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \\n#ifndef HIDE_TERRAIN    \\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\\n    \\n    camint( ro, t, 7., roe, pro, dro );\\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\\n    camint( up, t, 2., upe, pup, dup );\\n        \\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\\n    camint( ro, t, 17.,roe, pro, dro );\\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\\n        \\n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\\n    camint( ro, t, 4.,roe, pro, dro );\\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\\n#endif    \\n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \\n    \\n    up = normalize( up );\\n}\\n\\n//-----------------------------------------------------\\n// mainImage\\n//-----------------------------------------------------\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 uv = fragCoord.xy / iResolution.xy;\\n    \\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\\n    p.x *= iResolution.x/iResolution.y;\\n    \\n    vec3 col;\\n    \\n// black bands\\n    vec2 bandy = vec2(.1,.9);\\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\\n        col = vec3(0.);\\n    } else {\\n        // camera\\n        vec3 ro, ta, up;\\n        cameraPath( iTime*.7, ro, ta, up );\\n\\n        vec3 ww = normalize( ta - ro );\\n        vec3 uu = normalize( cross(ww,up) );\\n        vec3 vv = normalize( cross(uu,ww));\\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\\n\\n        float maxd = MAX;  \\n        col = renderStars( rd ).xyz;\\n\\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \\n        if( planet.w > 0. ) col.xyz = planet.xyz;\\n\\n        float atmosphered = maxd;\\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \\n\\n        vec4 ring = renderRing( ro, rd, maxd );\\n        if( ring.w > 0. && atmosphered < maxd ) {\\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \\n        }\\n        col = col * (1.-ring.w ) + ring.xyz;\\n\\n#ifdef DISPLAY_CLOUDS\\n        float lro = length(ro);\\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \\n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \\n\\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\\n                // clouds\\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\\n                if( d < maxd ) {\\n                    float shadow;\\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\\n                }\\n            }\\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\\n        }\\n#endif \\n\\n        // post processing\\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\\n        col *= vec3(1.,0.99,0.95);   \\n        col = clamp(1.06*col-0.03, 0., 1.);      \\n\\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\\n\\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \\n    }\\n    fragColor = vec4( col ,1.0);\\n}\\n\\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\\n    float maxd = MAX;  \\n    time = iTime * .7;\\n    \\n    rd = rd.xzy;\\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\\n    \\n    vec3 col = renderStars( rd ).xyz;\\n\\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \\n    if( planet.w > 0. ) col.xyz = planet.xyz;\\n\\n    float atmosphered = maxd;\\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \\n\\n    vec4 ring = renderRing( ro, rd, maxd );\\n    col = col * (1.-ring.w ) + ring.xyz;\\n    \\n    // post processing\\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\\n    col *= vec3(1.,0.99,0.95);   \\n    col = clamp(1.06*col-0.03, 0., 1.);      \\n    fragColor = vec4( col ,1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"\\n//----------------------------------------------------------------------\\n// Wind function by Dave Hoskins https://www.shadertoy.com/view/4ssXW2\\n\\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*43758.5453123);\\n}\\nvec2 Hash( vec2 p) {\\n    return vec2( hash(p.x), hash(p.y) );\\n}\\n\\n//--------------------------------------------------------------------------\\nvec2 Noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\\n    return res-.5;\\n}\\n\\n//--------------------------------------------------------------------------\\nvec2 FBM( vec2 p ) {\\n    vec2 f;\\n\\tf  = 0.5000\\t * Noise(p); p = p * 2.32;\\n\\tf += 0.2500  * Noise(p); p = p * 2.23;\\n\\tf += 0.1250  * Noise(p); p = p * 2.31;\\n    f += 0.0625  * Noise(p); p = p * 2.28;\\n    f += 0.03125 * Noise(p);\\n    return f;\\n}\\n\\n//--------------------------------------------------------------------------\\nvec2 Wind(float n) {\\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\\n    \\n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\\n    \\n\\treturn noise;\\n}\\n\\n//----------------------------------------------------------------------\\n\\n\\n\\nvec2 mainSound( in int samp,float time) {\\n    //16 - 38\\n //   time -= 7.5;\\n    time *= .7;\\n    float vol = 1.-smoothstep(6.,8.5, time);\\n    vol += smoothstep(16.5,20., time);\\n    vol *= 1.-smoothstep(23.5,25.5, time);\\n    vol += smoothstep(47.5,51.5, time);\\n    vol = vol*.8+.2;\\n    \\n\\treturn Wind(time*.05) * vol;\\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"MtsXzf","date":"1438956985","viewed":6070,"name":"[SIG15] Matrix Lobby Scene","description":"PLEASE REWIND ON FIRST LOAD (), TO MAKE SURE AUDIO IS IN SYNC.","likes":74,"published":"Public API","usePreview":0,"tags":["matrix","scene","sig15","lobby"]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Reinder Nijhoff 2015\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtsXzf\\n//\\n//   *Created for the Shadertoy Competition 2015*\\n//\\n// Theme: Your Favorite Movie/Game Moment\\n//\\n// https://www.shadertoy.com/eventsAugust2015.php5\\n//\\n\\n#define HIGHQUALITY 1\\n#define RENDERDEBRIS 0\\n#define REFLECTIONS 1\\n\\n#define MARCHSTEPS 90\\n#define MARCHSTEPSREFLECTION 30\\n#define DEBRISCOUNT 8\\n\\n#define BPM             (140.0)\\n#define STEP            (4.0 * BPM / 60.0)\\n#define ISTEP           (1./STEP)\\n#define STT(t)\\t\\t\\t(t*(60.0/BPM))\\n\\nfloat damageMod;\\nvec4 ep1, ep2, ep3, ep4, ep5;  \\n\\n//-----------------------------------------------------\\n// noise functions\\n\\n#define MOD2 vec2(.16632,.17369)\\nfloat hash(float p) { // by Dave Hoskins\\n\\tvec2 p2 = fract(vec2(p) * MOD2);\\n    p2 += dot(p2.yx, p2.xy+19.19);\\n\\treturn fract(p2.x * p2.y);\\n}\\n\\nfloat noise( const in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\tf = f*f*(3.0-2.0*f);\\n\\t\\n\\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\\n\\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\\n\\treturn mix( rg.x, rg.y, f.z );\\n}\\n\\nfloat noise( const in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\\n\\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0.0 ).x;\\n}\\n\\n//-----------------------------------------------------\\n// intersection functions\\n\\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\\n    return (pos-sph.xyz)/sph.w;\\n}\\n\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n\\tvec3 oc = ro - sph.xyz;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - sph.w*sph.w;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return -1.;\\n\\treturn -b - sqrt( h );\\n}\\n\\n//----------------------------------------------------------------------\\n// distance primitives\\n\\nfloat sdBox( const in vec3 p, const in vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdColumn( const in vec3 p, const in vec2 b ) {\\n    vec2 d = abs(p.xz) - b;\\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\n//----------------------------------------------------------------------\\n// distance operators\\n\\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\\n    \\n//--------------------------------------------\\n// map\\n\\nfloat tileId( const in vec3 p, const in vec3 nor ) { \\n    if( abs(nor.y) > .9 ) return 0.;\\n    \\n    float x, y;\\n    if( abs(nor.z) < abs(nor.x)) {\\n        x = p.z-6.;\\n    } else {\\n        x = abs(p.x)-16.;\\n    }\\n    if( p.y < 2.5 ) {\\n    \\treturn floor( x / 3.6 ) * sign(p.x);\\n    }\\n    return floor( x / 1.8 ) * sign(p.x) * (floor( (p.y+7.5) / 5. ));\\n}\\n\\n\\nvec3 bumpMapNormal( const in vec3 pos, in vec3 nor ) {\\n    float i = tileId( pos, nor );\\n    if( i > 0. ) {\\n        nor+= 0.0125 * vec3( hash(i), hash(i+5.), hash(i+13.) );\\n        nor = normalize( nor );\\n    }\\n    return nor;\\n}\\n\\nfloat map( const in vec3 p ) {\\n    float d = -sdBox( p, vec3( 28., 14., 63. ) );\\n\\n    vec3 pm = vec3( abs( p.x ) - 17.8, p.y, mod( p.z, 12.6 ) - 6.);    \\n    vec3 pm2 = abs(p) - vec3( 14., 25.25, 0. );\\n    vec3 pm3 = abs(p) - vec3( 6.8, 0., 56.4 );      \\n\\n    d = opU( d, sdColumn( pm, vec2( 1.8, 1.8 ) ) );        \\n    d = opS( d, sdBox( p,  vec3( 2.5, 9.5, 74. ) ) );    \\n    d = opS( d, sdBox( p,  vec3( 5., 18., 73. ) ) );\\n    d = opS( d, sdBox( p,  vec3( 13.8, 14.88, 63. ) ) );\\n    d = opS( d, sdBox( p,  vec3( 13.2, 25., 63. ) ) );\\n    d = opS( d, sdColumn( p,  vec2( 9.5, 63. ) ) ); \\n    d = opU( d, sdColumn( pm3, vec2( 1.8, 1.8 ) ) );\\n    d = opU( d, sdBox( pm2, vec3( 5., .45, 200. ) ) );\\n    \\n    return d;\\n}\\n\\nfloat mapDamage( vec3 p ) {\\n    float d = map( p );\\n\\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\\n                   noise( p*.3 )* (noise( p*2.3 ) +.2 )-.2 - damageMod, 0.);\\n   \\n\\treturn d + n;\\n}\\n\\nfloat mapDamageHigh( vec3 p ) {\\n    float d = map( p );\\n    \\n    float p1 = noise( p*2.3 );\\n    float p2 = noise( p*5.3 );\\n    \\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\\n                   noise( p*.3 )* (p1 +.2 )-.2 - damageMod, 0.);\\n  \\n    float ne = 0.;\\n    ne += smoothstep( -0.7, 0., -distance( p, ep1.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep2.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep3.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep4.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep5.xyz ) );\\n    \\n    n += .5 * max((ne - p2 ),0.) * ne;\\n  \\n    if( p.y < .1 ) {\\n        n += max(.1*(1.-abs(d)+7.*noise( p*.7 )+.9*p1+.5*p2)-4.5*damageMod,0.);\\n    }\\n    \\n    if( abs(n) > 0.0 ) {\\n        n += noise( p*11.) * .05;\\n        n += noise( p*23.) * .03;\\n    }\\n    \\n\\treturn d + n;\\n}\\n\\n\\nvec3 calcNormalDamage( in vec3 pos, in float eps ) {\\n    if( pos.y < 0.001 && (mapDamageHigh(pos)-map(pos)) < eps ) {   \\t\\t\\n\\t        return vec3( 0., 1., 0. );\\n    } else {    \\n        vec2 e = vec2(1.0,-1.0)*(0.5773*eps);\\n        vec3 n =  normalize( e.xyy*mapDamageHigh( pos + e.xyy ) + \\n                             e.yyx*mapDamageHigh( pos + e.yyx ) + \\n                             e.yxy*mapDamageHigh( pos + e.yxy ) + \\n                             e.xxx*mapDamageHigh( pos + e.xxx ) );\\n        n = bumpMapNormal( pos, n );\\n        return n;  \\n    }\\n}\\n\\n//----------------------------------------------------------------------\\n// lighting\\n\\nfloat calcAO( in vec3 pos, in vec3 nor ) {\\n\\tfloat occ = 0.0;\\n    for( int i=0; i<6; i++ ) {\\n        float h = 0.1 + 1.2*float(i);\\n        occ += (h-map( pos + h*nor ));\\n    }\\n    return clamp( 1.0 - occ*0.025, 0.0, 1.0 );    \\n}\\n\\nfloat calcFakeAOAndShadow( in vec3 pos ) { \\n    float r = (1.-abs(pos.x)/30.5);\\n    \\n    r *= max( min( .35-pos.z / 40., 1.), 0.65);\\n    r *= .5+.5*smoothstep( -66., -.65, pos.z);\\n    \\n    if( pos.y < 25. ) r *= 1.-smoothstep( 18., 25., .5*pos.y+abs(pos.x) ) * (.6+pos.y/25.);\\n    r *= 1.-smoothstep(5., 8., abs(pos.x) ) * .75 * (smoothstep( 60.,63.,abs(pos.z)));\\n    \\n    return clamp(r, 0., 1.);\\n}\\n\\n//----------------------------------------------------------------------\\n// materials\\n\\nfloat matMarble( in vec3 pos, in vec3 nor ) {\\n    float i = tileId( pos, nor );\\n    \\n    return .072*(hash(i)+noise(pos*7.))+.12*noise(pos*25.);\\n}\\n\\nfloat matSideLamp( in vec3 pos, in vec3 nor ) {\\n    float l = (1.-smoothstep(0.05,0.15, abs( pos.y-13.75 ) ))\\n        \\t* (1.-smoothstep(1.5,1.7, abs( mod(pos.z, 3.6)-1.8 ) ));\\n    return 5. * l;\\n}\\n\\nfloat matOutdoorLight( in vec3 pos, in vec3 nor ) {\\n    float l = ( smoothstep( 0.03, 0.1, abs( mod( pos.x, 1.8 ) / 1.8 - .5) ))\\n\\t\\t\\t* ( smoothstep( 0.03, 0.1, abs( mod( pos.y, 3.6 ) / 3.6 - .5) ));\\n    return mix( 8.,12., l);\\n}\\n\\nvec2 shade( in vec3 pos, in vec3 nor, in float m, in float t, in bool reflection ) {\\n    float refl = 0.1;\\n    float mate = 0.;\\n \\tfloat light = 0.;            \\n    float col = 0.;\\n    \\n    if( m < .5 ) {\\n   \\t\\tif( pos.y < .01 ) {\\n\\t    \\tmate = .05 * (.25+.2*texture( iChannel1, pos.xz*.05 ).r);\\n            float x = abs(pos.x);\\n            if( (x > 12. && x < 14.8) ||  (x > 3.2 && x < 6.8) || abs(pos.z) > 68.4 ) mate *= 0.25;\\n        } else if( pos.y > 13.5 && pos.y < 13.99 && abs( pos.x ) > 27.99 ) {\\n            light = matSideLamp( pos, nor ); \\n        } else if( pos.z > 62. && pos.y > 52. ) {\\n            light = matOutdoorLight( pos, nor );\\n        } else {\\n \\t\\t\\tmate = matMarble( pos, nor );\\n            refl = 0.05;\\n   \\t\\t}\\n        if( abs(mapDamageHigh(pos)-map(pos)) > 0.0001 * t ) {\\n            refl = 0.;\\n            mate = 0.21;\\n        }\\n        if( abs( pos.z ) > 73.1 ) {\\n            mate = 0.02;\\n            if( mod( abs( pos.x ), 2.25 ) < .3 ||\\n            \\tmod( abs( pos.y ), 2.25 ) < .3 ) mate = 0.0025;\\n            refl = 0.02;\\n        }\\n            \\n        if( nor.y < -0.8 && pos.y > 13.49 ) {\\n            col += mate * (0.4 * pow( max( (abs(pos.x*.38)-7.2),0.), 2.));\\n        }        \\n    } \\n#if RENDERDEBRIS\\n    else if( m < 1.5 ) {\\n            refl = 0.;\\n            mate = 0.1 * noise(pos);\\n    }\\n#endif\\n    \\n    col += mate * (\\n        25. * ( 0.02 +\\n        .2 * min(1., max( -nor.x * sign(pos.x), 0.)) + \\n        .5 * min(1., max( nor.y, 0. )) +\\n        .05 * abs( nor.z ) ) * calcFakeAOAndShadow( pos ) );\\n    \\n    col *= calcAO( pos, nor );\\n    col += light;\\n    \\n    return vec2( col, refl );\\n}\\n\\n//----------------------------------------------------------------------\\n// intersection code\\n\\nfloat intersect( in vec3 ro, in vec3 rd ) {\\n\\tconst float precis = 0.00125;\\n    float h = precis*2.0;\\n    float t = 0.1;\\n        \\n    float d = -(ro.y)/rd.y;\\n    float maxdist = d>0.?d:500.;\\n    \\n\\tfor( int i=0; i < MARCHSTEPS; i++ ) {\\n#if HIGHQUALITY\\n        h = .9*mapDamage( ro+rd*t );\\n#else\\n        h = map( ro+rd*t );\\n#endif\\n        if( abs(h) < precis ) {\\n            return t;\\n        } \\n        t += h;\\n        if( t > maxdist ) {\\n            return maxdist;\\n        }\\n    }\\n    return -1.;\\n}\\n\\n\\nfloat intersectReflection( in vec3 ro, in vec3 rd ) {\\n\\tconst float precis = 0.00125;\\n    float h = precis*2.0;\\n    float t = 0.;\\n        \\n    float d = -(ro.y)/rd.y;\\n    float maxdist = d>0.?d:500.;\\n    \\n\\tfor( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\\n        h = map( ro+rd*t );\\n        if( abs(h) < precis ) {\\n            return t;\\n        } \\n        t += h;\\n        if( t > maxdist ) {\\n            return maxdist;\\n        }\\n    }\\n    return -1.;\\n}\\n\\n//----------------------------------------------------------------------\\n// render functions\\n\\nfloat renderExplosionDebris( const in vec3 ro, const in vec3 rd, in float maxdist, const in vec4 ep, inout vec3 nor, \\n                             const in float time ) {\\n    float maxRadius = 30.*(time - ep.w - .025);\\n    float minRadius = 0.2 * maxRadius;\\n    if( maxRadius > 30. ) return maxdist;\\n    \\n    for( int i=0; i<DEBRISCOUNT; i++ ) {\\n        float id = hash(  ep.w+float(i) );\\n        vec3 dir = normalize( -1.+2.*vec3( id, hash(  ep.w+.5*float(i) ), hash(  ep.w+1.5*float(i) ) ) - vec3( 2.*sign(ep.x), 0., 0.) );\\n        vec3 pos = ep.xyz + dir*mix( minRadius, maxRadius, id ) + vec3(0.,-maxRadius*sin( maxRadius*0.005 ),0.);\\n        float d = iSphere( ro, rd, vec4( pos, 0.1*id+0.003 ) );\\n        if( d > 0. && d < maxdist ) {\\n            maxdist = d;\\n            nor = nSphere( ro+rd*d, vec4( pos, 0.1*id+0.003 ) );\\n        }\\n    }\\n    \\n    return maxdist;\\n}\\n\\nvoid renderExplosionDust( const in vec3 ro, const in vec3 rd, in float dist, const in vec4 ep, inout vec2 col, \\n                          const in float time, const in vec3 grd ) {\\n    float maxRadius = 10.*(time - ep.w + .25);\\n    if( maxRadius > 40. ) return ;\\n    \\n    float dens = 0.;\\n    float ho = hash( ep.w ); // id of explosion\\n    float fade = pow( 2., -maxRadius*0.11-2.);\\n    float zoom = 2.5/maxRadius;\\n    vec2 down = vec2(sin(maxRadius*0.005+.1), 0.);\\n                     \\n\\t// intersect planes\\n    vec2 d = -(ro.xz - ep.xz )/rd.xz;\\n    if( d.x > 0. ) {\\n        vec3 pos = ro+d.x*rd;\\n        float radius = distance( ep.yz, pos.yz );\\n        if( radius < maxRadius  ) {\\n            float l = max( 0.025*(dist-d.x) + .5, 0. ) \\n                        \\t\\t\\t* fade \\n                      \\t\\t\\t\\t* abs( grd.x )\\n                     \\t\\t\\t\\t* (1.-smoothstep( 0.8*maxRadius, maxRadius, radius ));            \\n\\t        float excol = mix( col.x, 1., pow( max(1.-2.*textureLod( iChannel2,ho+(pos.yz-ep.yz)*zoom + down, 0.0 ).x,0.),3.) );               \\n    \\t    col.x = mix( col.x, excol, l);\\n            col.y += l;\\n        }\\n    }\\n    \\n    if( d.y > 0. ) {\\n        vec3 pos = ro+d.y*rd;\\n        float radius = distance( ep.yx, pos.yx );\\n        if( radius < maxRadius  ) {\\n            float l = max( 0.025*(dist-d.y) + .5, 0. ) \\n                        \\t\\t\\t* fade \\n                      \\t\\t\\t\\t* abs( grd.z )\\n                     \\t\\t\\t\\t* (1.-smoothstep( 0.8*maxRadius, maxRadius, radius ));\\n\\t        float excol = mix( col.x, 1., pow( max(1.-2.*textureLod( iChannel2,ho+(pos.yx-ep.yx)*zoom + down, 0.0 ).x,0.),3.) );   \\n    \\t    col.x = mix( col.x, excol, l);\\n            col.y += l;\\n        }\\n    }\\n}\\n\\nvec3 render( const in vec3 ro, const in vec3 rd, in float time, const in float fog, const in vec3 grd ) {\\n    const float eps = 0.01;\\n    vec2 col = vec2(0.);\\n    \\n    float t = intersect( ro, rd );\\n    if( time > STT(98.) ) {\\n        time = STT(95.5)+.4*(time-STT(95.5)); // slow motion\\n    }\\n    time += .03*hash( rd.x + rd.y*5341.1231 ); // motionblur\\n    \\n    if( t > 0. ) {\\n        vec3 nor;\\n        float m = 0.;\\n\\n#if RENDERDEBRIS\\n        float d = renderExplosionDebris( ro, rd, t, ep1, nor, time );\\n        d = renderExplosionDebris( ro, rd, d, ep3, nor, time );\\n        d = renderExplosionDebris( ro, rd, d, ep5, nor, time );\\n#if HIGHQUALITY \\n        d = renderExplosionDebris( ro, rd, d, ep2, nor, time );\\n        d = renderExplosionDebris( ro, rd, d, ep4, nor, time );\\n#endif\\n        if( d < t ) {\\n            m = 1.;\\n            t = d;\\n        } \\n#endif\\n   \\n        vec3 pos = ro + t*rd;\\n        if( m < .5 ) {\\n\\t        nor = calcNormalDamage( pos, eps );\\n        }\\n        col = shade( pos, nor, m, t, false );\\n\\n#if REFLECTIONS        \\n        vec3 rdReflect = reflect( rd, -nor );\\n        float tReflect = intersectReflection( pos + eps*rdReflect, rdReflect );\\n\\n        if( tReflect >= 0. && col.y > 0. ) {\\n            vec3 posReflect = pos + tReflect*rdReflect;\\n            vec3 norReflect = calcNormalDamage( posReflect, eps );\\n\\n            col += shade( posReflect, norReflect, 0., tReflect, true ) * col.y;\\n        }\\n#endif\\n    } else {\\n        t = 60.;\\n    }\\n\\n    col.y = 0.; \\n    renderExplosionDust( ro, rd, t, ep1, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep2, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep3, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep4, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep5, col, time, grd );\\n    \\n // add fog\\n    vec3 dcol = vec3( max(col.x,0.) );\\n \\tdcol = mix( vec3(.5), dcol, exp( -t*(.02*fog+.005*col.y) ) );\\n        \\n    return pow( dcol, vec3(0.45) );\\n}\\n\\n//----------------------------------------------------------------------\\n// explosions\\n\\n#define E1(a,b,c,d) t+=a;if( time >= t ){ep1 = vec4(b,c,d,t);}\\n#define E2(a,b,c,d) t+=a;if( time >= t ){ep2 = vec4(b,c,d,t);}\\n#define E3(a,b,c,d) t+=a;if( time >= t ){ep3 = vec4(b,c,d,t);}\\n#define E4(a,b,c,d) t+=a;if( time >= t ){ep4 = vec4(b,c,d,t);}\\n#define E5(a,b,c,d) t+=a;if( time >= t ){ep5 = vec4(b,c,d,t);}\\n\\nvoid initExplosions( const in float time ) {\\n\\tep1 = ep2 = ep3 = ep4 = ep5 = vec4(-1000.);\\n    \\n    float t = 0.;    \\n    E1(STT(21.), 16., 3.9, 8.2 );\\n    E2(.7, 16., 5.4, 6.1 );\\n    E3(.3, 16., 6.3, 7.7 );\\n    E4(1., 16., 4.8, 8.2 );\\n    E5(.7, 16., 5.7, 7.3 );\\n    \\n    t = 0.;\\n    E1(STT(34.), -16., 3.9, 5.2 );\\n    E2(.5, -16., 5.4, 5.1 );\\n    E3(.7, -16., 6.3, 6.7 );\\n    E4(.5, -16., 4.8, 7.2 );\\n    E5(.4, -16., 5.7, 6.3 );\\n        \\n    t = 0.;\\n    E1(STT(42.), -19.1, 3.9, -4.5 );\\n    E2(1.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E1(.9, -16., 3.9, -5.2 );\\n    E2(.5, -16., 5.4, -5.1 );\\n    E3(.3, -16., 6.3, -6.7 );\\n    E4(.5, -16., 4.8, -7.2 );\\n    E5(.4, -16., 5.7, -6.3 );    \\n    \\n    t = 0.;    \\n    E1(STT(58.), 16., 3.9, 2.2 );\\n    E2(.2, 16., 5.4, 4.1 );\\n    E3(.3, 24., 6.3, 3.7 );\\n    E4(.5, 16., 4.8, 8.2 );\\n    E5(.7, 24., 5.7, 4.3 );\\n    E1(.1, 16., 1.9, 8.2 );\\n    E2(.2, 24., 5.4, -2.1 );\\n    \\n    t = 0.;\\n    E1(STT(66.), 16., 3.9, 6.5 );\\n    E2(.2, 16., 5.4, 6.1 );\\n    E5(.3, 16., 6.7, 7.3 );\\n    E3(.3, 16., 6.3, 5.7 );\\n    E4(.2, 16., 7.8, 6.2 );\\n        \\n    E5(.1, 16., 5.7, 4.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 17., 6.4, -4.5 );\\n    E3(.3, 16., 6.3, -5.7 );\\n    E4(.5, 16., 7.8, -6.2 );    \\n    E5(.3, 16., 5.7, -7.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 16., 6.4, -4.5 );\\n   \\n    t = 0.;\\n    E1(STT(78.), -17.1, 3.9, -4.5 );\\n    E2(.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(1.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E2(.5, -19.6, 5.4, -5.1 );\\n    E1(.9, -19.6, 3.9, -5.2 );\\n    E3(.3, -19.6, 6.3, -6.7 );\\n    E4(.5, -19.6, 4.8, -7.2 );\\n    E5(.4, -19.6, 5.7, -6.3 );\\n}\\n\\n//----------------------------------------------------------------------\\n// camera\\n\\nmat3 setCamera( const in vec3 ro, const in vec3 rt, const in float cr, const in float fl ) {\\n\\tvec3 cw = normalize(rt-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, -fl*cw );\\n}\\n\\n#define SCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){damageMod=j;sro=b;ero=c;sta=d;eta=e;st=t;dt=a;sfog=h;efog=i;}t+=a;\\n#define CCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){sro=ero;ero=c;sta=eta;eta=e;st=t;dt=a;sfog=efog;efog=i;}t+=a;\\n\\nvoid getCamPath( const in float time, inout vec3 ro, inout vec3 ta, inout float fl, inout float fog ) {\\n    vec3 sro, sta, ero, eta;\\n    float st = 0., dt, t = 0., sfog, efog;\\n    \\n    SCAM(STT(12.), 0., 0.,    0., 1.5, 1.5, vec3( 0., 5., 22.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \\n    SCAM(STT(7.5), 0., 0.,    0., 1.5, 1.5, vec3( -14., 5.,  18.5 ), vec3( 18., 4., 11. ), vec3( 10., 5., -50. ), vec3( 0., 5., -50. ) ); \\n    CCAM(STT(7.5), 0., 0.,  0.05, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 21.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \\n    CCAM(STT(2.5), 0., 0.05, 0.1, 1.5, 1.5, vec3( 21.5, 4., 11.5 ), vec3( 21.5, 4., 11.5 ),  vec3( -4., 7., 0. ), vec3( -16., 7., 8. ) ); \\n    CCAM(STT(4.), 0.,  0.1, 0.15, 1.5, 4.5, vec3( 21.5, 4., 11.5 ), vec3( 10., 4.25, 11.35 ),  vec3( -16., 7., 8. ), vec3( -16., 6., 8. ) ); \\n    \\n    SCAM(STT(7.5),  0., 0.1,  0.3, 1.5, 1.5, vec3( -11., 5.25, 7.05 ), vec3( -13., 5., 9. ),  vec3( -19., 5.2, 7. ), vec3( -16.5, 5., 5.3 ) );     \\n    SCAM(STT(13.), .4, 0.1,  0.5, 1.5, 1.5, vec3( -18., 5., 4.05 ), vec3( -10., 5.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 5.25, -7.3 ) );     \\n\\tCCAM(STT(4.), .45, 0.5,  0.65, 1.5, 1.2, vec3( -10., 5.25, -6. ), vec3( -12., 5.25, -9. ),  vec3( -15.5, 5.25, -7.3 ), vec3( -13.5, 6.25, 2.3 ) );     \\n\\n    SCAM(STT(7.5), .95, 0.4,  1.9, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 25.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \\n\\n    SCAM(STT(12.2), .95, 0.8,  1.3, 1.5, 1.5, vec3( 10., 4.7, 4. ), vec3( 10., 5., -7.5 ),  vec3( 50., 5., 2. ), vec3( 40., 5., -20. ) ); \\n    \\n    SCAM(STT(16.25), 1., 0.4,  0.8, 1.5, 1.5, vec3( -18., 4.5, 4.05 ), vec3( -26., 3.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 6.25, -7.3 ) );     \\n    CCAM(STT(4.),  1., 0.8,  0.6, 1.5, 1.5, vec3( -26., 3.25, -6. ), vec3( -26., 3.25, -6. ),  vec3( -15.5, 6.25, -7.3 ), vec3( -15.5, 6.25, -7.3 ) );     \\n\\n    SCAM(STT(16.), 1.1, 0.4, 0.05, 1.5, 1.5, vec3( 0., 5.,  18.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \\n  \\n    dt = clamp( (time-st)/dt, 0., 1. );\\n\\n    if(  time > STT(65.5) && time < STT(77.75)  ) {\\n\\t    ro = mix( sro, ero, dt);\\n    \\tta = mix( sta, eta, dt);\\n    } else {\\n\\t    ro = mix( sro, ero, smoothstep(0.,1., dt));\\n    \\tta = mix( sta, eta, smoothstep(0.,1., dt));\\n    }\\n\\t\\n    fl = 1.5;    \\n    if( time > STT(29.5) && time < STT(33.5) ) {\\n        fl = mix( 1.5, 4.5, smoothstep( STT(29.5), STT(33.5), time ) );\\n    }\\n    \\n   \\tfog = mix( sfog, efog, dt);\\n    damageMod = .4-.4*damageMod;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    float time = mod(iTime, 60.);\\n\\n    vec2 q = fragCoord.xy/iResolution.xy;\\n\\t    \\n    // letterbox\\n    if( abs(2.*fragCoord.y-iResolution.y) > iResolution.x * 0.42 ) {\\n        fragColor = vec4( 0., 0., 0., 1. );\\n        return;\\n    }\\n    vec3 ro, ta;\\n    float fl, fog;\\n      \\n    getCamPath( time, ro, ta, fl, fog );\\n        \\n    initExplosions( time );\\n    \\n    mat3 ca = setCamera( ro, ta, 0.0, (1./1.5) );    \\n    vec2 p = (-iResolution.xy+2.*(fragCoord.xy))/iResolution.x;\\n    vec3 rd = normalize( ca * vec3(p,-fl) );\\n\\n    vec3 col = render( ro, rd, time, fog, normalize( ta-ro ) );\\n    \\n    col *= vec3(0.704,0.778,0.704);    \\n\\tcol = col*0.8 + 0.2*col*col*(3.0-2.0*col);\\n\\tcol *= vec3(1.378,1.56,1.3);\\n        \\n    // vignette\\n    col *= 0.15 + 0.85*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\\n\\n    // flicker\\n    col *= 1.0 + 0.015*fract( 17.1*sin( 13.1*floor(12.0*iTime) ));\\n    \\n\\t// fade in\\n    col *= clamp( time*.7, 0., 1. );\\n    col *= clamp( abs(time-STT(12.)), 0., 1. );\\n    if( time < STT(33.5) ) col *= clamp( (STT(33.5)-time-.5), 0., 1. );\\n    col *= clamp( abs(time-STT(98.)), 0., 1. );\\n    \\n    fragColor = vec4( col, 1.0 );\\n}\\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"// Created by Reinder Nijhoff 2015\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtsXzf\\n//\\n\\n#define HIGHQUALITY 1\\n\\n#define N(a) if(t>b)x=b;b+=a;\\n#define NF(a,c,g) if(t>b){x=b;f=c;v=g;d=a;}b+=a;\\n\\n//----------------------------------------------------------------------------------------\\n\\n#define BPM             (140.0)\\n#define STEP            (4.0 * BPM / 60.0)\\n#define ISTEP           (1./STEP)\\n#define LOOPCOUNT\\t\\t(16.)\\n#define STT(t)\\t\\t\\t(t*(60.0/BPM))\\n\\n#define PI2 6.283185307179586476925286766559\\n\\n#define D 36.71\\n#define A 55.00\\t\\n#define B 61.74\\n#define C 65.41\\n\\n//-----------------------------------------------------\\n// noise functions\\n\\n#define MOD2 vec2(.16632,.17369)\\nfloat hash(const in float p) { // by Dave Hoskins\\n\\tvec2 p2 = fract(vec2(p) * MOD2);\\n    p2 += dot(p2.yx, p2.xy+19.19);\\n\\treturn fract(p2.x * p2.y);\\n}\\n\\nfloat sine(const in float x) {\\n    return sin(PI2 * x);\\n}\\n\\nfloat loop(const in float t, const in float steps) {\\n    return mod(t, steps * ISTEP);\\n}\\n\\nfloat distortion(const in float s, const in float d) {\\n\\treturn clamp(s * d, -1.0, 1.0);\\n}\\n\\nfloat quan(const in float s, const in float c) {\\n\\treturn floor(s / c) * c;\\n}\\n\\nbool inLoop( float time, float s, float e ) {\\n    float t = (time * (STEP / LOOPCOUNT));\\n    return ( t >= s && t < e );\\n}\\n\\n//-----------------------------------------------------\\n// instruments by iq and And\\n\\nfloat snare(const in float t, const in float f0) {\\n    float op3 = sine((t * f0) * 2.8020) * exp(-t * 1.0);\\n    float op2 = sine((t * f0) * 2.5000 + op3 * 1.00);\\n    float op1 = sine((t * f0) * 18.000 + op2 * 0.72);\\n\\n    return op1 * exp(-t * 5.5);\\n}\\n\\nfloat kick(float tb) {\\n\\tconst float aa = 5.0;\\n\\ttb = sqrt(tb * aa) / aa;\\n\\t\\n\\tfloat amp = exp(max(tb - 0.015, 0.0) * -5.0);\\n\\tfloat v = sine(tb * 100.0) * amp;\\n\\tv += distortion(v, 4.0) * amp;\\n\\treturn v;\\n}\\n\\nfloat bass(const in float time, const in float freq, const in float duration) {\\n    float ph = 1.0;\\n    ph *= sin(6.2831*freq*time);\\n    ph *= 0.1+0.9*max(0.0,6.0-0.01*freq);\\n    ph *= exp(-time*freq*0.3);\\n    \\n    \\n    float y = 0.;\\n    y += 0.70*sin(1.00*PI2*freq*time+ph);//*exp(-0.07*time);\\n    y += 0.90*sin(2.01*PI2*freq*time+ph);//*exp(-0.11*time);\\n\\n    y += 0.145*y*y*y;   \\n\\n    y *= 1.-smoothstep( duration*0.9, duration, time * STEP );\\n\\n    return y;\\n}\\n\\nfloat bell(const in float t, const in float f0) {\\n    float op3 = sine((f0 * t) * 6.0000             ) * exp(-t * 5.0);\\n    float op2 = sine((f0 * t) * 7.2364 + op3 * 0.20);\\n    float op1 = sine((f0 * t) * 2.0000 + op2 * 0.13) * exp(-t * 2.0);\\n\\n    return op1;\\n}\\n\\nfloat lift(float time) {\\n    return sin(PI2*D*32.*time)*exp(-6.0*time) + bell(time, D*32.);\\n}\\n\\nfloat gun(float time, float f, const in float d) {\\n    return distortion( textureLod( iChannel0, vec2(time*5.7864, time*6.9732)*f, 0. ).x *exp(-10.0*time)\\n                       * smoothstep(0.,0.1,time) * (1.-smoothstep(0.5,.6,time)), d);\\n}\\n\\n//-----------------------------------------------------\\n// loops\\n\\nfloat loopBass(const in float t, const in float m) {\\n    float x = 0., b = 0., f = 0., v = 0., d;\\n                \\n    NF(2.,D,0.9);NF(2.,D,1.);NF(1.,D,0.5);NF(1.,D,0.6);NF(1.,D,0.5);\\n    NF(2.,A,1.05);NF(1.,D,0.5);NF(2.,B,0.9);NF(1.,D,0.5); NF(3.,C,1.);\\n    f *= m;\\n    \\n    return v * bass( (t-x)*ISTEP, f, d );\\n\\n}\\n    \\nfloat loopBassIntro(const in float t) {\\n    float x = 0., b = 0., f = 0., v = 0., d;\\n    NF(4.,A,.5);NF(2.,D,.8);NF(8.,D,1.);NF(2.,D,.25);\\n    \\n    return v * bass( (t-x)*ISTEP, f*.5, d );\\n}\\n\\nfloat loopDrums(const in float t) {\\n    float x = 0., b = 0., r;\\n    \\n    // base\\n    N(3.);N(7.);N(1.);N(5.);\\n\\tr = kick( (t-x)*ISTEP*1.2 );\\n    \\n    // bell\\n    x = b = 0.;\\n    N(4.);N(4.);N(4.);N(2.);N(2.);\\n    r += .25 * bell( (t-x)*ISTEP*8., 100. );\\n    \\n    // hihat\\n    x = b = 0.;\\n    N(3.);N(3.);N(2.);N(2.);N(4.);\\n    r += .35 * snare( (t-x)*ISTEP*2., 200.+t );\\n    \\n    // snare\\n    x = b = 0.;\\n    N(4.);N(3.);N(2.);N(3.);N(1.);N(3.);\\n    r += .75 * snare( (t-x)*ISTEP*8., 10. );\\n\\n    return r;\\n}\\n\\nfloat loopDrumsIntro(const in float t) {\\n    float x = 0., b = 0.;\\n    \\n    // snare\\n    N(1.);N(3.);N(3.);N(2.);N(1.);N(1.);N(1.);N(1.);N(1.);N(1.);N(1.);\\n    return (t/24.) * snare( (t-x)*ISTEP*8., 10. ) + kick(  (t)*ISTEP*1.2 );\\n}\\n\\nfloat loopGun( const in float time, const in float interval, const in float numshots, \\n               const in float shotdelay, const in float minf, const in float maxf ) {\\n    float it = mod( time, interval );\\n\\n#if HIGHQUALITY\\n    float m = 0.;\\n    for( float sh = 0.; sh<2.5; sh+=1.) {\\n        if( sh < numshots ) {\\n            float g = (0.5+0.5*hash(sh+.5))*gun( it - sh*shotdelay - .5*shotdelay*hash(sh), mix(minf, maxf, hash(sh+.25)), 1.5 );\\n    \\t\\tm = m+g - abs(m)*g;\\n        }\\n    }\\n \\n    return m;\\n#else\\n    float sh = floor( it/shotdelay );\\n    if( sh < numshots ) {\\n        return (0.5+0.5*hash(sh+.5))*gun( it - sh*shotdelay - .5*shotdelay*hash(sh), mix(minf, maxf, hash(sh+.25)), 1.5 );\\n    }\\n    return 0.;\\n#endif\\n}\\n\\n\\n\\n//-----------------------------------------------------\\n// music\\n\\nfloat loopMusic(const in float time) {\\n\\tfloat mtime = loop( time, 16. );\\n    float t = mtime * STEP;\\n    float m = 1.;\\n    \\n    float d = 0.;\\n    float b = 0.;\\n    \\n    if( inLoop( time, 2., 36. ) && !inLoop( time, 6., 8. ) && !inLoop( time, 15., 16. )  ) {\\n        d = loopDrums( t );\\n    }\\n    \\n    if( inLoop( time, 1., 2. ) || inLoop( time, 7., 8. ) || inLoop( time, 11., 12. ) ) {\\n        d += loopDrumsIntro( t );\\n    }\\n    \\n    if( inLoop( time, 10., 12. ) ) {\\n        m = B/D;\\n    }\\n\\n    return loopBass( t, m ) + .5*d;\\n}\\n\\nfloat loopIntro(const in float time) {\\n\\tfloat mtime = loop( time, 16. );\\n    float t = mtime * STEP;\\n    \\n\\tif( inLoop( time, .74, 5.25 ) ) {\\n        return loopBassIntro( t );\\n    }\\n    return 0.;\\n}\\n    \\nfloat loopBackground( const in float time ) {\\n    float m = 0., g = 0.;\\n    g = .5 * loopGun( time, 2., 3., .21, 1., 1.5 );\\n    m = m+g - abs(m)*g;\\n    \\n    g = .95 * loopGun( time-4.123, 3., 1., 1.5, 1., 1.5 );\\n    m = m+g - abs(m)*g;\\n    \\n    g = .7 * loopGun( time-3., 3.2, 2., .41, 1., 1.5 );\\n    m = m+g - abs(m)*g;\\n    \\n    return m;\\n}\\n\\nvoid initExplosions( in float time );\\nfloat exTime1, exTime2;\\n\\n//-----------------------------------------------------\\n// main\\n    \\nvec2 mainSound( in int samp,float time) {\\n        \\n    initExplosions(time);\\n    // align with music\\n    exTime1 = floor( exTime1 / ISTEP * 2.)*ISTEP*.5;\\n    exTime2 = floor( exTime2 / ISTEP * 2.)*ISTEP*.5;\\n    \\n    float m = 0., music = 0., gun1 = 0., gun2 = 0., bg = 0.;\\n    \\n    if( time < STT(34.) ) {\\n        music = loopIntro( time );\\n    } else if( time < STT(98.) ){\\n        music = loopMusic( time-STT(34.) );\\n    }\\n    music *= .25;\\n    \\n    gun1 = gun( time-exTime1, mix(1.,1.5,hash(exTime1)), 3. );\\n    gun2 = gun( time-exTime2, mix(1.,1.5,hash(exTime2)), 3. );\\n    \\n    if( time > STT(34.) && time < STT(84.)  ) {\\n        bg = loopBackground(time);\\n    }\\n    \\n    m = m+bg - abs(m)*bg;\\n    m = m+music - abs(m)*music;\\n    \\n    m = m+gun1 - abs(m)*gun1;\\n    m = m+gun2 - abs(m)*gun2;\\n    \\n    m *= 1.5;\\n    \\n    if( time > 44.5 ) m += .0625*lift( time-44.5);\\n    \\n    return vec2( clamp(m, -1., 1.) );\\n}\\n\\n\\n//----------------------------------------------------------------------\\n// explosions\\n\\n#define E1(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n#define E2(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n#define E3(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n#define E4(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n#define E5(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n\\nvoid initExplosions( in float time ) {\\n\\texTime1 = exTime2 = -1000.;\\n    \\n    float t = 0.;    \\n    E1(STT(21.), 16., 3.9, 8.2 );\\n    E2(.7, 16., 5.4, 6.1 );\\n    E3(.3, 16., 6.3, 7.7 );\\n    E4(1., 16., 4.8, 8.2 );\\n    E5(.7, 16., 5.7, 7.3 );\\n    \\n    t = 0.;\\n    E1(STT(34.), -16., 3.9, 5.2 );\\n    E2(.5, -16., 5.4, 5.1 );\\n    E3(.7, -16., 6.3, 6.7 );\\n    E4(.5, -16., 4.8, 7.2 );\\n    E5(.4, -16., 5.7, 6.3 );\\n        \\n    t = 0.;\\n    E1(STT(42.), -19.1, 3.9, -4.5 );\\n    E2(1.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E1(.9, -16., 3.9, -5.2 );\\n    E2(.5, -16., 5.4, -5.1 );\\n    E3(.3, -16., 6.3, -6.7 );\\n    E4(.5, -16., 4.8, -7.2 );\\n    E5(.4, -16., 5.7, -6.3 );    \\n    \\n    t = 0.;    \\n    E1(STT(58.), 16., 3.9, 2.2 );\\n    E2(.2, 16., 5.4, 4.1 );\\n    E3(.3, 24., 6.3, 3.7 );\\n    E4(.5, 16., 4.8, 8.2 );\\n    E5(.7, 24., 5.7, 4.3 );\\n    E1(.1, 16., 1.9, 8.2 );\\n    E2(.2, 24., 5.4, -2.1 );\\n    \\n    t = 0.;\\n    E1(STT(66.), 16., 3.9, 6.5 );\\n    E2(.2, 16., 5.4, 6.1 );\\n    E5(.3, 16., 6.7, 7.3 );\\n    E3(.3, 16., 6.3, 5.7 );\\n    E4(.2, 16., 7.8, 6.2 );\\n        \\n    E5(.1, 16., 5.7, 4.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 17., 6.4, -4.5 );\\n    E3(.3, 16., 6.3, -5.7 );\\n    E4(.5, 16., 7.8, -6.2 );    \\n    E5(.3, 16., 5.7, -7.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 16., 6.4, -4.5 );\\n   \\n    t = 0.;\\n    E1(STT(78.), -17.1, 3.9, -4.5 );\\n    E2(.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(1.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E2(.5, -19.6, 5.4, -5.1 );\\n    E1(.9, -19.6, 3.9, -5.2 );\\n    E3(.3, -19.6, 6.3, -6.7 );\\n    E4(.5, -19.6, 4.8, -7.2 );\\n    E5(.4, -19.6, 5.7, -6.3 );\\n}\\n\\n","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"XdcGzr","date":"1447614697","viewed":3727,"name":"Matrix rain < 200 char","description":"Compacting [url=https://www.shadertoy.com/view/4tlXR4]matrix - 255 char[/url] by FabriceNeyret2 even more and added some color. All credits go to FabriceNeyret2.","likes":48,"published":"Public API","usePreview":0,"tags":["font","2tweets","short","pseudofont"]},"renderpass":[{"inputs":[],"outputs":[],"code":"// Created by Reinder Nijhoff 2015\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XdcGzr\\n//\\n// Based on matrix - 255 char by FabriceNeyret2: https://www.shadertoy.com/view/4tlXR4\\n// compacting to 2-tweets patriciogv's Matrix shader https://www.shadertoy.com/view/MlfXzN ( 819 -> 255 chars ) \\n// But first go see patriciogv's comments and readable sources :-D\\n//\\n// All credits go to FabriceNeyret2\\n//\\n\\n#define R fract(43.*sin(dot(p,p)))\\n\\nvoid mainImage( out vec4 o, vec2 i) {\\n    vec2 j = fract(i*=.1), \\n         p = vec2(9,int(iTime*(9.+8.*sin(i-=j).x)))+i;\\n    o-=o; o.g=R; p*=j; o*=R>.5&&j.x<.6&&j.y<.8?1.:0.;\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ls3GWS","date":"1451947421","viewed":9091,"name":"Post process - FXAA","description":"Demonstrating post process FXAA on my shader [url=https://www.shadertoy.com/view/Xtf3zn]Tokyo[/url]. \\n\\nFXAA code from: [url=http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/]geeks3d[/url].\\n","likes":48,"published":"Public API","usePreview":0,"tags":["aliasing","post","fxaa","process","anti"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Reinder Nijhoff 2016\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/ls3GWS\\n//\\n// car model is made by Eiffie\\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\\n//\\n// demonstrating post process FXAA applied to my shader 'Tokyo': \\n// https://www.shadertoy.com/view/Xtf3zn\\n//\\n// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\\n//\\n\\n#define FXAA_SPAN_MAX 8.0\\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\\n#define FXAA_REDUCE_MIN   (1.0/128.0)\\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\\n\\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\\n    \\n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\\n\\n    vec3 luma = vec3(0.299, 0.587, 0.114);\\n    float lumaNW = dot(rgbNW, luma);\\n    float lumaNE = dot(rgbNE, luma);\\n    float lumaSW = dot(rgbSW, luma);\\n    float lumaSE = dot(rgbSE, luma);\\n    float lumaM  = dot(rgbM,  luma);\\n\\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\\n\\n    vec2 dir;\\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n\\n    float dirReduce = max(\\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\\n        FXAA_REDUCE_MIN);\\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\\n    \\n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\\n          dir * rcpDirMin)) * rcpFrame.xy;\\n\\n    vec3 rgbA = (1.0/2.0) * (\\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\\n    \\n    float lumaB = dot(rgbB, luma);\\n\\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\\n    \\n    return rgbB; \\n}\\n\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    vec2 rcpFrame = 1./iResolution.xy;\\n  \\tvec2 uv2 = fragCoord.xy / iResolution.xy;\\n        \\n    float splitCoord = (iMouse.x == 0.0) ? iResolution.x/2. + iResolution.x*cos(iTime*.5) : iMouse.x;\\n    \\n    vec3 col;\\n    \\n    if( uv2.x < splitCoord/iResolution.x ) {\\n\\t   \\tvec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\\n\\t    col = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\\n    } else {\\n\\t    col = texture( iChannel0, uv2 ).xyz;\\n    }\\n    \\n    if (abs(fragCoord.x - splitCoord) < 1.0) {\\n\\t\\tcol.x = 1.0;\\n\\t}\\n    \\n    fragColor = vec4( col, 1. );\\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Reinder Nijhoff 2016\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/ls3GWS\\n//\\n// car model is made by Eiffie\\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\\n//\\n// demonstrating post process FXAA on my shader 'Tokyo': \\n// https://www.shadertoy.com/view/Xtf3zn\\n//\\n// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\\n//\\n\\n#define BUMPMAP\\n#define MARCHSTEPS 128\\n#define MARCHSTEPSREFLECTION 48\\n#define LIGHTINTENSITY 5.\\n\\n//----------------------------------------------------------------------\\n\\nconst vec3 backgroundColor = vec3(0.2,0.4,0.6) * 0.09;\\nfloat time;\\n\\n//----------------------------------------------------------------------\\n// noises\\n\\nfloat hash( float n ) {\\n    return fract(sin(n)*687.3123);\\n}\\n\\nfloat noise( in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    float n = p.x + p.y*157.0;\\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\\n}\\n\\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\\n\\nfloat fbm( vec2 p ) {\\n    float f = 0.0;\\n    f += 0.5000*noise( p ); p = m2*p*2.02;\\n    f += 0.2500*noise( p ); p = m2*p*2.03;\\n    f += 0.1250*noise( p ); p = m2*p*2.01;\\n//    f += 0.0625*noise( p );\\n    \\n    return f/0.9375;\\n}\\n\\n//----------------------------------------------------------------------\\n// distance primitives\\n\\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\\n  return length(max(abs(p)-b,0.0))-r;\\n}\\n\\nfloat sdBox( in vec3 p, in vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdSphere( in vec3 p, in float s ) {\\n    return length(p)-s;\\n}\\n\\nfloat sdCylinder( in vec3 p, in vec2 h ) {\\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\n//----------------------------------------------------------------------\\n// distance operators\\n\\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; } //from iq\\n\\n//----------------------------------------------------------------------\\n// Map functions\\n\\n// car model is made by Eiffie\\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\\n\\nfloat mapCar(in vec3 p0){ \\n\\tvec3 p=p0+vec3(0.0,1.24,0.0);\\n\\tfloat r=length(p.yz);\\n\\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\\n\\td=max(d,p.z-1.0);\\n\\tp=p0+vec3(0.0,-0.22,0.39);\\n\\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\\n\\tr=length(p.yz);\\n\\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\\n\\td=max(d,-max(p.x-0.165,r-0.24));\\n\\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\\n\\td=min(d,d2);\\n\\n\\treturn d;\\n}\\n\\nfloat dL; // minimal distance to light\\n\\nfloat map( const in vec3 p ) {\\n\\tvec3 pd = p;\\n    float d;\\n    \\n    pd.x = abs( pd.x );\\n    pd.z *= -sign( p.x );\\n    \\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\\n    float lh = hash( floor( pd.z/13. ) );\\n    \\n    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );\\n    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );\\n    \\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );\\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );\\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );\\n   \\n    if( lh > 0.5 ) {\\n\\t    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );\\n    }\\n    \\n    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );\\n\\td = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); \\n    \\n    d = opS( d, -(p.x+8.) );\\n    d = opU( d, pd.y );\\n\\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\\n    \\n    // car\\n    if( ch > 0.75 ) {\\n        pdc.x += (ch-0.75)*4.;\\n\\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );\\n\\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );\\n\\n        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );\\n \\t}\\n    \\n    d = opU( d, 13.-pd.x );\\n    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );\\n    d = opU( d, dL );\\n    \\n\\treturn d;\\n}\\n\\n//----------------------------------------------------------------------\\n\\nvec3 calcNormalSimple( in vec3 pos ) {   \\n    const vec2 e = vec2(1.0,-1.0)*0.005;\\n\\n    vec3 n = normalize( e.xyy*map( pos + e.xyy ) + \\n\\t\\t\\t\\t\\t    e.yyx*map( pos + e.yyx )   + \\n\\t\\t\\t\\t\\t    e.yxy*map( pos + e.yxy )   + \\n\\t\\t\\t\\t\\t    e.xxx*map( pos + e.xxx )   );  \\n    return n;\\n}\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    vec3 n = calcNormalSimple( pos );\\n    if( pos.y > 0.12 ) return n;\\n\\n#ifdef BUMPMAP\\n    vec2 oc = floor( vec2(pos.x+floor( pos.z * 4. )*0.25, pos.z) * vec2( 2., 4. ) );\\n\\n    if( abs(pos.x)<8. ) {\\n\\t\\toc = pos.xz;\\n    }\\n    \\n     vec3 p = pos * 250.;\\n   \\t vec3 xn = 0.05*vec3(noise(p.xz)-0.5,0.,noise(p.zx)-0.5);\\n     xn += 0.1*vec3(fbm(oc.xy)-0.5,0.,fbm(oc.yx)-0.5);\\n    \\n    n = normalize( xn + n );\\n#endif\\n    \\n    return n;\\n}\\n\\nvec3 int1, int2, nor1;\\nvec4 lint1, lint2;\\n\\nfloat intersect( in vec3 ro, in vec3 rd ) {\\n\\tconst float precis = 0.001;\\n    float h = precis*2.0;\\n    float t = 0.;\\n    int1 = int2 = vec3( -500. );\\n    lint1 = lint2 = vec4( -500. );\\n    float mld = 100.;\\n    \\n\\tfor( int i=0; i < MARCHSTEPS; i++ ) {\\n        h = map( ro+rd*t );\\n\\t\\tif(dL < mld){\\n\\t\\t\\tmld=dL;\\n            lint1.xyz = ro+rd*t;\\n\\t\\t\\tlint1.w = abs(dL);\\n\\t\\t}\\n        if( h < precis ) {\\n            int1.xyz = ro+rd*t;\\n            break;\\n        } \\n        t += max(h, precis*2.);\\n    }\\n    \\n    if( int1.z < -400. || t > 300.) {\\n        // check intersection with plane y = -0.1;\\n        float d = -(ro.y + 0.1)/rd.y;\\n\\t\\tif( d > 0. ) {\\n\\t\\t\\tint1.xyz = ro+rd*d;\\n\\t    } else {\\n        \\treturn -1.;\\n    \\t}\\n    }\\n    \\n    ro = ro + rd*t;\\n    nor1 = calcNormal(ro);\\n    ro += 0.01*nor1;\\n    rd = reflect( rd, nor1 );\\n    t = 0.0;\\n    h = precis*2.0;\\n    mld = 100.;\\n    \\n    for( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\\n        h = map( ro+rd*t );\\n\\t\\tif(dL < mld){\\n\\t\\t\\tmld=dL;            \\n            lint2.xyz = ro+rd*t;\\n\\t\\t\\tlint2.w = abs(dL);\\n\\t\\t}\\n        if( h < precis ) {\\n   \\t\\t\\tint2.xyz = ro+rd*t;\\n            return 1.;\\n        }   \\n        t += max(h, precis*2.);\\n    }\\n\\n    return 0.;\\n}\\n\\n//----------------------------------------------------------------------\\n// shade\\n\\nvec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {\\n    vec3  col = vec3(0.5);\\n    \\n    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );\\n    if( pos.y < 0.01 ) {\\n        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );\\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );\\n    }    \\n    \\n    float sh = clamp( dot( nor, normalize( vec3( -0.3, 0.3, -0.5 ) ) ), 0., 1.);\\n  \\tcol *= (sh * backgroundColor);  \\n \\n    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows\\n        float ha = hash(  133.1234*floor( pos.y / 3. ) + floor( (pos.z) / 3. ) );\\n        if( ha > 0.95) {\\n            col = ( (ha-0.95)*10.) * vec3( 1., 0.7, 0.4 );\\n        }\\n    }\\n    \\n\\tcol = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );\\n  \\n    return col;\\n}\\n\\nvec3 getLightColor( in vec3 pos ) {\\n    vec3 lcol = vec3( 1., .7, .5 );\\n    \\n\\tvec3 pd = pos;\\n    pd.x = abs( pd.x );\\n    pd.z *= -sign( pos.x );\\n    \\n    float ch = hash( floor( (pd.z+18.*time)/40. ) );\\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\\n\\n    if( ch > 0.75 ) { // car\\n        pdc.x += (ch-0.75)*4.;\\n        if(  sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ), 0.25) < 2. ) {\\n            lcol = vec3( 1., 0.05, 0.01 );\\n        }\\n    }\\n    if( pd.y > 2. && abs(pd.x) > 10. && pd.y < 5. ) {\\n        float fl = floor( pd.z/13. );\\n        lcol = 0.4*lcol+0.5*vec3( hash( .1562+fl ), hash( .423134+fl ), 0. );\\n    }\\n    if(  abs(pd.x) > 10. && pd.y > 5. ) {\\n        float fl = floor( pd.z/2. );\\n        lcol = 0.5*lcol+0.5*vec3( hash( .1562+fl ),  hash( .923134+fl ), hash( .423134+fl ) );\\n    }\\n   \\n    return lcol;\\n}\\n\\nfloat randomStart(vec2 co){return 0.8+0.2*hash(dot(co,vec2(123.42,117.853))*412.453);}\\n\\n//----------------------------------------------------------------------\\n// main\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \\n    time = iTime + 90.;\\n    vec2 q = fragCoord.xy / iResolution.xy;\\n\\tvec2 p = -1.0 + 2.0*q;\\n\\tp.x *= iResolution.x / iResolution.y;\\n        \\n    if (q.y < .12 || q.y >= .88) {\\n\\t\\tfragColor=vec4(0.,0.,0.,1.);\\n\\t\\treturn;\\n\\t}\\n    \\n    // camera\\n    float z = time;\\n    float x = -10.9+1.*sin(time*0.2);\\n\\tvec3 ro = vec3(x,  1.3+.3*cos(time*0.26), z-1.);\\n    vec3 ta = vec3(-8.,1.3+.4*cos(time*0.26), z+4.+cos(time*0.04));\\n    \\n    vec3 ww = normalize( ta - ro );\\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\\n    vec3 vv = normalize( cross(uu,ww));\\n\\tvec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\\n    \\n    vec3 col = backgroundColor;\\n\\n    // raymarch\\n    float ints = intersect(ro+randomStart(p)*rd ,rd );\\n    if(  ints > -0.5 ) {\\n        \\n        // calculate reflectance\\n\\t\\tfloat r = 0.09;     \\t        \\n        if( int1.y > 0.129 ) r = 0.025 * hash(  133.1234*floor( int1.y / 3. ) + floor( int1.z / 3. ) );\\n        if( abs(int1.x) < 8. ) {\\n            if( int1.y < 0.01 ) { // road\\n\\t            r = 0.007*fbm(int1.xz);\\n            } else { // car\\n                r = 0.02;\\n            }\\n        }\\n        if( abs( int1.x ) < 0.1 ) r *= 4.;\\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) r *= 4.;\\n        \\n        r *= 2.;\\n        \\n        col = shade( ro, int1.xyz, nor1 );\\n        \\n        if( ints > 0.5 ) {\\n            col += r * shade( int1.xyz, int2.xyz, calcNormalSimple(int2.xyz) );\\n        }  \\n        if( lint2.w > 0. ) {            \\n            col += (r*LIGHTINTENSITY*exp(-lint2.w*7.0)) * getLightColor(lint2.xyz);\\n        } \\n    } \\n      \\n    // Rain (by Dave Hoskins)\\n\\tvec2 st = 256. * ( p* vec2(.5, .01)+vec2(time*.13-q.y*.6, time*.13) );\\n    float f = noise( st ) * noise( st*0.773) * 1.55;\\n\\tf = 0.25+ clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\\n    \\n    if( lint1.w > 0. ) {\\n        col += (f*LIGHTINTENSITY*exp(-lint1.w*7.0)) * getLightColor(lint1.xyz);\\n    }  \\n    \\n\\tcol += 0.25*f*(0.2+backgroundColor);\\n\\n    // post processing\\n\\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\\n\\tcol *= 1.2*vec3(1.,0.99,0.95);   \\n\\tcol = clamp(1.06*col-0.03, 0., 1.);  \\n    q.y = (q.y-.12)*(1./0.76);\\n\\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ); \\n\\n    fragColor = vec4( col, 1.0 );\\n}\\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Ms33WB","date":"1452023671","viewed":11977,"name":"Post process - SSAO","description":"Demonstrating post process Screen Space Ambient Occlusion applied to a depth and normal map with the geometry of my shader [url=https://www.shadertoy.com/view/MtsXzf][SIG15] Matrix Lobby Scene'[/url].","likes":84,"published":"Public API","usePreview":1,"tags":["screen","post","space","occlusion","ambient","ssaa","process"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Reinder Nijhoff 2016\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/ls3GWS\\n//\\n//\\n// demonstrating post process Screen Space Ambient Occlusion applied to a depth and normal map\\n// with the geometry of my shader '[SIG15] Matrix Lobby Scene': \\n//\\n// https://www.shadertoy.com/view/MtsXzf\\n//\\n\\n\\n#define SAMPLES 16\\n#define INTENSITY 1.\\n#define SCALE 2.5\\n#define BIAS 0.05\\n#define SAMPLE_RAD 0.02\\n#define MAX_DISTANCE 0.07\\n\\n#define MOD3 vec3(.1031,.11369,.13787)\\n\\nfloat hash12(vec2 p)\\n{\\n\\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\nvec2 hash22(vec2 p)\\n{\\n\\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\\n    p3 += dot(p3, p3.yzx+19.19);\\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\\n}\\n\\nvec3 getPosition(vec2 uv) {\\n    float fl = textureLod(iChannel0, vec2(0.), 0.).x; \\n    float d = textureLod(iChannel0, uv, 0.).w;\\n       \\n    vec2 p = uv*2.-1.;\\n    mat3 ca = mat3(1.,0.,0.,0.,1.,0.,0.,0.,-1./1.5);\\n    vec3 rd = normalize( ca * vec3(p,fl) );\\n    \\n\\tvec3 pos = rd * d;\\n    return pos;\\n}\\n\\nvec3 getNormal(vec2 uv) {\\n    return textureLod(iChannel0, uv, 0.).xyz;\\n}\\n\\nvec2 getRandom(vec2 uv) {\\n    return normalize(hash22(uv*126.1231) * 2. - 1.);\\n}\\n\\n\\nfloat doAmbientOcclusion(in vec2 tcoord,in vec2 uv, in vec3 p, in vec3 cnorm)\\n{\\n    vec3 diff = getPosition(tcoord + uv) - p;\\n    float l = length(diff);\\n    vec3 v = diff/l;\\n    float d = l*SCALE;\\n    float ao = max(0.0,dot(cnorm,v)-BIAS)*(1.0/(1.0+d));\\n    ao *= smoothstep(MAX_DISTANCE,MAX_DISTANCE * 0.5, l);\\n    return ao;\\n\\n}\\n\\nfloat spiralAO(vec2 uv, vec3 p, vec3 n, float rad)\\n{\\n    float goldenAngle = 2.4;\\n    float ao = 0.;\\n    float inv = 1. / float(SAMPLES);\\n    float radius = 0.;\\n\\n    float rotatePhase = hash12( uv*100. ) * 6.28;\\n    float rStep = inv * rad;\\n    vec2 spiralUV;\\n\\n    for (int i = 0; i < SAMPLES; i++) {\\n        spiralUV.x = sin(rotatePhase);\\n        spiralUV.y = cos(rotatePhase);\\n        radius += rStep;\\n        ao += doAmbientOcclusion(uv, spiralUV * radius, p, n);\\n        rotatePhase += goldenAngle;\\n    }\\n    ao *= inv;\\n    return ao;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n    // letterbox\\n    if( abs(2.*fragCoord.y-iResolution.y) > iResolution.x * 0.42 ) {\\n        fragColor = vec4( 0., 0., 0., 1. );\\n        return;\\n    }\\n    \\n\\tvec2 uv = fragCoord.xy / iResolution.xy;\\n        \\n    vec3 p = getPosition(uv);\\n    vec3 n = getNormal(uv);\\n\\n    float ao = 0.;\\n    float rad = SAMPLE_RAD/p.z;\\n\\n    ao = spiralAO(uv, p, n, rad);\\n\\n    ao = 1. - ao * INTENSITY;\\n    \\n\\tfragColor = vec4(ao,ao,ao,1.);\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Reinder Nijhoff 2016\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/ls3GWS\\n//\\n//\\n// demonstrating post process Screen Space Ambient Occlusion applied to a depth and normal map\\n// with the geometry of my shader '[SIG15] Matrix Lobby Scene': \\n//\\n// https://www.shadertoy.com/view/MtsXzf\\n//\\n\\n\\n#define HIGHQUALITY 1\\n\\n#define MARCHSTEPS 120\\n\\n#define BPM             (140.0)\\n#define STEP            (4.0 * BPM / 60.0)\\n#define ISTEP           (1./STEP)\\n#define STT(t)\\t\\t\\t(t*(60.0/BPM))\\n\\nfloat damageMod;\\n\\n//-----------------------------------------------------\\n// noise functions\\n\\n#define MOD2 vec2(.16632,.17369)\\nfloat hash(float p) { // by Dave Hoskins\\n\\tvec2 p2 = fract(vec2(p) * MOD2);\\n    p2 += dot(p2.yx, p2.xy+19.19);\\n\\treturn fract(p2.x * p2.y);\\n}\\n\\nfloat noise( const in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\tf = f*f*(3.0-2.0*f);\\n\\t\\n\\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\\n\\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\\n\\treturn mix( rg.x, rg.y, f.z );\\n}\\n\\nfloat noise( const in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\\n\\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0.0 ).x;\\n}\\n\\n//-----------------------------------------------------\\n// intersection functions\\n\\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\\n    return (pos-sph.xyz)/sph.w;\\n}\\n\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n\\tvec3 oc = ro - sph.xyz;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - sph.w*sph.w;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return -1.;\\n\\treturn -b - sqrt( h );\\n}\\n\\n//----------------------------------------------------------------------\\n// distance primitives\\n\\nfloat sdBox( const in vec3 p, const in vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdColumn( const in vec3 p, const in vec2 b ) {\\n    vec2 d = abs(p.xz) - b;\\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\n//----------------------------------------------------------------------\\n// distance operators\\n\\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\\n    \\n//--------------------------------------------\\n// map\\n\\nfloat tileId( const in vec3 p, const in vec3 nor ) { \\n    if( abs(nor.y) > .9 ) return 0.;\\n    \\n    float x, y;\\n    if( abs(nor.z) < abs(nor.x)) {\\n        x = p.z-6.;\\n    } else {\\n        x = abs(p.x)-16.;\\n    }\\n    if( p.y < 2.5 ) {\\n    \\treturn floor( x / 3.6 ) * sign(p.x);\\n    }\\n    return floor( x / 1.8 ) * sign(p.x) * (floor( (p.y+7.5) / 5. ));\\n}\\n\\n\\nvec3 bumpMapNormal( const in vec3 pos, in vec3 nor ) {\\n    float i = tileId( pos, nor );\\n    if( i > 0. ) {\\n        nor+= 0.0125 * vec3( hash(i), hash(i+5.), hash(i+13.) );\\n        nor = normalize( nor );\\n    }\\n    return nor;\\n}\\n\\nfloat map( const in vec3 p ) {\\n    float d = -sdBox( p, vec3( 28., 14., 63. ) );\\n\\n    vec3 pm = vec3( abs( p.x ) - 17.8, p.y, mod( p.z, 12.6 ) - 6.);    \\n    vec3 pm2 = abs(p) - vec3( 14., 25.25, 0. );\\n    vec3 pm3 = abs(p) - vec3( 6.8, 0., 56.4 );      \\n\\n    d = opU( d, sdColumn( pm, vec2( 1.8, 1.8 ) ) );        \\n    d = opS( d, sdBox( p,  vec3( 2.5, 9.5, 74. ) ) );    \\n    d = opS( d, sdBox( p,  vec3( 5., 18., 73. ) ) );\\n    d = opS( d, sdBox( p,  vec3( 13.8, 14.88, 63. ) ) );\\n    d = opS( d, sdBox( p,  vec3( 13.2, 25., 63. ) ) );\\n    d = opS( d, sdColumn( p,  vec2( 9.5, 63. ) ) ); \\n    d = opU( d, sdColumn( pm3, vec2( 1.8, 1.8 ) ) );\\n    d = opU( d, sdBox( pm2, vec3( 5., .45, 200. ) ) );\\n    \\n    return d;\\n}\\n\\nfloat mapDamage( vec3 p ) {\\n    float d = map( p );\\n\\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\\n                   noise( p*.3 )* (noise( p*2.3 ) +.2 )-.2 - damageMod, 0.);\\n   \\n\\treturn d + n;\\n}\\n\\nfloat mapDamageHigh( vec3 p ) {\\n    float d = map( p );\\n    \\n    float p1 = noise( p*2.3 );\\n    float p2 = noise( p*5.3 );\\n    \\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\\n                   noise( p*.3 )* (p1 +.2 )-.2 - damageMod, 0.);\\n    \\n    if( p.y < .1 ) {\\n        n += max(.1*(1.-abs(d)+7.*noise( p*.7 )+.9*p1+.5*p2)-4.5*damageMod,0.);\\n    }\\n    \\n    if( abs(n) > 0.0 ) {\\n        n += noise( p*11.) * .05;\\n        n += noise( p*23.) * .03;\\n    }\\n    \\n\\treturn d + n;\\n}\\n\\n\\nvec3 calcNormalDamage( in vec3 pos, in float eps ) {\\n    if( pos.y < 0.001 && (mapDamageHigh(pos)-map(pos)) < eps ) {   \\t\\t\\n\\t        return vec3( 0., 1., 0. );\\n    }\\n    \\n    vec2 e = vec2(1.0,-1.0)*(0.5773*eps);\\n    vec3 n =  normalize( e.xyy*mapDamageHigh( pos + e.xyy ) + \\n\\t\\t\\t     \\t\\t e.yyx*mapDamageHigh( pos + e.yyx ) + \\n\\t\\t\\t\\t\\t  \\t e.yxy*mapDamageHigh( pos + e.yxy ) + \\n\\t\\t\\t\\t\\t  \\t e.xxx*mapDamageHigh( pos + e.xxx ) );\\n    n = bumpMapNormal( pos, n );\\n    return n;    \\n}\\n\\n//----------------------------------------------------------------------\\n// intersection code\\n\\nfloat intersect( in vec3 ro, in vec3 rd ) {\\n\\tconst float precis = 0.00125;\\n    float h = precis*2.0;\\n    float t = 0.1;\\n        \\n    float d = -(ro.y)/rd.y;\\n    float maxdist = d>0.?d:500.;\\n    \\n\\tfor( int i=0; i < MARCHSTEPS; i++ ) {\\n#if HIGHQUALITY\\n        h = .8*mapDamage( ro+rd*t );\\n#else\\n        h = map( ro+rd*t );\\n#endif\\n        if( abs(h) < precis ) {\\n            return t;\\n        } \\n        t += h;\\n        if( t > maxdist ) {\\n            return maxdist;\\n        }\\n    }\\n    return -1.;\\n}\\n\\n\\nvec4 render( const in vec3 ro, const in vec3 rd, in float time, const in float fog, const in vec3 grd ) {\\n    const float eps = 0.01;\\n    vec2 col = vec2(0.);\\n    \\n    float t = intersect( ro, rd );\\n    if( time > STT(98.) ) {\\n        time = STT(95.5)+.4*(time-STT(95.5)); // slow motion\\n    }\\n    time += .03*hash( rd.x + rd.y*5341.1231 ); // motionblur\\n    \\n    vec3 nor;\\n    \\n    if( t > 0. ) {\\n        float m = 0.;\\n   \\n        vec3 pos = ro + t*rd;\\n        if( m < .5 ) {\\n\\t        nor = calcNormalDamage( pos, eps );\\n        }\\n    } else {\\n        t = 60.;\\n    }        \\n    return vec4(nor, max(t/60.,0.));\\n}\\n\\n//----------------------------------------------------------------------\\n// camera\\n\\nmat3 setCamera( const in vec3 ro, const in vec3 rt, const in float cr, const in float fl ) {\\n\\tvec3 cw = normalize(rt-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, -fl*cw );\\n}\\n\\n#define SCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){damageMod=j;sro=b;ero=c;sta=d;eta=e;st=t;dt=a;sfog=h;efog=i;}t+=a;\\n#define CCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){sro=ero;ero=c;sta=eta;eta=e;st=t;dt=a;sfog=efog;efog=i;}t+=a;\\n\\nvoid getCamPath( const in float time, inout vec3 ro, inout vec3 ta, inout float fl, inout float fog ) {\\n    vec3 sro, sta, ero, eta;\\n    float st = 0., dt, t = 0., sfog, efog;\\n    \\n    SCAM(STT(12.), 0., 0.,    0., 1.5, 1.5, vec3( 0., 5., 22.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \\n    SCAM(STT(7.5), 0., 0.,    0., 1.5, 1.5, vec3( -14., 5.,  18.5 ), vec3( 18., 4., 11. ), vec3( 10., 5., -50. ), vec3( 0., 5., -50. ) ); \\n    CCAM(STT(7.5), 0., 0.,  0.05, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 21.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \\n    CCAM(STT(2.5), 0., 0.05, 0.1, 1.5, 1.5, vec3( 21.5, 4., 11.5 ), vec3( 21.5, 4., 11.5 ),  vec3( -4., 7., 0. ), vec3( -16., 7., 8. ) ); \\n    CCAM(STT(4.), 0.,  0.1, 0.15, 1.5, 4.5, vec3( 21.5, 4., 11.5 ), vec3( 10., 4.25, 11.35 ),  vec3( -16., 7., 8. ), vec3( -16., 6., 8. ) ); \\n    \\n    SCAM(STT(7.5),  0., 0.1,  0.3, 1.5, 1.5, vec3( -11., 5.25, 7.05 ), vec3( -13., 5., 9. ),  vec3( -19., 5.2, 7. ), vec3( -16.5, 5., 5.3 ) );     \\n    SCAM(STT(13.), .4, 0.1,  0.5, 1.5, 1.5, vec3( -18., 5., 4.05 ), vec3( -10., 5.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 5.25, -7.3 ) );     \\n\\tCCAM(STT(4.), .45, 0.5,  0.65, 1.5, 1.2, vec3( -10., 5.25, -6. ), vec3( -12., 5.25, -9. ),  vec3( -15.5, 5.25, -7.3 ), vec3( -13.5, 6.25, 2.3 ) );     \\n\\n    SCAM(STT(7.5), .95, 0.4,  1.9, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 25.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \\n\\n    SCAM(STT(12.2), .95, 0.8,  1.3, 1.5, 1.5, vec3( 10., 4.7, 4. ), vec3( 10., 5., -7.5 ),  vec3( 50., 5., 2. ), vec3( 40., 5., -20. ) ); \\n    \\n    SCAM(STT(16.25), 1., 0.4,  0.8, 1.5, 1.5, vec3( -18., 4.5, 4.05 ), vec3( -26., 3.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 6.25, -7.3 ) );     \\n    CCAM(STT(4.),  1., 0.8,  0.6, 1.5, 1.5, vec3( -26., 3.25, -6. ), vec3( -26., 3.25, -6. ),  vec3( -15.5, 6.25, -7.3 ), vec3( -15.5, 6.25, -7.3 ) );     \\n\\n    SCAM(STT(16.), 1.1, 0.4, 0.05, 1.5, 1.5, vec3( 0., 5.,  18.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \\n  \\n    dt = clamp( (time-st)/dt, 0., 1. );\\n\\n    if(  time > STT(65.5) && time < STT(77.75)  ) {\\n\\t    ro = mix( sro, ero, dt);\\n    \\tta = mix( sta, eta, dt);\\n    } else {\\n\\t    ro = mix( sro, ero, smoothstep(0.,1., dt));\\n    \\tta = mix( sta, eta, smoothstep(0.,1., dt));\\n    }\\n\\t\\n    fl = 1.5;    \\n    if( time > STT(29.5) && time < STT(33.5) ) {\\n        fl = mix( 1.5, 4.5, smoothstep( STT(29.5), STT(33.5), time ) );\\n    }\\n    \\n   \\tfog = mix( sfog, efog, dt);\\n    damageMod = .4-.4*damageMod;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    float time = mod(iTime, 60.);\\n\\n    vec2 q = fragCoord.xy/iResolution.xy;\\n\\t \\n    vec3 ro, ta;\\n    float fl, fog;\\n      \\n    getCamPath( time, ro, ta, fl, fog );\\n    \\n    if( dot(fragCoord.xy, fragCoord.xy) < 10. ) {\\n\\t   fragColor = vec4( fl );\\n       return;\\n    }\\n        \\n    mat3 ca = setCamera( ro, ta, 0.0, (1./1.5) );    \\n    vec2 p = (-iResolution.xy+2.*(fragCoord.xy))/iResolution.x;\\n    vec3 rd = normalize( ca * vec3(p,-fl) );\\n\\n    vec4 r = render( ro, rd, time, fog, normalize( ta-ro ) ); \\n    fragColor = vec4( ((r.xyz * ca)).xyz,  r.w );\\n}\\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MstSD8","date":"1459155443","viewed":2042,"name":"Matrix Lobby Scene (MP)","description":"This is my Sig15 shader [url=https://www.shadertoy.com/view/MtsXzf][SIG15] Matrix Lobby Scene[/url]. I don't know why, but the original shader keeps crashing webgl on some windows machines. Therefore I made this version which uses multiple passes.","likes":23,"published":"Public API","usePreview":0,"tags":["matrix","scene","sig15","lobby"]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original shader. Instead of calculating the first intersection, depth is sampled from buffer A.\\n\\n// Created by Reinder Nijhoff 2015\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtsXzf\\n//\\n\\nfloat damageMod;\\nvec4 ep1, ep2, ep3, ep4, ep5;  \\n\\n//-----------------------------------------------------\\n// noise functions\\n\\n#define MOD2 vec2(.16632,.17369)\\nfloat hash(float p) { // by Dave Hoskins\\n\\tvec2 p2 = fract(vec2(p) * MOD2);\\n    p2 += dot(p2.yx, p2.xy+19.19);\\n\\treturn fract(p2.x * p2.y);\\n}\\n\\nfloat noise( const in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\tf = f*f*(3.0-2.0*f);\\n\\t\\n\\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\\n\\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\\n\\treturn mix( rg.x, rg.y, f.z );\\n}\\n\\nfloat noise( const in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\\n\\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\\n}\\n\\n//-----------------------------------------------------\\n// intersection functions\\n\\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\\n    return (pos-sph.xyz)/sph.w;\\n}\\n\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n\\tvec3 oc = ro - sph.xyz;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - sph.w*sph.w;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return -1.;\\n\\treturn -b - sqrt( h );\\n}\\n\\n//----------------------------------------------------------------------\\n// distance primitives\\n\\nfloat sdBox( const in vec3 p, const in vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdColumn( const in vec3 p, const in vec2 b ) {\\n    vec2 d = abs(p.xz) - b;\\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\n//----------------------------------------------------------------------\\n// distance operators\\n\\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\\n    \\n//--------------------------------------------\\n// map\\n\\nfloat tileId( const in vec3 p, const in vec3 nor ) { \\n    if( abs(nor.y) > .9 ) return 0.;\\n    \\n    float x, y;\\n    if( abs(nor.z) < abs(nor.x)) {\\n        x = p.z-6.;\\n    } else {\\n        x = abs(p.x)-16.;\\n    }\\n    if( p.y < 2.5 ) {\\n    \\treturn floor( x / 3.6 ) * sign(p.x);\\n    }\\n    return floor( x / 1.8 ) * sign(p.x) * (floor( (p.y+7.5) / 5. ));\\n}\\n\\n\\nvec3 bumpMapNormal( const in vec3 pos, in vec3 nor ) {\\n    float i = tileId( pos, nor );\\n    if( i > 0. ) {\\n        nor+= 0.0125 * vec3( hash(i), hash(i+5.), hash(i+13.) );\\n        nor = normalize( nor );\\n    }\\n    return nor;\\n}\\n\\nfloat map( const in vec3 p ) {\\n    float d = -sdBox( p, vec3( 28., 14., 63. ) );\\n\\n    vec3 pm = vec3( abs( p.x ) - 17.8, p.y, mod( p.z, 12.6 ) - 6.);    \\n    vec3 pm2 = abs(p) - vec3( 14., 25.25, 0. );\\n    vec3 pm3 = abs(p) - vec3( 6.8, 0., 56.4 );      \\n\\n    d = opU( d, sdColumn( pm, vec2( 1.8, 1.8 ) ) );        \\n    d = opS( d, sdBox( p,  vec3( 2.5, 9.5, 74. ) ) );    \\n    d = opS( d, sdBox( p,  vec3( 5., 18., 73. ) ) );\\n    d = opS( d, sdBox( p,  vec3( 13.8, 14.88, 63. ) ) );\\n    d = opS( d, sdBox( p,  vec3( 13.2, 25., 63. ) ) );\\n    d = opS( d, sdColumn( p,  vec2( 9.5, 63. ) ) ); \\n    d = opU( d, sdColumn( pm3, vec2( 1.8, 1.8 ) ) );\\n    d = opU( d, sdBox( pm2, vec3( 5., .45, 200. ) ) );\\n    \\n    return d;\\n}\\n\\nfloat mapDamage( vec3 p ) {\\n    float d = map( p );\\n\\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\\n                   noise( p*.3 )* (noise( p*2.3 ) +.2 )-.2 - damageMod, 0.);\\n   \\n\\treturn d + n;\\n}\\n\\nfloat mapDamageHigh( vec3 p ) {\\n    float d = map( p );\\n    \\n    float p1 = noise( p*2.3 );\\n    float p2 = noise( p*5.3 );\\n    \\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\\n                   noise( p*.3 )* (p1 +.2 )-.2 - damageMod, 0.);\\n  \\n    float ne = 0.;\\n    ne += smoothstep( -0.7, 0., -distance( p, ep1.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep2.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep3.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep4.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep5.xyz ) );\\n    \\n    n += .5 * max((ne - p2 ),0.) * ne;\\n  \\n    if( p.y < .1 ) {\\n        n += max(.1*(1.-abs(d)+7.*noise( p*.7 )+.9*p1+.5*p2)-4.5*damageMod,0.);\\n    }\\n    \\n    if( abs(n) > 0.0 ) {\\n        n += noise( p*11.) * .05;\\n        n += noise( p*23.) * .03;\\n    }\\n    \\n\\treturn d + n;\\n}\\n\\n\\nvec3 calcNormalDamage( in vec3 pos, in float eps ) {\\n    if( pos.y < 0.001 && (mapDamageHigh(pos)-map(pos)) < eps ) {   \\t\\t\\n\\t        return vec3( 0., 1., 0. );\\n    }\\n    \\n    vec2 e = vec2(1.0,-1.0)*(0.5773*eps);\\n    vec3 n =  normalize( e.xyy*mapDamageHigh( pos + e.xyy ) + \\n\\t\\t\\t     \\t\\t e.yyx*mapDamageHigh( pos + e.yyx ) + \\n\\t\\t\\t\\t\\t  \\t e.yxy*mapDamageHigh( pos + e.yxy ) + \\n\\t\\t\\t\\t\\t  \\t e.xxx*mapDamageHigh( pos + e.xxx ) );\\n    n = bumpMapNormal( pos, n );\\n    return n;    \\n}\\n\\n//----------------------------------------------------------------------\\n// lighting\\n\\nfloat calcAO( in vec3 pos, in vec3 nor ) {\\n\\tfloat occ = 0.0;\\n    for( int i=0; i<6; i++ ) {\\n        float h = 0.1 + 1.2*float(i);\\n        occ += (h-map( pos + h*nor ));\\n    }\\n    return clamp( 1.0 - occ*0.025, 0.0, 1.0 );    \\n}\\n\\nfloat calcFakeAOAndShadow( in vec3 pos ) { \\n    float r = (1.-abs(pos.x)/30.5);\\n    \\n    r *= max( min( .35-pos.z / 40., 1.), 0.65);\\n    r *= .5+.5*smoothstep( -66., -.65, pos.z);\\n    \\n    if( pos.y < 25. ) r *= 1.-smoothstep( 18., 25., .5*pos.y+abs(pos.x) ) * (.6+pos.y/25.);\\n    r *= 1.-smoothstep(5., 8., abs(pos.x) ) * .75 * (smoothstep( 60.,63.,abs(pos.z)));\\n    \\n    return clamp(r, 0., 1.);\\n}\\n\\n//----------------------------------------------------------------------\\n// materials\\n\\nfloat matMarble( in vec3 pos, in vec3 nor ) {\\n    float i = tileId( pos, nor );\\n    \\n    return .072*(hash(i)+noise(pos*7.))+.12*noise(pos*25.);\\n}\\n\\nfloat matSideLamp( in vec3 pos, in vec3 nor ) {\\n    float l = (1.-smoothstep(0.05,0.15, abs( pos.y-13.75 ) ))\\n        \\t* (1.-smoothstep(1.5,1.7, abs( mod(pos.z, 3.6)-1.8 ) ));\\n    return 5. * l;\\n}\\n\\nfloat matOutdoorLight( in vec3 pos, in vec3 nor ) {\\n    float l = ( smoothstep( 0.03, 0.1, abs( mod( pos.x, 1.8 ) / 1.8 - .5) ))\\n\\t\\t\\t* ( smoothstep( 0.03, 0.1, abs( mod( pos.y, 3.6 ) / 3.6 - .5) ));\\n    return mix( 8.,12., l);\\n}\\n\\nvec2 shade( in vec3 pos, in vec3 nor, in float m, in float t, in bool reflection ) {\\n    float refl = 0.1;\\n    float mate = 0.;\\n \\tfloat light = 0.;            \\n    float col = 0.;\\n    \\n    if( m < .5 ) {\\n   \\t\\tif( pos.y < .01 ) {\\n\\t    \\tmate = .05 * (.25+.2*texture( iChannel1, pos.xz*.05 ).r);\\n            float x = abs(pos.x);\\n            if( (x > 12. && x < 14.8) ||  (x > 3.2 && x < 6.8) || abs(pos.z) > 68.4 ) mate *= 0.25;\\n        } else if( pos.y > 13.5 && pos.y < 13.99 && abs( pos.x ) > 27.99 ) {\\n            light = matSideLamp( pos, nor ); \\n        } else if( pos.z > 62. && pos.y > 52. ) {\\n            light = matOutdoorLight( pos, nor );\\n        } else {\\n \\t\\t\\tmate = matMarble( pos, nor );\\n            refl = 0.05;\\n   \\t\\t}\\n        if( abs(mapDamageHigh(pos)-map(pos)) > 0.0001 * t ) {\\n            refl = 0.;\\n            mate = 0.21;\\n        }\\n        if( abs( pos.z ) > 73.1 ) {\\n            mate = 0.02;\\n            if( mod( abs( pos.x ), 2.25 ) < .3 ||\\n            \\tmod( abs( pos.y ), 2.25 ) < .3 ) mate = 0.0025;\\n            refl = 0.02;\\n        }\\n            \\n        if( nor.y < -0.8 && pos.y > 13.49 ) {\\n            col += mate * (0.4 * pow( max( (abs(pos.x*.38)-7.2),0.), 2.));\\n        }        \\n    } \\n#if RENDERDEBRIS\\n    else if( m < 1.5 ) {\\n            refl = 0.;\\n            mate = 0.1 * noise(pos);\\n    }\\n#endif\\n    \\n    col += mate * (\\n        25. * ( 0.02 +\\n        .2 * min(1., max( -nor.x * sign(pos.x), 0.)) + \\n        .5 * min(1., max( nor.y, 0. )) +\\n        .05 * abs( nor.z ) ) * calcFakeAOAndShadow( pos ) );\\n    \\n    col *= calcAO( pos, nor );\\n    col += light;\\n    \\n    return vec2( col, refl );\\n}\\n\\n//----------------------------------------------------------------------\\n// intersection code\\n\\nfloat intersect( in vec3 ro, in vec3 rd, in vec2 uv ) {\\n    vec4 dist = textureLod(iChannel3, uv, 0.);\\n\\treturn dist.r + dist.g;\\n}\\n\\n\\nfloat intersectReflection( in vec3 ro, in vec3 rd ) {\\n\\tconst float precis = 0.00125;\\n    float h = precis*2.0;\\n    float t = 0.;\\n        \\n    float d = -(ro.y)/rd.y;\\n    float maxdist = d>0.?d:500.;\\n    \\n\\tfor( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\\n        h = map( ro+rd*t );\\n        if( h < precis ) {\\n            return t;\\n        } \\n        t += h+0.01*t;\\n        if( t > maxdist ) {\\n            return maxdist;\\n        }\\n    }\\n    return -1.;\\n}\\n\\n//----------------------------------------------------------------------\\n// render functions\\n\\nfloat renderExplosionDebris( const in vec3 ro, const in vec3 rd, in float maxdist, const in vec4 ep, inout vec3 nor, \\n                             const in float time ) {\\n    float maxRadius = 30.*(time - ep.w - .025);\\n    float minRadius = 0.2 * maxRadius;\\n    if( maxRadius > 30. ) return maxdist;\\n    \\n    for( int i=0; i<DEBRISCOUNT; i++ ) {\\n        float id = hash(  ep.w+float(i) );\\n        vec3 dir = normalize( -1.+2.*vec3( id, hash(  ep.w+.5*float(i) ), hash(  ep.w+1.5*float(i) ) ) - vec3( 2.*sign(ep.x), 0., 0.) );\\n        vec3 pos = ep.xyz + dir*mix( minRadius, maxRadius, id ) + vec3(0.,-maxRadius*sin( maxRadius*0.005 ),0.);\\n        float d = iSphere( ro, rd, vec4( pos, 0.1*id+0.003 ) );\\n        if( d > 0. && d < maxdist ) {\\n            maxdist = d;\\n            nor = nSphere( ro+rd*d, vec4( pos, 0.1*id+0.003 ) );\\n        }\\n    }\\n    \\n    return maxdist;\\n}\\n\\nvoid renderExplosionDust( const in vec3 ro, const in vec3 rd, in float dist, const in vec4 ep, inout vec2 col, \\n                          const in float time, const in vec3 grd ) {\\n    float maxRadius = 10.*(time - ep.w + .25);\\n    if( maxRadius > 40. ) return ;\\n    \\n    float dens = 0.;\\n    float ho = hash( ep.w ); // id of explosion\\n    float fade = pow( 2., -maxRadius*0.11-2.);\\n    float zoom = 2.5/maxRadius;\\n    vec2 down = vec2(sin(maxRadius*0.005+.1), 0.);\\n                     \\n\\t// intersect planes\\n    vec2 d = -(ro.xz - ep.xz )/rd.xz;\\n    if( d.x > 0. ) {\\n        vec3 pos = ro+d.x*rd;\\n        float radius = distance( ep.yz, pos.yz );\\n        if( radius < maxRadius  ) {\\n            float l = max( 0.025*(dist-d.x) + .5, 0. ) \\n                        \\t\\t\\t* fade \\n                      \\t\\t\\t\\t* abs( grd.x )\\n                     \\t\\t\\t\\t* (1.-smoothstep( 0.8*maxRadius, maxRadius, radius ));            \\n\\t        float excol = mix( col.x, 1., pow( max(1.-2.*texture( iChannel2,ho+(pos.yz-ep.yz)*zoom + down, -100.0 ).x,0.),3.) );               \\n    \\t    col.x = mix( col.x, excol, l);\\n            col.y += l;\\n        }\\n    }\\n    \\n    if( d.y > 0. ) {\\n        vec3 pos = ro+d.y*rd;\\n        float radius = distance( ep.yx, pos.yx );\\n        if( radius < maxRadius  ) {\\n            float l = max( 0.025*(dist-d.y) + .5, 0. ) \\n                        \\t\\t\\t* fade \\n                      \\t\\t\\t\\t* abs( grd.z )\\n                     \\t\\t\\t\\t* (1.-smoothstep( 0.8*maxRadius, maxRadius, radius ));\\n\\t        float excol = mix( col.x, 1., pow( max(1.-2.*texture( iChannel2,ho+(pos.yx-ep.yx)*zoom + down, -100.0 ).x,0.),3.) );   \\n    \\t    col.x = mix( col.x, excol, l);\\n            col.y += l;\\n        }\\n    }\\n}\\n\\nvec3 render( const in vec3 ro, const in vec3 rd, in float time, const in float fog, const in vec3 grd, in vec2 uv ) {\\n    const float eps = 0.01;\\n    vec2 col = vec2(0.);\\n    \\n    float t = intersect( ro, rd, uv );\\n    if( time > STT(98.) ) {\\n        time = STT(95.5)+.4*(time-STT(95.5)); // slow motion\\n    }\\n    time += .03*hash( rd.x + rd.y*5341.1231 ); // motionblur\\n    \\n    if( t > 0. ) {\\n        vec3 nor;\\n        float m = 0.;\\n\\n#if RENDERDEBRIS\\n        float d = renderExplosionDebris( ro, rd, t, ep1, nor, time );\\n        d = renderExplosionDebris( ro, rd, d, ep3, nor, time );\\n        d = renderExplosionDebris( ro, rd, d, ep5, nor, time );\\n#if HIGHQUALITY \\n        d = renderExplosionDebris( ro, rd, d, ep2, nor, time );\\n        d = renderExplosionDebris( ro, rd, d, ep4, nor, time );\\n#endif\\n        if( d < t ) {\\n            m = 1.;\\n            t = d;\\n        } \\n#endif\\n   \\n        vec3 pos = ro + t*rd;\\n        if( m < .5 ) {\\n\\t        nor = calcNormalDamage( pos, eps );\\n        }\\n        col = shade( pos, nor, m, t, false );\\n\\n#if REFLECTIONS        \\n        vec3 rdReflect = reflect( rd, -nor );\\n        float tReflect = intersectReflection( pos + eps*rdReflect, rdReflect );\\n\\n        if( tReflect >= 0. && col.y > 0. ) {\\n            vec3 posReflect = pos + tReflect*rdReflect;\\n            vec3 norReflect = calcNormalDamage( posReflect, eps );\\n\\n            col += shade( posReflect, norReflect, 0., tReflect, true ) * col.y;\\n        }\\n#endif\\n    } else {\\n        t = 60.;\\n    }\\n\\n    col.y = 0.; \\n    renderExplosionDust( ro, rd, t, ep1, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep2, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep3, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep4, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep5, col, time, grd );\\n    \\n // add fog\\n    vec3 dcol = vec3( max(col.x,0.) );\\n \\tdcol = mix( vec3(.5), dcol, exp( -t*(.02*fog+.005*col.y) ) );\\n        \\n    return pow( dcol, vec3(0.45) );\\n}\\n\\n//----------------------------------------------------------------------\\n// explosions\\n\\n#define E1(a,b,c,d) t+=a;if( time >= t ){ep1 = vec4(b,c,d,t);}\\n#define E2(a,b,c,d) t+=a;if( time >= t ){ep2 = vec4(b,c,d,t);}\\n#define E3(a,b,c,d) t+=a;if( time >= t ){ep3 = vec4(b,c,d,t);}\\n#define E4(a,b,c,d) t+=a;if( time >= t ){ep4 = vec4(b,c,d,t);}\\n#define E5(a,b,c,d) t+=a;if( time >= t ){ep5 = vec4(b,c,d,t);}\\n\\nvoid initExplosions( const in float time ) {\\n\\tep1 = ep2 = ep3 = ep4 = ep5 = vec4(-1000.);\\n    \\n    float t = 0.;    \\n    E1(STT(21.), 16., 3.9, 8.2 );\\n    E2(.7, 16., 5.4, 6.1 );\\n    E3(.3, 16., 6.3, 7.7 );\\n    E4(1., 16., 4.8, 8.2 );\\n    E5(.7, 16., 5.7, 7.3 );\\n    \\n    t = 0.;\\n    E1(STT(34.), -16., 3.9, 5.2 );\\n    E2(.5, -16., 5.4, 5.1 );\\n    E3(.7, -16., 6.3, 6.7 );\\n    E4(.5, -16., 4.8, 7.2 );\\n    E5(.4, -16., 5.7, 6.3 );\\n        \\n    t = 0.;\\n    E1(STT(42.), -19.1, 3.9, -4.5 );\\n    E2(1.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E1(.9, -16., 3.9, -5.2 );\\n    E2(.5, -16., 5.4, -5.1 );\\n    E3(.3, -16., 6.3, -6.7 );\\n    E4(.5, -16., 4.8, -7.2 );\\n    E5(.4, -16., 5.7, -6.3 );    \\n    \\n    t = 0.;    \\n    E1(STT(58.), 16., 3.9, 2.2 );\\n    E2(.2, 16., 5.4, 4.1 );\\n    E3(.3, 24., 6.3, 3.7 );\\n    E4(.5, 16., 4.8, 8.2 );\\n    E5(.7, 24., 5.7, 4.3 );\\n    E1(.1, 16., 1.9, 8.2 );\\n    E2(.2, 24., 5.4, -2.1 );\\n    \\n    t = 0.;\\n    E1(STT(66.), 16., 3.9, 6.5 );\\n    E2(.2, 16., 5.4, 6.1 );\\n    E5(.3, 16., 6.7, 7.3 );\\n    E3(.3, 16., 6.3, 5.7 );\\n    E4(.2, 16., 7.8, 6.2 );\\n        \\n    E5(.1, 16., 5.7, 4.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 17., 6.4, -4.5 );\\n    E3(.3, 16., 6.3, -5.7 );\\n    E4(.5, 16., 7.8, -6.2 );    \\n    E5(.3, 16., 5.7, -7.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 16., 6.4, -4.5 );\\n   \\n    t = 0.;\\n    E1(STT(78.), -17.1, 3.9, -4.5 );\\n    E2(.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(1.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E2(.5, -19.6, 5.4, -5.1 );\\n    E1(.9, -19.6, 3.9, -5.2 );\\n    E3(.3, -19.6, 6.3, -6.7 );\\n    E4(.5, -19.6, 4.8, -7.2 );\\n    E5(.4, -19.6, 5.7, -6.3 );\\n}\\n\\n//----------------------------------------------------------------------\\n// camera\\n\\nmat3 setCamera( const in vec3 ro, const in vec3 rt, const in float cr, const in float fl ) {\\n\\tvec3 cw = normalize(rt-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, -fl*cw );\\n}\\n\\n#define SCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){damageMod=j;sro=b;ero=c;sta=d;eta=e;st=t;dt=a;sfog=h;efog=i;}t+=a;\\n#define CCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){sro=ero;ero=c;sta=eta;eta=e;st=t;dt=a;sfog=efog;efog=i;}t+=a;\\n\\nvoid getCamPath( const in float time, inout vec3 ro, inout vec3 ta, inout float fl, inout float fog ) {\\n    vec3 sro, sta, ero, eta;\\n    float st = 0., dt, t = 0., sfog, efog;\\n    \\n    SCAM(STT(12.), 0., 0.,    0., 1.5, 1.5, vec3( 0., 5., 22.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \\n    SCAM(STT(7.5), 0., 0.,    0., 1.5, 1.5, vec3( -14., 5.,  18.5 ), vec3( 18., 4., 11. ), vec3( 10., 5., -50. ), vec3( 0., 5., -50. ) ); \\n    CCAM(STT(7.5), 0., 0.,  0.05, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 21.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \\n    CCAM(STT(2.5), 0., 0.05, 0.1, 1.5, 1.5, vec3( 21.5, 4., 11.5 ), vec3( 21.5, 4., 11.5 ),  vec3( -4., 7., 0. ), vec3( -16., 7., 8. ) ); \\n    CCAM(STT(4.), 0.,  0.1, 0.15, 1.5, 4.5, vec3( 21.5, 4., 11.5 ), vec3( 10., 4.25, 11.35 ),  vec3( -16., 7., 8. ), vec3( -16., 6., 8. ) ); \\n    \\n    SCAM(STT(7.5),  0., 0.1,  0.3, 1.5, 1.5, vec3( -11., 5.25, 7.05 ), vec3( -13., 5., 9. ),  vec3( -19., 5.2, 7. ), vec3( -16.5, 5., 5.3 ) );     \\n    SCAM(STT(13.), .4, 0.1,  0.5, 1.5, 1.5, vec3( -18., 5., 4.05 ), vec3( -10., 5.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 5.25, -7.3 ) );     \\n\\tCCAM(STT(4.), .45, 0.5,  0.65, 1.5, 1.2, vec3( -10., 5.25, -6. ), vec3( -12., 5.25, -9. ),  vec3( -15.5, 5.25, -7.3 ), vec3( -13.5, 6.25, 2.3 ) );     \\n\\n    SCAM(STT(7.5), .95, 0.4,  1.9, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 25.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \\n\\n    SCAM(STT(12.2), .95, 0.8,  1.3, 1.5, 1.5, vec3( 10., 4.7, 4. ), vec3( 10., 5., -7.5 ),  vec3( 50., 5., 2. ), vec3( 40., 5., -20. ) ); \\n    \\n    SCAM(STT(16.25), 1., 0.4,  0.8, 1.5, 1.5, vec3( -18., 4.5, 4.05 ), vec3( -26., 3.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 6.25, -7.3 ) );     \\n    CCAM(STT(4.),  1., 0.8,  0.6, 1.5, 1.5, vec3( -26., 3.25, -6. ), vec3( -26., 3.25, -6. ),  vec3( -15.5, 6.25, -7.3 ), vec3( -15.5, 6.25, -7.3 ) );     \\n\\n    SCAM(STT(16.), 1.1, 0.4, 0.05, 1.5, 1.5, vec3( 0., 5.,  18.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \\n  \\n    dt = clamp( (time-st)/dt, 0., 1. );\\n\\n    if(  time > STT(65.5) && time < STT(77.75)  ) {\\n\\t    ro = mix( sro, ero, dt);\\n    \\tta = mix( sta, eta, dt);\\n    } else {\\n\\t    ro = mix( sro, ero, smoothstep(0.,1., dt));\\n    \\tta = mix( sta, eta, smoothstep(0.,1., dt));\\n    }\\n\\t\\n    fl = 1.5;    \\n    if( time > STT(29.5) && time < STT(33.5) ) {\\n        fl = mix( 1.5, 4.5, smoothstep( STT(29.5), STT(33.5), time ) );\\n    }\\n    \\n   \\tfog = mix( sfog, efog, dt);\\n    damageMod = .4-.4*damageMod;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    float time = mod(iTime, 60.);\\n\\n    vec2 q = fragCoord.xy/iResolution.xy;\\n\\t    \\n    // letterbox\\n    if( abs(2.*fragCoord.y-iResolution.y) > iResolution.x * 0.42 ) {\\n        fragColor = vec4( 0., 0., 0., 1. );\\n        return;\\n    }\\n    vec3 ro, ta;\\n    float fl, fog;\\n      \\n    getCamPath( time, ro, ta, fl, fog );\\n        \\n    initExplosions( time );\\n    \\n    mat3 ca = setCamera( ro, ta, 0.0, (1./1.5) );    \\n    vec2 p = (-iResolution.xy+2.*(fragCoord.xy))/iResolution.x;\\n    vec3 rd = normalize( ca * vec3(p,-fl) );\\n\\n    vec3 col = render( ro, rd, time, fog, normalize( ta-ro ), q );\\n    \\n    col *= vec3(0.704,0.778,0.704);    \\n\\tcol = col*0.8 + 0.2*col*col*(3.0-2.0*col);\\n\\tcol *= vec3(1.378,1.56,1.3);\\n        \\n    // vignette\\n    col *= 0.15 + 0.85*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\\n\\n    // flicker\\n    col *= 1.0 + 0.015*fract( 17.1*sin( 13.1*floor(12.0*iTime) ));\\n    \\n\\t// fade in\\n    col *= clamp( time*.7, 0., 1. );\\n    col *= clamp( abs(time-STT(12.)), 0., 1. );\\n    if( time < STT(33.5) ) col *= clamp( (STT(33.5)-time-.5), 0., 1. );\\n    col *= clamp( abs(time-STT(98.)), 0., 1. );\\n    \\n    fragColor = vec4( col, 1.0 );\\n}\\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Only calculate depth of first intersection and write to Buffer A\\n\\n// Created by Reinder Nijhoff 2015\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtsXzf\\n//\\n\\nfloat damageMod;\\nvec4 ep1, ep2, ep3, ep4, ep5;  \\n\\n//-----------------------------------------------------\\n// noise functions\\n\\n#define MOD2 vec2(.16632,.17369)\\nfloat hash(float p) { // by Dave Hoskins\\n\\tvec2 p2 = fract(vec2(p) * MOD2);\\n    p2 += dot(p2.yx, p2.xy+19.19);\\n\\treturn fract(p2.x * p2.y);\\n}\\n\\nfloat noise( const in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\tf = f*f*(3.0-2.0*f);\\n\\t\\n\\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\\n\\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\\n\\treturn mix( rg.x, rg.y, f.z );\\n}\\n\\nfloat noise( const in vec2 x ) {\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\\n\\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0.0 ).x;\\n}\\n\\n//-----------------------------------------------------\\n// intersection functions\\n\\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\\n    return (pos-sph.xyz)/sph.w;\\n}\\n\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n\\tvec3 oc = ro - sph.xyz;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - sph.w*sph.w;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return -1.;\\n\\treturn -b - sqrt( h );\\n}\\n\\n//----------------------------------------------------------------------\\n// distance primitives\\n\\nfloat sdBox( const in vec3 p, const in vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdColumn( const in vec3 p, const in vec2 b ) {\\n    vec2 d = abs(p.xz) - b;\\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\n//----------------------------------------------------------------------\\n// distance operators\\n\\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\\n    \\n//--------------------------------------------\\n// map\\n\\nfloat tileId( const in vec3 p, const in vec3 nor ) { \\n    if( abs(nor.y) > .9 ) return 0.;\\n    \\n    float x, y;\\n    if( abs(nor.z) < abs(nor.x)) {\\n        x = p.z-6.;\\n    } else {\\n        x = abs(p.x)-16.;\\n    }\\n    if( p.y < 2.5 ) {\\n    \\treturn floor( x / 3.6 ) * sign(p.x);\\n    }\\n    return floor( x / 1.8 ) * sign(p.x) * (floor( (p.y+7.5) / 5. ));\\n}\\n\\n\\nvec3 bumpMapNormal( const in vec3 pos, in vec3 nor ) {\\n    float i = tileId( pos, nor );\\n    if( i > 0. ) {\\n        nor+= 0.0125 * vec3( hash(i), hash(i+5.), hash(i+13.) );\\n        nor = normalize( nor );\\n    }\\n    return nor;\\n}\\n\\nfloat map( const in vec3 p ) {\\n    float d = -sdBox( p, vec3( 28., 14., 63. ) );\\n\\n    vec3 pm = vec3( abs( p.x ) - 17.8, p.y, mod( p.z, 12.6 ) - 6.);    \\n    vec3 pm2 = abs(p) - vec3( 14., 25.25, 0. );\\n    vec3 pm3 = abs(p) - vec3( 6.8, 0., 56.4 );      \\n\\n    d = opU( d, sdColumn( pm, vec2( 1.8, 1.8 ) ) );        \\n    d = opS( d, sdBox( p,  vec3( 2.5, 9.5, 74. ) ) );    \\n    d = opS( d, sdBox( p,  vec3( 5., 18., 73. ) ) );\\n    d = opS( d, sdBox( p,  vec3( 13.8, 14.88, 63. ) ) );\\n    d = opS( d, sdBox( p,  vec3( 13.2, 25., 63. ) ) );\\n    d = opS( d, sdColumn( p,  vec2( 9.5, 63. ) ) ); \\n    d = opU( d, sdColumn( pm3, vec2( 1.8, 1.8 ) ) );\\n    d = opU( d, sdBox( pm2, vec3( 5., .45, 200. ) ) );\\n    \\n    return d;\\n}\\n\\nfloat mapDamage( vec3 p ) {\\n    float d = map( p );\\n\\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\\n                   noise( p*.3 )* (noise( p*2.3 ) +.2 )-.2 - damageMod, 0.);\\n   \\n\\treturn d + n;\\n}\\n\\nfloat mapDamageHigh( vec3 p ) {\\n    float d = map( p );\\n    \\n    float p1 = noise( p*2.3 );\\n    float p2 = noise( p*5.3 );\\n    \\n    float n = max( max( 1.-abs(p.z*.01), 0. )*\\n                   max( 1.-abs(p.y*.2-1.2), 0. ) *\\n                   noise( p*.3 )* (p1 +.2 )-.2 - damageMod, 0.);\\n  \\n    float ne = 0.;\\n    ne += smoothstep( -0.7, 0., -distance( p, ep1.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep2.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep3.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep4.xyz ) );\\n    ne += smoothstep( -0.7, 0., -distance( p, ep5.xyz ) );\\n    \\n    n += .5 * max((ne - p2 ),0.) * ne;\\n  \\n    if( p.y < .1 ) {\\n        n += max(.1*(1.-abs(d)+7.*noise( p*.7 )+.9*p1+.5*p2)-4.5*damageMod,0.);\\n    }\\n    \\n    if( abs(n) > 0.0 ) {\\n        n += noise( p*11.) * .05;\\n        n += noise( p*23.) * .03;\\n    }\\n    \\n\\treturn d + n;\\n}\\n\\n\\nvec3 calcNormalDamage( in vec3 pos, in float eps ) {\\n    if( pos.y < 0.001 && (mapDamageHigh(pos)-map(pos)) < eps ) {   \\t\\t\\n\\t        return vec3( 0., 1., 0. );\\n    }\\n    \\n    vec2 e = vec2(1.0,-1.0)*(0.5773*eps);\\n    vec3 n =  normalize( e.xyy*mapDamageHigh( pos + e.xyy ) + \\n\\t\\t\\t     \\t\\t e.yyx*mapDamageHigh( pos + e.yyx ) + \\n\\t\\t\\t\\t\\t  \\t e.yxy*mapDamageHigh( pos + e.yxy ) + \\n\\t\\t\\t\\t\\t  \\t e.xxx*mapDamageHigh( pos + e.xxx ) );\\n    n = bumpMapNormal( pos, n );\\n    return n;    \\n}\\n\\n//----------------------------------------------------------------------\\n// lighting\\n\\nfloat calcAO( in vec3 pos, in vec3 nor ) {\\n\\tfloat occ = 0.0;\\n    for( int i=0; i<6; i++ ) {\\n        float h = 0.1 + 1.2*float(i);\\n        occ += (h-map( pos + h*nor ));\\n    }\\n    return clamp( 1.0 - occ*0.025, 0.0, 1.0 );    \\n}\\n\\nfloat calcFakeAOAndShadow( in vec3 pos ) { \\n    float r = (1.-abs(pos.x)/30.5);\\n    \\n    r *= max( min( .35-pos.z / 40., 1.), 0.65);\\n    r *= .5+.5*smoothstep( -66., -.65, pos.z);\\n    \\n    if( pos.y < 25. ) r *= 1.-smoothstep( 18., 25., .5*pos.y+abs(pos.x) ) * (.6+pos.y/25.);\\n    r *= 1.-smoothstep(5., 8., abs(pos.x) ) * .75 * (smoothstep( 60.,63.,abs(pos.z)));\\n    \\n    return clamp(r, 0., 1.);\\n}\\n\\n//----------------------------------------------------------------------\\n// materials\\n\\nfloat matMarble( in vec3 pos, in vec3 nor ) {\\n    float i = tileId( pos, nor );\\n    \\n    return .072*(hash(i)+noise(pos*7.))+.12*noise(pos*25.);\\n}\\n\\nfloat matSideLamp( in vec3 pos, in vec3 nor ) {\\n    float l = (1.-smoothstep(0.05,0.15, abs( pos.y-13.75 ) ))\\n        \\t* (1.-smoothstep(1.5,1.7, abs( mod(pos.z, 3.6)-1.8 ) ));\\n    return 5. * l;\\n}\\n\\nfloat matOutdoorLight( in vec3 pos, in vec3 nor ) {\\n    float l = ( smoothstep( 0.03, 0.1, abs( mod( pos.x, 1.8 ) / 1.8 - .5) ))\\n\\t\\t\\t* ( smoothstep( 0.03, 0.1, abs( mod( pos.y, 3.6 ) / 3.6 - .5) ));\\n    return mix( 8.,12., l);\\n}\\n\\nvec2 shade( in vec3 pos, in vec3 nor, in float m, in float t, in bool reflection ) {\\n    float refl = 0.1;\\n    float mate = 0.;\\n \\tfloat light = 0.;            \\n    float col = 0.;\\n    \\n    if( m < .5 ) {\\n   \\t\\tif( pos.y < .01 ) {\\n\\t    \\tmate = .05 * (.25+.2*texture( iChannel1, pos.xz*.05 ).r);\\n            float x = abs(pos.x);\\n            if( (x > 12. && x < 14.8) ||  (x > 3.2 && x < 6.8) || abs(pos.z) > 68.4 ) mate *= 0.25;\\n        } else if( pos.y > 13.5 && pos.y < 13.99 && abs( pos.x ) > 27.99 ) {\\n            light = matSideLamp( pos, nor ); \\n        } else if( pos.z > 62. && pos.y > 52. ) {\\n            light = matOutdoorLight( pos, nor );\\n        } else {\\n \\t\\t\\tmate = matMarble( pos, nor );\\n            refl = 0.05;\\n   \\t\\t}\\n        if( abs(mapDamageHigh(pos)-map(pos)) > 0.0001 * t ) {\\n            refl = 0.;\\n            mate = 0.21;\\n        }\\n        if( abs( pos.z ) > 73.1 ) {\\n            mate = 0.02;\\n            if( mod( abs( pos.x ), 2.25 ) < .3 ||\\n            \\tmod( abs( pos.y ), 2.25 ) < .3 ) mate = 0.0025;\\n            refl = 0.02;\\n        }\\n            \\n        if( nor.y < -0.8 && pos.y > 13.49 ) {\\n            col += mate * (0.4 * pow( max( (abs(pos.x*.38)-7.2),0.), 2.));\\n        }        \\n    } \\n#if RENDERDEBRIS\\n    else if( m < 1.5 ) {\\n            refl = 0.;\\n            mate = 0.1 * noise(pos);\\n    }\\n#endif\\n    \\n    col += mate * (\\n        25. * ( 0.02 +\\n        .2 * min(1., max( -nor.x * sign(pos.x), 0.)) + \\n        .5 * min(1., max( nor.y, 0. )) +\\n        .05 * abs( nor.z ) ) * calcFakeAOAndShadow( pos ) );\\n    \\n    col *= calcAO( pos, nor );\\n    col += light;\\n    \\n    return vec2( col, refl );\\n}\\n\\n//----------------------------------------------------------------------\\n// intersection code\\n\\nfloat intersect( in vec3 ro, in vec3 rd ) {\\n\\tconst float precis = 0.00125;\\n    float h = precis*2.0;\\n    float t = 0.1;\\n        \\n    float d = -(ro.y)/rd.y;\\n    float maxdist = d>0.?d:500.;\\n    \\n\\tfor( int i=0; i < MARCHSTEPS; i++ ) {\\n#if HIGHQUALITY\\n        h = .9*mapDamage( ro+rd*t );\\n#else\\n        h = map( ro+rd*t );\\n#endif\\n        if( h < precis ) {\\n            return t;\\n        } \\n        t += h+0.00005*t;\\n        if( t > maxdist ) {\\n            return maxdist;\\n        }\\n    }\\n    return -1.;\\n}\\n\\n\\nfloat intersectReflection( in vec3 ro, in vec3 rd ) {\\n\\tconst float precis = 0.00125;\\n    float h = precis*2.0;\\n    float t = 0.;\\n        \\n    float d = -(ro.y)/rd.y;\\n    float maxdist = d>0.?d:500.;\\n    \\n\\tfor( int i=0; i < MARCHSTEPSREFLECTION; i++ ) {\\n        h = map( ro+rd*t );\\n        if( h < precis ) {\\n            return t;\\n        } \\n        t += h+0.01*t;\\n        if( t > maxdist ) {\\n            return maxdist;\\n        }\\n    }\\n    return -1.;\\n}\\n\\n//----------------------------------------------------------------------\\n// render functions\\n\\nfloat renderExplosionDebris( const in vec3 ro, const in vec3 rd, in float maxdist, const in vec4 ep, inout vec3 nor, \\n                             const in float time ) {\\n    float maxRadius = 30.*(time - ep.w - .025);\\n    float minRadius = 0.2 * maxRadius;\\n    if( maxRadius > 30. ) return maxdist;\\n    \\n    for( int i=0; i<DEBRISCOUNT; i++ ) {\\n        float id = hash(  ep.w+float(i) );\\n        vec3 dir = normalize( -1.+2.*vec3( id, hash(  ep.w+.5*float(i) ), hash(  ep.w+1.5*float(i) ) ) - vec3( 2.*sign(ep.x), 0., 0.) );\\n        vec3 pos = ep.xyz + dir*mix( minRadius, maxRadius, id ) + vec3(0.,-maxRadius*sin( maxRadius*0.005 ),0.);\\n        float d = iSphere( ro, rd, vec4( pos, 0.1*id+0.003 ) );\\n        if( d > 0. && d < maxdist ) {\\n            maxdist = d;\\n            nor = nSphere( ro+rd*d, vec4( pos, 0.1*id+0.003 ) );\\n        }\\n    }\\n    \\n    return maxdist;\\n}\\n\\nvoid renderExplosionDust( const in vec3 ro, const in vec3 rd, in float dist, const in vec4 ep, inout vec2 col, \\n                          const in float time, const in vec3 grd ) {\\n    float maxRadius = 10.*(time - ep.w + .25);\\n    if( maxRadius > 40. ) return ;\\n    \\n    float dens = 0.;\\n    float ho = hash( ep.w ); // id of explosion\\n    float fade = pow( 2., -maxRadius*0.11-2.);\\n    float zoom = 2.5/maxRadius;\\n    vec2 down = vec2(sin(maxRadius*0.005+.1), 0.);\\n                     \\n\\t// intersect planes\\n    vec2 d = -(ro.xz - ep.xz )/rd.xz;\\n    if( d.x > 0. ) {\\n        vec3 pos = ro+d.x*rd;\\n        float radius = distance( ep.yz, pos.yz );\\n        if( radius < maxRadius  ) {\\n            float l = max( 0.025*(dist-d.x) + .5, 0. ) \\n                        \\t\\t\\t* fade \\n                      \\t\\t\\t\\t* abs( grd.x )\\n                     \\t\\t\\t\\t* (1.-smoothstep( 0.8*maxRadius, maxRadius, radius ));            \\n\\t        float excol = mix( col.x, 1., pow( max(1.-2.*textureLod( iChannel2,ho+(pos.yz-ep.yz)*zoom + down, 0.0 ).x,0.),3.) );               \\n    \\t    col.x = mix( col.x, excol, l);\\n            col.y += l;\\n        }\\n    }\\n    \\n    if( d.y > 0. ) {\\n        vec3 pos = ro+d.y*rd;\\n        float radius = distance( ep.yx, pos.yx );\\n        if( radius < maxRadius  ) {\\n            float l = max( 0.025*(dist-d.y) + .5, 0. ) \\n                        \\t\\t\\t* fade \\n                      \\t\\t\\t\\t* abs( grd.z )\\n                     \\t\\t\\t\\t* (1.-smoothstep( 0.8*maxRadius, maxRadius, radius ));\\n\\t        float excol = mix( col.x, 1., pow( max(1.-2.*textureLod( iChannel2,ho+(pos.yx-ep.yx)*zoom + down, 0.0 ).x,0.),3.) );   \\n    \\t    col.x = mix( col.x, excol, l);\\n            col.y += l;\\n        }\\n    }\\n}\\n\\nvec3 render( const in vec3 ro, const in vec3 rd, in float time, const in float fog, const in vec3 grd ) {\\n    const float eps = 0.01;\\n    vec2 col = vec2(0.);\\n    \\n    float t = intersect( ro, rd );\\n    if( time > STT(98.) ) {\\n        time = STT(95.5)+.4*(time-STT(95.5)); // slow motion\\n    }\\n    time += .03*hash( rd.x + rd.y*5341.1231 ); // motionblur\\n    \\n    if( t > 0. ) {\\n        vec3 nor;\\n        float m = 0.;\\n\\n#if RENDERDEBRIS\\n        float d = renderExplosionDebris( ro, rd, t, ep1, nor, time );\\n        d = renderExplosionDebris( ro, rd, d, ep3, nor, time );\\n        d = renderExplosionDebris( ro, rd, d, ep5, nor, time );\\n#if HIGHQUALITY \\n        d = renderExplosionDebris( ro, rd, d, ep2, nor, time );\\n        d = renderExplosionDebris( ro, rd, d, ep4, nor, time );\\n#endif\\n        if( d < t ) {\\n            m = 1.;\\n            t = d;\\n        } \\n#endif\\n   \\n        vec3 pos = ro + t*rd;\\n        if( m < .5 ) {\\n\\t        nor = calcNormalDamage( pos, eps );\\n        }\\n        col = shade( pos, nor, m, t, false );\\n\\n#if REFLECTIONS        \\n        vec3 rdReflect = reflect( rd, -nor );\\n        float tReflect = intersectReflection( pos + eps*rdReflect, rdReflect );\\n\\n        if( tReflect >= 0. && col.y > 0. ) {\\n            vec3 posReflect = pos + tReflect*rdReflect;\\n            vec3 norReflect = calcNormalDamage( posReflect, eps );\\n\\n            col += shade( posReflect, norReflect, 0., tReflect, true ) * col.y;\\n        }\\n#endif\\n    } else {\\n        t = 60.;\\n    }\\n\\n    col.y = 0.; \\n    renderExplosionDust( ro, rd, t, ep1, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep2, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep3, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep4, col, time, grd );\\n    renderExplosionDust( ro, rd, t, ep5, col, time, grd );\\n    \\n // add fog\\n    vec3 dcol = vec3( max(col.x,0.) );\\n \\tdcol = mix( vec3(.5), dcol, exp( -t*(.02*fog+.005*col.y) ) );\\n        \\n    return pow( dcol, vec3(0.45) );\\n}\\n\\n//----------------------------------------------------------------------\\n// explosions\\n\\n#define E1(a,b,c,d) t+=a;if( time >= t ){ep1 = vec4(b,c,d,t);}\\n#define E2(a,b,c,d) t+=a;if( time >= t ){ep2 = vec4(b,c,d,t);}\\n#define E3(a,b,c,d) t+=a;if( time >= t ){ep3 = vec4(b,c,d,t);}\\n#define E4(a,b,c,d) t+=a;if( time >= t ){ep4 = vec4(b,c,d,t);}\\n#define E5(a,b,c,d) t+=a;if( time >= t ){ep5 = vec4(b,c,d,t);}\\n\\nvoid initExplosions( const in float time ) {\\n\\tep1 = ep2 = ep3 = ep4 = ep5 = vec4(-1000.);\\n    \\n    float t = 0.;    \\n    E1(STT(21.), 16., 3.9, 8.2 );\\n    E2(.7, 16., 5.4, 6.1 );\\n    E3(.3, 16., 6.3, 7.7 );\\n    E4(1., 16., 4.8, 8.2 );\\n    E5(.7, 16., 5.7, 7.3 );\\n    \\n    t = 0.;\\n    E1(STT(34.), -16., 3.9, 5.2 );\\n    E2(.5, -16., 5.4, 5.1 );\\n    E3(.7, -16., 6.3, 6.7 );\\n    E4(.5, -16., 4.8, 7.2 );\\n    E5(.4, -16., 5.7, 6.3 );\\n        \\n    t = 0.;\\n    E1(STT(42.), -19.1, 3.9, -4.5 );\\n    E2(1.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E1(.9, -16., 3.9, -5.2 );\\n    E2(.5, -16., 5.4, -5.1 );\\n    E3(.3, -16., 6.3, -6.7 );\\n    E4(.5, -16., 4.8, -7.2 );\\n    E5(.4, -16., 5.7, -6.3 );    \\n    \\n    t = 0.;    \\n    E1(STT(58.), 16., 3.9, 2.2 );\\n    E2(.2, 16., 5.4, 4.1 );\\n    E3(.3, 24., 6.3, 3.7 );\\n    E4(.5, 16., 4.8, 8.2 );\\n    E5(.7, 24., 5.7, 4.3 );\\n    E1(.1, 16., 1.9, 8.2 );\\n    E2(.2, 24., 5.4, -2.1 );\\n    \\n    t = 0.;\\n    E1(STT(66.), 16., 3.9, 6.5 );\\n    E2(.2, 16., 5.4, 6.1 );\\n    E5(.3, 16., 6.7, 7.3 );\\n    E3(.3, 16., 6.3, 5.7 );\\n    E4(.2, 16., 7.8, 6.2 );\\n        \\n    E5(.1, 16., 5.7, 4.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 17., 6.4, -4.5 );\\n    E3(.3, 16., 6.3, -5.7 );\\n    E4(.5, 16., 7.8, -6.2 );    \\n    E5(.3, 16., 5.7, -7.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 16., 6.4, -4.5 );\\n   \\n    t = 0.;\\n    E1(STT(78.), -17.1, 3.9, -4.5 );\\n    E2(.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(1.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E2(.5, -19.6, 5.4, -5.1 );\\n    E1(.9, -19.6, 3.9, -5.2 );\\n    E3(.3, -19.6, 6.3, -6.7 );\\n    E4(.5, -19.6, 4.8, -7.2 );\\n    E5(.4, -19.6, 5.7, -6.3 );\\n}\\n\\n//----------------------------------------------------------------------\\n// camera\\n\\nmat3 setCamera( const in vec3 ro, const in vec3 rt, const in float cr, const in float fl ) {\\n\\tvec3 cw = normalize(rt-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, -fl*cw );\\n}\\n\\n#define SCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){damageMod=j;sro=b;ero=c;sta=d;eta=e;st=t;dt=a;sfog=h;efog=i;}t+=a;\\n#define CCAM(a,j,h,i,f,g,b,c,d,e) if(time >= t ){sro=ero;ero=c;sta=eta;eta=e;st=t;dt=a;sfog=efog;efog=i;}t+=a;\\n\\nvoid getCamPath( const in float time, inout vec3 ro, inout vec3 ta, inout float fl, inout float fog ) {\\n    vec3 sro, sta, ero, eta;\\n    float st = 0., dt, t = 0., sfog, efog;\\n    \\n    SCAM(STT(12.), 0., 0.,    0., 1.5, 1.5, vec3( 0., 5., 22.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \\n    SCAM(STT(7.5), 0., 0.,    0., 1.5, 1.5, vec3( -14., 5.,  18.5 ), vec3( 18., 4., 11. ), vec3( 10., 5., -50. ), vec3( 0., 5., -50. ) ); \\n    CCAM(STT(7.5), 0., 0.,  0.05, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 21.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \\n    CCAM(STT(2.5), 0., 0.05, 0.1, 1.5, 1.5, vec3( 21.5, 4., 11.5 ), vec3( 21.5, 4., 11.5 ),  vec3( -4., 7., 0. ), vec3( -16., 7., 8. ) ); \\n    CCAM(STT(4.), 0.,  0.1, 0.15, 1.5, 4.5, vec3( 21.5, 4., 11.5 ), vec3( 10., 4.25, 11.35 ),  vec3( -16., 7., 8. ), vec3( -16., 6., 8. ) ); \\n    \\n    SCAM(STT(7.5),  0., 0.1,  0.3, 1.5, 1.5, vec3( -11., 5.25, 7.05 ), vec3( -13., 5., 9. ),  vec3( -19., 5.2, 7. ), vec3( -16.5, 5., 5.3 ) );     \\n    SCAM(STT(13.), .4, 0.1,  0.5, 1.5, 1.5, vec3( -18., 5., 4.05 ), vec3( -10., 5.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 5.25, -7.3 ) );     \\n\\tCCAM(STT(4.), .45, 0.5,  0.65, 1.5, 1.2, vec3( -10., 5.25, -6. ), vec3( -12., 5.25, -9. ),  vec3( -15.5, 5.25, -7.3 ), vec3( -13.5, 6.25, 2.3 ) );     \\n\\n    SCAM(STT(7.5), .95, 0.4,  1.9, 1.5, 1.5, vec3( 18., 4., 11. ), vec3( 25.5, 4., 11.5 ),  vec3( 0., 5., -50. ), vec3( -4., 7., 0. ) ); \\n\\n    SCAM(STT(12.2), .95, 0.8,  1.3, 1.5, 1.5, vec3( 10., 4.7, 4. ), vec3( 10., 5., -7.5 ),  vec3( 50., 5., 2. ), vec3( 40., 5., -20. ) ); \\n    \\n    SCAM(STT(16.25), 1., 0.4,  0.8, 1.5, 1.5, vec3( -18., 4.5, 4.05 ), vec3( -26., 3.25, -6. ),  vec3( -17., 5.5, 0. ), vec3( -15.5, 6.25, -7.3 ) );     \\n    CCAM(STT(4.),  1., 0.8,  0.6, 1.5, 1.5, vec3( -26., 3.25, -6. ), vec3( -26., 3.25, -6. ),  vec3( -15.5, 6.25, -7.3 ), vec3( -15.5, 6.25, -7.3 ) );     \\n\\n    SCAM(STT(16.), 1.1, 0.4, 0.05, 1.5, 1.5, vec3( 0., 5.,  18.5 ), vec3( 0., 5.,  18.5 ), vec3( 0., 5., 0. ), vec3( 0., 5., 0. ) ); \\n  \\n    dt = clamp( (time-st)/dt, 0., 1. );\\n\\n    if(  time > STT(65.5) && time < STT(77.75)  ) {\\n\\t    ro = mix( sro, ero, dt);\\n    \\tta = mix( sta, eta, dt);\\n    } else {\\n\\t    ro = mix( sro, ero, smoothstep(0.,1., dt));\\n    \\tta = mix( sta, eta, smoothstep(0.,1., dt));\\n    }\\n\\t\\n    fl = 1.5;    \\n    if( time > STT(29.5) && time < STT(33.5) ) {\\n        fl = mix( 1.5, 4.5, smoothstep( STT(29.5), STT(33.5), time ) );\\n    }\\n    \\n   \\tfog = mix( sfog, efog, dt);\\n    damageMod = .4-.4*damageMod;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    float time = mod(iTime, 60.);\\n\\n    vec2 q = fragCoord.xy/iResolution.xy;\\n\\t    \\n    // letterbox\\n    if( abs(2.*fragCoord.y-iResolution.y) > iResolution.x * 0.42 ) {\\n        fragColor = vec4( 0., 0., 0., 1. );\\n        return;\\n    }\\n  \\n    vec3 ro, ta;\\n    float fl, fog;\\n      \\n    getCamPath( time, ro, ta, fl, fog );\\n        \\n    initExplosions( time );\\n    \\n    mat3 ca = setCamera( ro, ta, 0.0, (1./1.5) );    \\n    vec2 p = (-iResolution.xy+2.*(fragCoord.xy))/iResolution.x;\\n    vec3 rd = normalize( ca * vec3(p,-fl) );\\n\\n    float dist = intersect( ro, rd );\\n    vec3 col = vec3( floor(dist), fract(dist), 0. );\\n    \\n    fragColor = vec4( col, 1.0 );\\n}\\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"// Created by Reinder Nijhoff 2015\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtsXzf\\n//\\n\\n#define N(a) if(t>b)x=b;b+=a;\\n#define NF(a,c,g) if(t>b){x=b;f=c;v=g;d=a;}b+=a;\\n\\n//----------------------------------------------------------------------------------------\\n\\n#define LOOPCOUNT\\t\\t(16.)\\n\\n#define PI2 6.283185307179586476925286766559\\n\\n#define D 36.71\\n#define A 55.00\\t\\n#define B 61.74\\n#define C 65.41\\n\\n//-----------------------------------------------------\\n// noise functions\\n\\n#define MOD2 vec2(.16632,.17369)\\nfloat hash(const in float p) { // by Dave Hoskins\\n\\tvec2 p2 = fract(vec2(p) * MOD2);\\n    p2 += dot(p2.yx, p2.xy+19.19);\\n\\treturn fract(p2.x * p2.y);\\n}\\n\\nfloat sine(const in float x) {\\n    return sin(PI2 * x);\\n}\\n\\nfloat loop(const in float t, const in float steps) {\\n    return mod(t, steps * ISTEP);\\n}\\n\\nfloat distortion(const in float s, const in float d) {\\n\\treturn clamp(s * d, -1.0, 1.0);\\n}\\n\\nfloat quan(const in float s, const in float c) {\\n\\treturn floor(s / c) * c;\\n}\\n\\nbool inLoop( float time, float s, float e ) {\\n    float t = (time * (STEP / LOOPCOUNT));\\n    return ( t >= s && t < e );\\n}\\n\\n//-----------------------------------------------------\\n// instruments by iq and And\\n\\nfloat snare(const in float t, const in float f0) {\\n    float op3 = sine((t * f0) * 2.8020) * exp(-t * 1.0);\\n    float op2 = sine((t * f0) * 2.5000 + op3 * 1.00);\\n    float op1 = sine((t * f0) * 18.000 + op2 * 0.72);\\n\\n    return op1 * exp(-t * 5.5);\\n}\\n\\nfloat kick(float tb) {\\n\\tconst float aa = 5.0;\\n\\ttb = sqrt(tb * aa) / aa;\\n\\t\\n\\tfloat amp = exp(max(tb - 0.015, 0.0) * -5.0);\\n\\tfloat v = sine(tb * 100.0) * amp;\\n\\tv += distortion(v, 4.0) * amp;\\n\\treturn v;\\n}\\n\\nfloat bass(const in float time, const in float freq, const in float duration) {\\n    float ph = 1.0;\\n    ph *= sin(6.2831*freq*time);\\n    ph *= 0.1+0.9*max(0.0,6.0-0.01*freq);\\n    ph *= exp(-time*freq*0.3);\\n    \\n    \\n    float y = 0.;\\n    y += 0.70*sin(1.00*PI2*freq*time+ph);//*exp(-0.07*time);\\n    y += 0.90*sin(2.01*PI2*freq*time+ph);//*exp(-0.11*time);\\n\\n    y += 0.145*y*y*y;   \\n\\n    y *= 1.-smoothstep( duration*0.9, duration, time * STEP );\\n\\n    return y;\\n}\\n\\nfloat bell(const in float t, const in float f0) {\\n    float op3 = sine((f0 * t) * 6.0000             ) * exp(-t * 5.0);\\n    float op2 = sine((f0 * t) * 7.2364 + op3 * 0.20);\\n    float op1 = sine((f0 * t) * 2.0000 + op2 * 0.13) * exp(-t * 2.0);\\n\\n    return op1;\\n}\\n\\nfloat lift(float time) {\\n    return sin(PI2*D*32.*time)*exp(-6.0*time) + bell(time, D*32.);\\n}\\n\\nfloat gun(float time, float f, const in float d) {\\n    return distortion( textureLod( iChannel0, vec2(time*5.7864, time*6.9732)*f, 0. ).x *exp(-10.0*time)\\n                       * smoothstep(0.,0.1,time) * (1.-smoothstep(0.5,.6,time)), d);\\n}\\n\\n//-----------------------------------------------------\\n// loops\\n\\nfloat loopBass(const in float t, const in float m) {\\n    float x = 0., b = 0., f = 0., v = 0., d;\\n                \\n    NF(2.,D,0.9);NF(2.,D,1.);NF(1.,D,0.5);NF(1.,D,0.6);NF(1.,D,0.5);\\n    NF(2.,A,1.05);NF(1.,D,0.5);NF(2.,B,0.9);NF(1.,D,0.5); NF(3.,C,1.);\\n    f *= m;\\n    \\n    return v * bass( (t-x)*ISTEP, f, d );\\n\\n}\\n    \\nfloat loopBassIntro(const in float t) {\\n    float x = 0., b = 0., f = 0., v = 0., d;\\n    NF(4.,A,.5);NF(2.,D,.8);NF(8.,D,1.);NF(2.,D,.25);\\n    \\n    return v * bass( (t-x)*ISTEP, f*.5, d );\\n}\\n\\nfloat loopDrums(const in float t) {\\n    float x = 0., b = 0., r;\\n    \\n    // base\\n    N(3.);N(7.);N(1.);N(5.);\\n\\tr = kick( (t-x)*ISTEP*1.2 );\\n    \\n    // bell\\n    x = b = 0.;\\n    N(4.);N(4.);N(4.);N(2.);N(2.);\\n    r += .25 * bell( (t-x)*ISTEP*8., 100. );\\n    \\n    // hihat\\n    x = b = 0.;\\n    N(3.);N(3.);N(2.);N(2.);N(4.);\\n    r += .35 * snare( (t-x)*ISTEP*2., 200.+t );\\n    \\n    // snare\\n    x = b = 0.;\\n    N(4.);N(3.);N(2.);N(3.);N(1.);N(3.);\\n    r += .75 * snare( (t-x)*ISTEP*8., 10. );\\n\\n    return r;\\n}\\n\\nfloat loopDrumsIntro(const in float t) {\\n    float x = 0., b = 0.;\\n    \\n    // snare\\n    N(1.);N(3.);N(3.);N(2.);N(1.);N(1.);N(1.);N(1.);N(1.);N(1.);N(1.);\\n    return (t/24.) * snare( (t-x)*ISTEP*8., 10. ) + kick(  (t)*ISTEP*1.2 );\\n}\\n\\nfloat loopGun( const in float time, const in float interval, const in float numshots, \\n               const in float shotdelay, const in float minf, const in float maxf ) {\\n    float it = mod( time, interval );\\n\\n#if HIGHQUALITY\\n    float m = 0.;\\n    for( float sh = 0.; sh<2.5; sh+=1.) {\\n        if( sh < numshots ) {\\n            float g = (0.5+0.5*hash(sh+.5))*gun( it - sh*shotdelay - .5*shotdelay*hash(sh), mix(minf, maxf, hash(sh+.25)), 1.5 );\\n    \\t\\tm = m+g - abs(m)*g;\\n        }\\n    }\\n \\n    return m;\\n#else\\n    float sh = floor( it/shotdelay );\\n    if( sh < numshots ) {\\n        return (0.5+0.5*hash(sh+.5))*gun( it - sh*shotdelay - .5*shotdelay*hash(sh), mix(minf, maxf, hash(sh+.25)), 1.5 );\\n    }\\n    return 0.;\\n#endif\\n}\\n\\n\\n\\n//-----------------------------------------------------\\n// music\\n\\nfloat loopMusic(const in float time) {\\n\\tfloat mtime = loop( time, 16. );\\n    float t = mtime * STEP;\\n    float m = 1.;\\n    \\n    float d = 0.;\\n    float b = 0.;\\n    \\n    if( inLoop( time, 2., 36. ) && !inLoop( time, 6., 8. ) && !inLoop( time, 15., 16. )  ) {\\n        d = loopDrums( t );\\n    }\\n    \\n    if( inLoop( time, 1., 2. ) || inLoop( time, 7., 8. ) || inLoop( time, 11., 12. ) ) {\\n        d += loopDrumsIntro( t );\\n    }\\n    \\n    if( inLoop( time, 10., 12. ) ) {\\n        m = B/D;\\n    }\\n\\n    return loopBass( t, m ) + .5*d;\\n}\\n\\nfloat loopIntro(const in float time) {\\n\\tfloat mtime = loop( time, 16. );\\n    float t = mtime * STEP;\\n    \\n\\tif( inLoop( time, .74, 5.25 ) ) {\\n        return loopBassIntro( t );\\n    }\\n    return 0.;\\n}\\n    \\nfloat loopBackground( const in float time ) {\\n    float m = 0., g = 0.;\\n    g = .5 * loopGun( time, 2., 3., .21, 1., 1.5 );\\n    m = m+g - abs(m)*g;\\n    \\n    g = .95 * loopGun( time-4.123, 3., 1., 1.5, 1., 1.5 );\\n    m = m+g - abs(m)*g;\\n    \\n    g = .7 * loopGun( time-3., 3.2, 2., .41, 1., 1.5 );\\n    m = m+g - abs(m)*g;\\n    \\n    return m;\\n}\\n\\nvoid initExplosions( in float time );\\nfloat exTime1, exTime2;\\n\\n//-----------------------------------------------------\\n// main\\n    \\nvec2 mainSound( in int samp,float time) {\\n    time = mod(time, 60.);\\n        \\n    initExplosions(time);\\n    // align with music\\n    exTime1 = floor( exTime1 / ISTEP * 2.)*ISTEP*.5;\\n    exTime2 = floor( exTime2 / ISTEP * 2.)*ISTEP*.5;\\n    \\n    float m = 0., music = 0., gun1 = 0., gun2 = 0., bg = 0.;\\n    \\n    if( time < STT(34.) ) {\\n        music = loopIntro( time );\\n    } else if( time < STT(98.) ){\\n        music = loopMusic( time-STT(34.) );\\n    }\\n    music *= .25;\\n    \\n    gun1 = gun( time-exTime1, mix(1.,1.5,hash(exTime1)), 3. );\\n    gun2 = gun( time-exTime2, mix(1.,1.5,hash(exTime2)), 3. );\\n    \\n    if( time > STT(34.) && time < STT(84.)  ) {\\n        bg = loopBackground(time);\\n    }\\n    \\n    m = m+bg - abs(m)*bg;\\n    m = m+music - abs(m)*music;\\n    \\n    m = m+gun1 - abs(m)*gun1;\\n    m = m+gun2 - abs(m)*gun2;\\n    \\n    m *= 1.5;\\n    \\n    if( time > 44.5 ) m += .0625*lift( time-44.5);\\n    \\n    return vec2( clamp(m, -1., 1.) );\\n}\\n\\n\\n//----------------------------------------------------------------------\\n// explosions\\n\\n#define E1(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n#define E2(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n#define E3(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n#define E4(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n#define E5(a,b,c,d) t+=a;if( time >= t ){exTime2=exTime1;exTime1=t;}\\n\\nvoid initExplosions( in float time ) {\\n\\texTime1 = exTime2 = -1000.;\\n    \\n    float t = 0.;    \\n    E1(STT(21.), 16., 3.9, 8.2 );\\n    E2(.7, 16., 5.4, 6.1 );\\n    E3(.3, 16., 6.3, 7.7 );\\n    E4(1., 16., 4.8, 8.2 );\\n    E5(.7, 16., 5.7, 7.3 );\\n    \\n    t = 0.;\\n    E1(STT(34.), -16., 3.9, 5.2 );\\n    E2(.5, -16., 5.4, 5.1 );\\n    E3(.7, -16., 6.3, 6.7 );\\n    E4(.5, -16., 4.8, 7.2 );\\n    E5(.4, -16., 5.7, 6.3 );\\n        \\n    t = 0.;\\n    E1(STT(42.), -19.1, 3.9, -4.5 );\\n    E2(1.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E1(.9, -16., 3.9, -5.2 );\\n    E2(.5, -16., 5.4, -5.1 );\\n    E3(.3, -16., 6.3, -6.7 );\\n    E4(.5, -16., 4.8, -7.2 );\\n    E5(.4, -16., 5.7, -6.3 );    \\n    \\n    t = 0.;    \\n    E1(STT(58.), 16., 3.9, 2.2 );\\n    E2(.2, 16., 5.4, 4.1 );\\n    E3(.3, 24., 6.3, 3.7 );\\n    E4(.5, 16., 4.8, 8.2 );\\n    E5(.7, 24., 5.7, 4.3 );\\n    E1(.1, 16., 1.9, 8.2 );\\n    E2(.2, 24., 5.4, -2.1 );\\n    \\n    t = 0.;\\n    E1(STT(66.), 16., 3.9, 6.5 );\\n    E2(.2, 16., 5.4, 6.1 );\\n    E5(.3, 16., 6.7, 7.3 );\\n    E3(.3, 16., 6.3, 5.7 );\\n    E4(.2, 16., 7.8, 6.2 );\\n        \\n    E5(.1, 16., 5.7, 4.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 17., 6.4, -4.5 );\\n    E3(.3, 16., 6.3, -5.7 );\\n    E4(.5, 16., 7.8, -6.2 );    \\n    E5(.3, 16., 5.7, -7.7 );\\n    E1(.2, 16., 3.9, -6.2 );\\n    E2(.3, 16., 6.4, -4.5 );\\n   \\n    t = 0.;\\n    E1(STT(78.), -17.1, 3.9, -4.5 );\\n    E2(.3, -17.4, 5.4, -4.5 );\\n    E3(.3, -18.2, 6.3, -4.5 );\\n    E4(.4, -17.7, 4.8, -4.5 );\\n    E5(.3, -16.7, 5.7, -4.5 );\\n  \\n    E3(1.3, -18.2, 6.3, -4.5 );\\n    E2(.2, -17.4, 5.4, -4.5 );\\n    E3(.1, -18.2, 6.3, -4.5 );\\n    E4(.2, -17.7, 4.8, -4.5 );\\n    E5(.1, -16.7, 5.7, -4.5 );\\n    \\n    E2(.5, -19.6, 5.4, -5.1 );\\n    E1(.9, -19.6, 3.9, -5.2 );\\n    E3(.3, -19.6, 6.3, -6.7 );\\n    E4(.5, -19.6, 4.8, -7.2 );\\n    E5(.4, -19.6, 5.7, -6.3 );\\n}\\n\\n","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define HIGHQUALITY 1\\n#define RENDERDEBRIS 1\\n#define REFLECTIONS 1\\n\\n#define MARCHSTEPS 90\\n#define MARCHSTEPSREFLECTION 30\\n#define DEBRISCOUNT 8\\n\\n#define BPM             (140.0)\\n#define STEP            (4.0 * BPM / 60.0)\\n#define ISTEP           (1./STEP)\\n#define STT(t)\\t\\t\\t(t*(60.0/BPM))","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"4tcGRr","date":"1467593786","viewed":1513,"name":"[SH16A] Reinder","description":"[SH16A] Challenge. This is work in progress. For now no change to code flow / algorithm is made.","likes":2,"published":"Public API","usePreview":0,"tags":["challenge","codesize","sh16a"]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Changes:\\n// Applying P_Malins comment (C *= T*V(1.2,1.02,.66)+(y+N).y*V(1,1.4,2)/8.;) -> 713 char\\n// I don't know why, but I could remove the max(0.,dot at the lighting equation -> 714 char\\n// Make all arguments global (inspired by P_Malin)\\n// Applying FabriceNeyret2's comment (identity in calculation of D)\\n\\n#define V vec3\\n#define Q normalize\\n#define F for(int i=0;i<64;i++)\\n\\n#define c F{n=y,T=P.y,m=-2;F l=length(q=P-V(i/5-2,s,i-2-i/5*5))-s,i<28&&l<T?T=l,m=i/2,n=Q(q):q,s+=g*=-1.;P+=T*d;}\\n\\nvoid mainImage( out vec4 f, vec2 p ) {\\n\\tint m; float T, s=.4, g=.15, l,h=.5;\\n    V C, d, D, N, n, q=iResolution, y = V(0,1,0),\\n    P = V( .851, 2, -2.8768 );\\n    \\n    D = d = mat3( d = Q(cross(N = -Q(.2*y+P),y)),cross(d,N), N ) * Q(V(p-q.xy*h,q.y));\\n    \\n    c\\n    \\n    N=n,q=mod(ceil(P),2.),C=P*P,\\n\\t\\n    C = m<0?\\n    \\tsmoothstep( 0.,h,max(C.x,C.z)<2.25?length(fract(P.xz+h)-h):2.)*        \\n       \\tV(q.x==q.z?.4:h*texture( iChannel0,.1*P.xz).x) : V(100-8*m,3*m,6*m)*.01;     \\n\\n\\td = Q(V(-6,7,-5));\\n    P += .01*d;\\n    \\n    c\\n    \\n    T = m<-1?dot(N,d):0.;    \\n\\t\\n    f=sqrt(C*(T*V(1.2,1.02,.66)+(y+N).y*V(1,1.4,2)/8.)+pow(max(0.,dot(reflect( D, N ), d)),16.)*T).xyzz;\\n}\\n\\n/*\\n\\n#define V vec3\\n#define Q normalize\\n\\nV C, P, n, q=iResolution, y = V(0,1,0);\\nfloat t, m, T, M, s, g=.15, l;\\n\\nvoid c( V o, V d ) {\\n    t=.01,s=.4;\\n    for( int i=0; i<64; i++ ) {\\n\\t\\tP=o+d*t,\\n\\t    n = y,\\n        T = P.y, M = -2.;        \\n        for( int i=0;i<28;i++) {\\n            l=length(q = P - V( i/5-2,s, i-2-i/5*5)) - s;\\n            if( l < T ) \\n                T = l, M = float(i/2), n = Q(q);\\n            s += g*=-1.;\\n\\t\\t}\\n        t += T;\\n\\t    m = M;\\n    }\\n}\\n\\nvoid mainImage( out vec4 f, vec2 p ) {\\n    V o = V( cos(5.),1,sin(5.) )*3.-y,\\n        N = -Q(.2*y+o),\\n        d = Q(cross(N,y)),        \\n\\t\\tL = Q(V(-6,7,-5));\\n    \\n    c(o,d = mat3( d,cross(d,N), N ) * Q(V((p+p-q.xy)/q.y,2)));  \\n    \\n    N=n,q=ceil(P),C=abs(P),\\n\\t\\n    C = m>=0.?V(-8,3,6)*.01*m+y.yxx:\\n    \\tsmoothstep( 0.,.5,length(fract(P.xz+.5)-.5)+step(1.5,max(C.x,C.z)))*        \\n       \\tV(mod(q.x+q.z,2.)<.5?.4:.5*texture( iChannel0,.1*P.xz).x);     \\n    \\n    c(P, L);\\n    \\n    t = max(0.,dot(N, L)) * step(m,-.5);    \\n\\t\\n    C *= t*V(1.2,1.02,.66)+(1.+N.y)*V(1,1.4,2)/8.;\\n    \\n    f=sqrt(C.xyzz+pow(max(0.,dot(reflect( d, N ), L)),16.)*t);\\n}\\n\\n*/","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xlt3Dn","date":"1468788417","viewed":5304,"name":"[SH16B] Speed tracer","description":"Because there is no character limit anymore, a lot more spheres can be rendered.\\nThis shader uses code of the [url=https://www.shadertoy.com/view/MdB3Dw]Analytical Motionblur 3D[/url] shader by Inigo and a grid to trace a lot of spheres.","likes":81,"published":"Public API","usePreview":0,"tags":["ray","blur","spheres","motion","analytic","trace"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [SH16B] Speed tracer. Created by Reinder Nijhoff 2016\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/Xlt3Dn\\n//\\n// This shader uses code of the Analytical Motionblur 3D shader by Inego and a grid to trace a lot of spheres.\\n//\\n\\n#define RAYCASTSTEPS 30\\n\\n#define GRIDSIZE 10.\\n#define GRIDSIZESMALL 7.\\n#define MAXHEIGHT 30.\\n#define SPEED 20.\\n#define FPS 30.\\n#define MAXDISTANCE 260.\\n#define MAXSHADOWDISTANCE 20.\\n\\n#define time iTime\\n\\n#define HASHSCALE1 .1031\\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\\n\\n//----------------------------------------------------------------------------------------\\n//  1 out, 2 in...\\nfloat hash12(vec2 p)\\n{\\n\\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\n\\n//----------------------------------------------------------------------------------------\\n///  2 out, 2 in...\\nvec2 hash22(vec2 p)\\n{\\n\\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\\n    p3 += dot(p3, p3.yzx+19.19);\\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\\n}\\n\\n//\\n// intersection functions\\n//\\n\\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, out float dist) {\\t\\n\\tif (rd.y==0.0) {\\n\\t\\treturn false;\\n\\t}\\n\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\td = min(100000.0, d);\\n\\tif( d > 0. ) {\\n\\t\\tdist = d;\\n\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n\\n//\\n// intersect a MOVING sphere\\n//\\n// see: Analytical Motionblur 3D\\n//      https://www.shadertoy.com/view/MdB3Dw\\n//\\n// Created by inigo quilez - iq/2014\\n//\\nvec2 iSphere( const in vec3 ro, const in vec3 rd, const in vec4 sp, const in vec3 ve, out vec3 nor )\\n{\\n    float t = -1.0;\\n\\tfloat s = 0.0;\\n\\tnor = vec3(0.0);\\n\\t\\n\\tvec3  rc = ro - sp.xyz;\\n\\tfloat A = dot(rc,rd);\\n\\tfloat B = dot(rc,rc) - sp.w*sp.w;\\n\\tfloat C = dot(ve,ve);\\n\\tfloat D = dot(rc,ve);\\n\\tfloat E = dot(rd,ve);\\n\\tfloat aab = A*A - B;\\n\\tfloat eec = E*E - C;\\n\\tfloat aed = A*E - D;\\n\\tfloat k = aed*aed - eec*aab;\\n\\t\\t\\n\\tif( k>0.0 )\\n\\t{\\n\\t\\tk = sqrt(k);\\n\\t\\tfloat hb = (aed - k)/eec;\\n\\t\\tfloat ha = (aed + k)/eec;\\n\\t\\t\\n\\t\\tfloat ta = max( 0.0, ha );\\n\\t\\tfloat tb = min( 1.0, hb );\\n\\t\\t\\n\\t\\tif( ta < tb )\\n\\t\\t{\\n            ta = 0.5*(ta+tb);\\t\\t\\t\\n            t = -(A-E*ta) - sqrt( (A-E*ta)*(A-E*ta) - (B+C*ta*ta-2.0*D*ta) );\\n            nor = normalize( (ro+rd*t) - (sp.xyz+ta*ve ) );\\n            s = 2.0*(tb - ta);\\n\\t\\t}\\n\\t}\\n\\n\\treturn vec2(t,s);\\n}\\n\\n//\\n// Shade\\n//\\n\\nvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\\n\\nvec3 shade( const in float d, in vec3 col, const in float shadow, const in vec3 nor, const in vec3 ref, const in vec3 sky) {\\n    float amb = max(0., 0.5+0.5*nor.y);\\n    float dif = max(0., dot( normalize(nor), lig ) );\\n    float spe = pow(clamp( dot(normalize(ref), lig ), 0.0, 1.0 ),16.0);\\n\\n    dif *= shadow;\\n\\n    vec3 lin = 1.20*dif*vec3(1.00,0.85,0.55);\\n    lin += 0.50*amb*vec3(0.50,0.70,1.00);\\n    col = col*lin;\\n    col += spe*dif;\\n    \\n    // fog\\n    col = mix( col, sky, smoothstep( MAXDISTANCE * .8, MAXDISTANCE, d ) );\\n    \\n\\treturn col;\\n}\\n\\n//\\n// Scene\\n//\\n\\nvoid getSphereOffset( const in vec2 grid, inout vec2 center ) {\\n\\tcenter = (hash22( grid ) - vec2(0.5) )*(GRIDSIZESMALL);\\n}\\n\\nvoid getMovingSpherePosition( const in vec2 grid, const in vec2 sphereOffset, inout vec4 center, inout vec3 speed ) {\\n\\t// falling?\\n\\tfloat s = 0.1+hash12( grid );\\n    \\n\\tfloat t = fract(14.*s + time/s*.3);\\t\\n\\tfloat y =  s * MAXHEIGHT * abs( 4.*t*(1.-t) );\\n    \\n    speed = vec3(0, s * MAXHEIGHT * ( 8.*t - 4. ), 0 ) * (1./FPS);\\n    \\n\\tvec2 offset = grid + sphereOffset;\\n\\t\\n\\tcenter = vec4(  offset.x + 0.5*GRIDSIZE, 1. + y, offset.y + 0.5*GRIDSIZE, 1. );\\n}\\n\\nvoid getSpherePosition( const in vec2 grid, const in vec2 sphereOffset, inout vec4 center ) {\\n\\tvec2 offset = grid + sphereOffset;\\n\\tcenter = vec4( offset.x + 0.5*GRIDSIZE, 1., offset.y + 0.5*GRIDSIZE, 1. );\\n}\\n\\nvec3 getSphereColor( vec2 grid ) {\\n\\tfloat m = hash12( grid.yx ) * 12.;\\n    return vec3(1.-m*0.08, m*0.03, m*0.06);\\n}\\n\\nvec3 render(const in vec3 ro, const in vec3 rd, const in vec3 cameraSpeed, const in mat3 rot ) {\\n    vec3 nor, ref, speed;\\n    \\n\\tfloat dist = MAXDISTANCE;\\n\\t\\n\\tvec3 sky = clamp( vec3(1,1.5,2.5)*(1.0-0.8*rd.y), vec3(0.), vec3(1.));\\n\\tvec3 colBackground, sphereSpeed, col = vec3(0.);\\n    \\n    vec4 sphereCenter;    \\n\\tvec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;\\n\\tvec2 offset;\\n    \\n\\tif( intersectPlane( ro,  rd, 0., dist) ) {\\n        vec3 interSectionPoint = ro + rd * dist;\\n        \\n        \\n        // HMMMMM this is totaly fake. Hopefully I have enough time to find the analytic\\n        // solution to get a motion blurred checkerboard\\n        speed = rot * (interSectionPoint.xyz - ro) + cameraSpeed;   \\n        \\n        vec2 c1 = mod(interSectionPoint.xz * .25, vec2(2.));\\n\\t\\t\\n        float w = (abs( fract(c1.x*abs(rd.x)) -.5 ) + abs( fract(c1.y*abs(rd.y)) -.5 ));        \\n\\n        colBackground = mix(\\n            mod(floor(c1.x) + floor(c1.y), 2.) < 1. ? vec3( 0.4 ) : vec3( .6 ),\\n            vec3(.5), clamp( (w + .8) * .007 * length(speed.xz) * FPS , 0., 1.));\\n            \\n        // calculate shadow\\n        float shadow = 0.;\\n                \\n        vec3 shadowStartPos = interSectionPoint - lig;\\n        vec2 shadowGridPos = floor((ro + rd * dist).xz/GRIDSIZE);\\n        \\n        for( float x=-1.; x<=1.; x++) {\\n            for( float y=-1.; y<=1.; y++) {\\n                vec2 gridpos = (shadowGridPos+vec2(x,y))*GRIDSIZE;\\n                getSphereOffset( gridpos, offset );\\n\\n                getMovingSpherePosition( gridpos, -offset, sphereCenter, sphereSpeed );\\n\\n                vec2 res = iSphere( shadowStartPos, lig, sphereCenter, sphereSpeed + cameraSpeed, nor );\\n                if( res.x>0.0 )\\n                {            \\n                    shadow = clamp( shadow+mix(res.y,0., res.x/MAXSHADOWDISTANCE), 0., 1.);\\n                }\\n\\n                getSpherePosition( gridpos, offset, sphereCenter );\\n\\n                res = iSphere( shadowStartPos, lig, sphereCenter, cameraSpeed, nor );\\n                if( res.x>0.0 )\\n                {            \\n                    shadow = clamp( shadow+mix(res.y,0., res.x/MAXSHADOWDISTANCE), 0., 1.);\\n                }\\n            }\\n        }\\n                \\n        ref = reflect( rd, vec3( 0., 1., 0. ) );\\n        colBackground = shade( dist, colBackground, 1.-shadow, vec3( 0., 1., 0. ), ref, sky );            \\n\\t} else {\\n\\t\\tcolBackground = sky;\\n\\t}\\t\\n\\t\\t\\n\\t// trace grid\\n\\tvec3 ri = 1.0/rd;\\n\\tvec3 rs = sign(rd) * GRIDSIZE;\\n\\tvec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\\n\\tvec3 mm = vec3(0.0);\\n\\t\\t\\n    float alpha = 1.;\\n    \\n\\tfor( int i=0; i<RAYCASTSTEPS; i++ )\\t{  \\n        if( alpha < .01 ) break;\\n        \\n\\t\\tgetSphereOffset( pos.xz, offset );\\n\\t\\t\\n\\t\\tgetMovingSpherePosition( pos.xz, -offset, sphereCenter, sphereSpeed );\\n\\t\\t        \\n        speed = rot * (sphereCenter.xyz - ro) + sphereSpeed + cameraSpeed;\\n        vec2 res = iSphere( ro, rd, sphereCenter, speed, nor );\\n        if( res.x>0.0 )\\n        {            \\n       \\t\\tref = reflect( rd, nor );\\n            vec3  lcol = shade( res.x, getSphereColor(-offset), 1., nor, ref, sky);\\n            col += lcol * res.y * alpha;\\n            alpha *= (1.-res.y);\\n        }        \\n                \\n\\t\\tgetSpherePosition( pos.xz, offset, sphereCenter );\\n        \\n        speed = rot * (sphereCenter.xyz - ro) + cameraSpeed;        \\n\\t\\tres = iSphere( ro, rd, sphereCenter, speed, nor );\\n        if( res.x>0.0 )\\n        {            \\n       \\t\\tref = reflect( rd, nor );\\n            vec3  lcol = shade( res.x, getSphereColor(-offset), 1., nor, ref, sky);\\n            col += lcol * res.y * alpha;\\n            alpha *= (1.-res.y);\\n        }\\n        \\n\\t\\tmm = step(dis.xyz, dis.zyx);\\n\\t\\tdis += mm * rs * ri;\\n\\t\\tpos += mm * rs;\\t\\t\\n\\t}\\t\\n    \\n    col += colBackground * alpha;\\n    \\n\\treturn col;\\n}\\n\\nvoid path( in float time, out vec3 ro, out vec3 ta ) {\\n\\tro = vec3( 16.0*cos(0.2+0.5*.4*time*1.5) * SPEED, 5.6+3.*sin(time), 16.0*sin(0.1+0.5*0.11*time*1.5) * SPEED);\\n    time += 1.6;\\n\\tta = vec3( 16.0*cos(0.2+0.5*.4*time*1.5) * SPEED, -.1 + 2.*sin(time), 16.0*sin(0.1+0.5*0.11*time*1.5) * SPEED);\\n}\\n\\nmat3 setCamera(in float time, out vec3 ro )\\n{\\n    vec3 ta;\\n    \\n    path(time, ro, ta);\\n\\tfloat roll = -0.15*sin(.732*time);\\n    \\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(roll), cos(roll), 0.);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 q = fragCoord.xy/iResolution.xy;\\n\\tvec2 p = -1.0+2.0*q;\\n\\tp.x *= iResolution.x/iResolution.y;\\n\\t\\n\\t// camera\\t\\n\\tvec3 ro0, ro1, ta;\\n    \\n    mat3 ca0 = setCamera( time - 1./FPS, ro0 );\\n\\tvec3 rd0 = ca0 * normalize( vec3(p.xy,2.0) );\\n\\n    mat3 ca1 = setCamera( time, ro1 );\\n\\tvec3 rd1 = ca1 * normalize( vec3(p.xy,2.0) );\\n\\t        \\n    mat3 rot = ca1 * mat3( ca0[0].x, ca0[1].x, ca0[2].x,\\n                           ca0[0].y, ca0[1].y, ca0[2].y,\\n                           ca0[0].z, ca0[1].z, ca0[2].z);\\n    \\n    rot -= mat3( 1,0,0, 0,1,0, 0,0,1);\\n    \\n\\t// raytrace\\t\\n\\tvec3 col = render(ro0, rd0, ro1-ro0, rot );\\n\\t\\n\\tcol = pow( col, vec3(0.5) );\\n\\t\\n\\tfragColor = vec4( col,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Ms2fDh","date":"1500332532","viewed":1280,"name":"[SH17A] Metaballs","description":"3D metaballs in 280 chars.","likes":14,"published":"Public API","usePreview":0,"tags":["metaballs","2t","sh17a"]},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [SH17A] Metaballs. Created by Reinder Nijhoff 2017\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/Ms2fDh\\n//\\n\\nvoid mainImage( out vec4 f, vec2 g ) {\\n\\tvec3 n=iResolution,r=vec3(g,1)/n-.5,p=n-n;\\n\\tp.z -= 4.;   \\n\\tfor(int i=64;i-->0;){ \\n\\t\\tfloat s=1.,j=0.,b=p.y+2.,h; \\n\\t\\tfor(;++j<7.;) \\n            h=clamp(.5+.5*(b-s),0.,1.),\\n            s=mix(b,s,h)-h*(1.-h),\\n            b=length(p-1.3*sin(j*99.*n+iTime))-.4; \\n\\t\\tp+=r*s;\\n\\t\\t}   \\n\\tf=texture(iChannel0,p)*2./dot(p,p);\\t\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldjBW1","date":"1500332665","viewed":3814,"name":"[SH17A] Matrix rain","description":"Matrix rain. View in full screen.","likes":56,"published":"Public API","usePreview":0,"tags":["matrixrain","sh17a"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [SH17A] Matrix rain. Created by Reinder Nijhoff 2017\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/ldjBW1\\n//\\n\\n#define R fract(1e2*sin(p.x*8.+p.y))\\nvoid mainImage(out vec4 o,vec2 u) {\\n    vec3 v=vec3(u,1)/iResolution-.5,\\n        s=.5/abs(v),\\n        i=ceil(8e2*(s.z=min(s.y,s.x))*(s.y<s.x?v.xzz:v.zyz)),\\n        j=fract(i*=.1),\\n        p=vec3(9,int(iTime*(9.+8.*sin(i-=j).x)),0)+i;\\n   o-=o,o.g=R/s.z;p*=j;o*=R>.5&&j.x<.6&&j.y<.8?1.:0.;\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Xs2Bzy","date":"1500968542","viewed":2912,"name":"[SH17B] Legend of the Gelatinous","description":"Legend of the Gelatinous Cube\\n\\nCollect all keys and escape the dungeons filled with gelatinous cubes.\\n\\n- Arrow keys: move\\n- Space: fight & open doors.","likes":31,"published":"Public API","usePreview":0,"tags":["game","raymarch","voxel","dungeon","crawler"]},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Legend of the Gelatinous Cube. Created by Reinder Nijhoff 2017\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/Xs2Bzy\\n//\\n// I created this shader in one long night for the Shadertoy Competition 2017\\n// \\n\\n// RENDER THE DUNGEON AND ADD UI FROM BUFFER B\\n\\n#define MAXSTEPS 8\\nconst int MOVESTEPS = 60;\\nconst int USERMOVESTEPS = 30;\\nconst int USERROTATESTEPS = 30;\\nconst int DOORMOVESTEPS = 30;\\nconst int MAXSWORD = 30;\\nconst int REDFLASHSTEPS = 15;\\n\\nconst int NONE = 0;\\nconst int FORWARD = 1;\\nconst int BACK = 2;\\nconst int ROT_LEFT = 3;\\nconst int ROT_RIGHT = 4;\\nconst int ACTION = 5;\\n\\nvec3 USERRD = vec3(0);\\n\\nconst ivec2 DIRECTION[] = ivec2[] (\\n    ivec2(0,1),\\n    ivec2(1,0),\\n    ivec2(0,-1),\\n    ivec2(-1,0)\\n);\\n\\n#define HASHSCALE1 .1031\\nfloat hash12(vec2 p)\\n{\\n\\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\nfloat hash13(vec3 p3)\\n{\\n\\tp3  = fract(p3 * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\nvec3 rotate(vec3 r, float v){ return vec3(r.x*cos(v)+r.z*sin(v),r.y,r.z*cos(v)-r.x*sin(v));}\\n\\nvec2 boxIntersection(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\\n\\n    vec3 m = 1.0/rd;\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*boxSize;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),\\n                 min( min( t2.x, t2.y ), t2.z ) );\\n\\t\\n    if( !(time.y>time.x && time.y>0.0) ) return vec2(-1);\\n    \\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n    return time;\\n}\\n\\nivec4 m(ivec2 uv) {\\n    return ivec4(texelFetch(iChannel0, uv + ivec2(32,0), 0));\\n}\\n\\nivec4 w(ivec2 uv) {\\n    return ivec4( texelFetch(iChannel0, uv, 0) );\\n}\\n\\n\\n//----------------------------------------------------------------------\\n// Material helper functions\\n\\n#define COL(r,g,b) vec3(r/255.,g/255.,b/255.)\\n\\nfloat onLine( const float c, const float b ) {\\n\\treturn clamp( 1.-abs(b-c), 0., 1. );\\n}\\nfloat onBand( const float c, const float mi, const float ma ) {\\n\\treturn clamp( (ma-c+1.), 0., 1. )*clamp( (c-mi+1.), 0., 1. );\\n}\\nfloat onRect( const vec2 c, const vec2 lt, const vec2 rb ) {\\n\\treturn onBand( c.x, lt.x, rb.x )*onBand( c.y, lt.y, rb.y );\\n}\\nvec3 addBevel( const vec2 c, const vec2 lt, const vec2 rb, const float size, const float strength, const float lil, const float lit, const vec3 col ) {\\n\\tfloat xl = clamp( (c.x-lt.x)/size, 0., 1. ); \\n\\tfloat xr = clamp( (rb.x-c.x)/size, 0., 1. );\\t\\n\\tfloat yt = clamp( (c.y-lt.y)/size, 0., 1. ); \\n\\tfloat yb = clamp( (rb.y-c.y)/size, 0., 1. );\\t\\n\\n\\treturn mix( col, col*clamp(1.0+strength*(lil*(xl-xr)+lit*(yb-yt)), 0., 2.), onRect( c, lt, rb ) );\\n}\\nfloat stepeq( float a, float b ) { \\n\\treturn step( a, b )*step( b, a );\\n}\\n//----------------------------------------------------------------------\\n// Generate materials!\\n\\nvoid decorateWall(in vec2 uv, const float decorationHash, inout vec3 col ) {\\t\\n\\tvec3 fgcol;\\n\\t\\n\\tuv = floor( mod(uv+64., vec2(64.)) );\\n\\tvec2 uvs = uv / 64.;\\n\\t\\n\\t// basecolor\\n\\tvec3 basecol = col;\\t\\n\\tfloat br = hash12(uv);\\n\\n\\t\\n// prison door\\t\\n\\tif( decorationHash > 0.95 ) {\\t\\n\\t\\tvec4 prisoncoords = vec4(12.,14.,52.,62.);\\n\\t// shadow\\n\\t\\tcol *= 1.-0.5*onRect( uv,  vec2( 11., 13. ), vec2( 53., 63. ) );\\n\\t// hinge\\n\\t\\tcol = mix( col, COL(72.,72.,72.), stepeq(uv.x, 53.)*step( mod(uv.y+2.,25.), 5.)*step(13.,uv.y) );\\n\\t\\tcol = mix( col, COL(100.,100.,100.), stepeq(uv.x, 53.)*step( mod(uv.y+1.,25.), 3.)*step(13.,uv.y) );\\n\\t\\t\\n\\t\\tvec3 pcol = vec3(0.)+COL(100.,100.,100.)*step( mod(uv.x-4., 7.), 0. ); \\n\\t\\tpcol += COL(55.,55.,55.)*step( mod(uv.x-5., 7.), 0. ); \\n\\t\\tpcol = addBevel(uv, vec2(0.,17.), vec2(63.,70.), 3., 0.8, 0., -1., pcol);\\n\\t\\tpcol = addBevel(uv, vec2(0.,45.), vec2(22.,70.), 3., 0.8, 0., -1., pcol);\\n\\t\\t\\n\\t\\tfgcol = COL(72.,72.,72.);\\n\\t\\tfgcol = addBevel(uv, prisoncoords.xy, prisoncoords.zw+vec2(1.,1.), 1., 0.5, -1., 1., fgcol );\\n\\t\\tfgcol = addBevel(uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(2.,1.), 1., 0.5, 1., -1., fgcol );\\n\\t\\tfgcol = mix( fgcol, pcol, onRect( uv, prisoncoords.xy+vec2(3.,3.), prisoncoords.zw-vec2(3.,2.) ) );\\n\\t\\tfgcol = mix( fgcol, COL(72.,72.,72.), onRect( uv, vec2(15.,32.5), vec2(21.,44.) ) );\\n\\t\\t\\n\\t\\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.) ), stepeq(uv.x, 15.)*step(37.,uv.y)*step(uv.y,38.) );\\n\\t\\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(43.,43.,43.), (uv.y-37.)/3. ), stepeq(uv.x, 17.)*step(37.,uv.y)*step(uv.y,40.) );\\n\\t\\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 18.)*step(37.,uv.y)*step(uv.y,41.) );\\n\\t\\tfgcol = mix( fgcol, mix( COL(0.,0.,0.), COL(100.,100.,100.), (uv.y-37.)/3. ), stepeq(uv.x, 18.)*step(36.,uv.y)*step(uv.y,40.) );\\n\\t\\tfgcol = mix( fgcol, COL(43.,43.,43.), stepeq(uv.x, 19.)*step(37.,uv.y)*step(uv.y,40.) );\\n\\n\\t\\tfgcol = mix( fgcol, mix( COL(84.,84.,84.), COL(108.,108.,108.), (uv.x-15.)/2. ), stepeq(uv.y, 32.)*step(15.,uv.x)*step(uv.x,17.) );\\n\\t\\tfgcol = mix( fgcol, COL(81.,81.,81.), stepeq(uv.y, 32.)*step(20.,uv.x)*step(uv.x,21.) );\\n\\n\\t\\tcol = mix( col, fgcol, onRect( uv, prisoncoords.xy, prisoncoords.zw ) );\\n\\t}\\t\\n// fake 8-bit color palette and dithering\\t\\n\\tcol = floor( (col+0.5*mod(uv.x+uv.y,2.)/32.)*32.)/32.;\\n}\\n\\n// store functions\\n\\nivec4 LoadVec4( in ivec2 vAddr ) {\\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\\n}\\n\\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\\n\\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\\n}\\n\\n// map\\n\\nvec4 debugMap( in vec2 fragCoord ) {\\n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\\n   \\tivec2 uv = ivec2(fragCoord.xy * .1);\\n    vec4 col = vec4(1);\\n    if( uv.x < 32 && uv.y < 32 ) {\\n        vec4 wall = texelFetch(iChannel0, uv, 0);\\n        vec4 monster = texelFetch(iChannel0, uv+ivec2(32,0),0);\\n        \\n        if( wall.x > 0. ) col.rgb = vec3(0,0,0);\\n        if( wall.x > 1. ) col.rgb = vec3(0,1,0);\\n        if( wall.x > 2. ) col.rgb = vec3(0,0,1);\\n        if( wall.x > 5. ) col.rgb = vec3(0,1,1);\\n        if( monster.x > 0. ) col.rgb = vec3( monster.y<0.?1.:.5,0,0);\\n    }\\n    if( uv.x == ud1.x && uv.y == ud1.y ) col = vec4(1,0,1,1);\\n    return col;\\n}\\n\\n// draw level\\n\\nvec4 drawSword( vec2 uv, int level ) {\\n    uv = floor(fract(uv)*64.) - 32.;\\n    if( abs(uv.x) < 16. && abs(uv.y) < 16. ) {\\n        float l = step(abs(uv.y), .5); \\n        l = max(l, step(abs(uv.y), 1.5) * step(uv.x, 13.));   \\n        l = max(l, step(abs(uv.y), 5.5) * step(abs(uv.x+9.), 1.));\\n                        \\n\\t    vec3 col = mix( vec3(.8), vec3(.5,.3,.2), step(uv.x, -11.));\\n        vec3 scol = mix( vec3(.5,.3,.2), vec3(1.), clamp(float(level) / float(MAXSWORD/2), 0., 1.) );\\n        scol = mix( scol, vec3(0.,.9, 1.), clamp(float(level-MAXSWORD/2) / float(MAXSWORD/2), 0., 1.) );\\n        col = mix( scol, col, step(uv.x, -8.));        \\n        \\n        return vec4( 2. * l * (.5 + .5 * texture(iChannel1, uv/64.).x) * col, l );\\n    } else {\\n        return vec4(0);\\n    }\\n}\\n\\nvec4 drawKey( vec2 uv, int color ) {\\n    uv = floor(fract(uv)*64.) - 32.;\\n    if( abs(uv.x) < 16. && abs(uv.y) < 16. ) {\\n        float l = step(abs(uv.y), 1.);\\n        l = max(l, step(length(uv+vec2(8,0)), 7.5));\\n        l -= step(length(uv+vec2(8,0)), 4.5);\\n        l = max(l, step(6.,uv.x)*step(uv.x, 7.)*step(0.,uv.y)*step(abs(uv.y), 5.));\\n        l = max(l, step(10.,uv.x)*step(uv.x, 11.)*step(0.,uv.y)*step(abs(uv.y), 7.));\\n        l = max(l, step(14.,uv.x)*step(0.,uv.y)*step(abs(uv.y), 6.));\\n        \\n\\t    vec3 col = vec3(0);\\n    \\tcol[color-7] = 1.;\\n        return vec4( 2. * l * (.5 + .5 * texture(iChannel1, uv/64.).x) * col, l );\\n    } else {\\n        return vec4(0);\\n    }\\n}\\n\\nvec4 drawLock( vec2 uv, int color ) {\\n    uv = floor(fract(uv)*64.) - 32.;\\n    if( abs(uv.x) < 6. && abs(uv.y) < 8. ) {\\n        float l = 1.;\\n        l -= smoothstep( 3., 2., length(uv+vec2(0,2.5)));\\n        l = min( l, 1.-step(abs(uv.x),.5)*step(abs(uv.y), 5.));\\n\\t    vec3 col = vec3(0);\\n    \\tcol[color-3] = 1.;\\n        return vec4( l * (.5 + .5 * texture(iChannel1, uv/64.).x) * col, 1 );\\n    } else {\\n        return vec4(0);\\n    }\\n}\\n\\nvec4 drawHealth( vec2 uv ) {\\n    uv = floor(fract(uv)*64.) - 32.;\\n    if( abs(uv.x) < 12. && abs(uv.y) < 12. ) {\\n        vec4 col = vec4( 1,1,1, smoothstep( 10., 9., length(uv)) );\\n        col.rgb = mix( col.rgb, vec3(1,0,0), step(abs(uv.y), 1.)*step(abs(uv.x),7.) );\\n        col.rgb = mix( col.rgb, vec3(1,0,0), step(abs(uv.y), 7.)*step(abs(uv.x),1.) );\\n        return vec4( 2.*col.rgb * (.5 + .5 * texture(iChannel1, uv/64.).x), col.a );\\n    } else {\\n        return vec4(0);\\n    }\\n}\\n\\n\\nvec3 getLight( vec3 pos, float d, vec3 nor ) {\\n    return vec3(0.,0.05, 0.2) * smoothstep(0., 6., d) * smoothstep(6., 5.5, d) + // fog\\n        (0.5 + 0.4*dot(nor, -USERRD)) \\n        * (1. + .025*sin(iTime * 20. + cos(iTime*10.))) * vec3(1., .9, .6) * clamp(7./(d*d)-.1, 0., 1.);\\n}\\n\\nvoid getCeilingColor( const vec3 ro, const vec3 rd, inout vec3 col ) {\\n\\tfloat d = -(ro.y-1.)/rd.y;\\n\\tvec3 pos = ro + rd * d;\\n    col = texture(iChannel1, floor(pos.xz*64.)/64.,0.).rgb * vec3(.5, .4, .3);\\n    col *= getLight(pos, d, vec3(0,-1,0)) * .8;\\n}\\n\\nvoid getFloorColor( const vec3 ro, const vec3 rd, inout vec3 col ) {\\n\\tfloat d = -(ro.y)/rd.y;\\n\\tvec3 pos = ro + rd * d;\\n    col = texture(iChannel1, floor(pos.xz*64.)/64.,0.).rgb * vec3(.5, .4, .3) * 1.2;\\n    \\n    ivec4 map = w(ivec2(pos.xz));\\n    if( map.x > 8 ) {\\n        vec4 s = drawHealth(pos.xz);\\n        col = mix(col, s.rgb, s.a);\\n    } else if( map.x > 6 ) { // key\\n        vec4 s = drawKey( pos.xz, map.x );\\n        col = mix( col, s.rgb, s.a);\\n    } else if( map.x > 5 ) {\\n        vec4 s = drawSword( pos.xz, map.z );\\n        col = mix( col, s.rgb, s.a);\\n    }\\n    \\n    col *= getLight(pos, d, vec3(0,1,0));\\n}\\n\\nbool getMapColorForPosition( \\n    const vec3 ro, const vec3 rd, const vec3 vos, \\n    const vec3 pos, const vec3 nor, const float t, in ivec4 map, inout vec3 col ) {\\n    \\n    if( map.x > 1) {\\n        if( map.x < 6 ) {\\n        // a door is hit\\n            float h = .95*min(float(map.w),float(DOORMOVESTEPS))/float(DOORMOVESTEPS);\\n            vec3 mpos = vec3( vos.x+.5, .5+h, vos.z+.5);\\n            vec3 nn;\\n            vec3 dim = map.y == 1 ? vec3(.025, .5, .5) : vec3(.5, .5, .025 );\\n            vec2 intersect = boxIntersection(ro - mpos, rd, dim, nn);\\n            vec3 p = ro + rd * intersect.x;\\n\\n            if( intersect.x > 0. && p.y < 1.) {\\n                vec2 i = map.y == 1 ? p.yz : p.yx; \\n                i.x -= h;\\n                vec2 uv = floor(i*64.);\\n                col = (.2+.5*texture(iChannel1,uv/64.,0.).rgb) * vec3(1.,.6, .4);\\n                col.rgb *= .5 + .5*step( 1., mod(uv.y, 8.) );\\n                if( map.x > 2) {\\n                \\tvec4 s = drawLock( -i.yx, map.x );\\n                \\tcol = mix( col, s.rgb, s.a);\\n                }\\n                col *= getLight(p, intersect.x, nn);         \\n                return true;\\n            }\\n        }\\n        return false;\\n    } else {    \\n \\t\\tif( pos.y <= 1. && pos.y >= 0. ) {\\n\\t    // a wall is hit\\n        \\tvec2 mpos = vec2( dot(vec3(-nor.z,0.0,nor.x),pos), -pos.y );\\n            vec2 uv = floor(mpos*64.);\\n        \\tcol = texture(iChannel2, uv/64.,0.).rgb * .7;  \\n            decorateWall( uv, hash12(vos.xz), col.rgb );        \\n        \\tcol *= getLight(vos, t, vec3(nor.x,0,nor.z));\\n        \\treturn true;\\n    \\t}\\n    }\\n    return false;\\n}\\n\\nbool getMonsterColorForPosition( \\n    const vec3 ro, const vec3 rd, const vec3 vos, \\n    const vec3 pos, const vec3 nor, const float t, inout vec3 col,\\n\\tivec4 monster ) {\\n    \\n    vec3 mpos = vec3( vos.x+.5, .5, vos.z+.5);\\n    if( monster.y != 0 ) {\\n\\t    mpos.xz += float(monster.y)/float(MOVESTEPS) * vec2(DIRECTION[monster.z-1]);\\n    }\\n    \\n    vec3 nn;\\n    vec3 roo = ro-mpos+ sin(rd*1e2+5.*iTime)*.0025;\\n    vec3 rdd = rd + sin(rd*70.+iTime)*.01;\\n    \\n    float size = .2 + .025*smoothstep( 0., 30., float(monster.w));\\n    \\n    vec2 intersect = boxIntersection(roo, rdd, vec3(size), nn);\\n    if( intersect.x > 0.) {\\n       col = mix( vec3(.5,0,0), vec3(0,1,0), float(monster.w)/30.);\\n       col.b = .5+.5*sin(iTime);\\n       vec3 i = intersect.x*rd+ro-mpos;\\n       vec2 texUV;\\n       if( abs(nn.x) > .5 ) {\\n           texUV = i.yz;\\n       } else {\\n           texUV = i.xy;           \\n       }\\n       texUV += vec2(sin(iTime*5.+20.*texUV.y),cos(iTime*4.+20.*texUV.x))*.01;\\n       col *= .5 +.5*texture(iChannel1, floor(texUV*64.)/64.,0.).x;\\n        float hl = hash13( floor(vec3(texUV*64.,iTime+hash12(floor(texUV*64.)))));\\n       col += .2 * hl * hl * hl;\\n       col = mix( col, normalize(i)*.5+.5, .25);\\n       col *= getLight(intersect.x*rd+ro, intersect.x, nn) *(.5 + smoothstep(4., 1., intersect.x) * .1/dot(i,i));\\n       return true;\\n    }\\n    \\n    return false;\\n}\\n\\nbool castRay( const vec3 ro, const vec3 rd, inout vec3 col ) {\\n\\tvec3 pos = floor(ro);\\n\\tvec3 ri = 1.0/rd;\\n\\tvec3 rs = sign(rd);\\n\\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\\n\\t\\n\\tfloat res = 0.0;\\n\\tvec3 mm = vec3(0.0);\\n\\tbool hit = false;\\n\\t\\n\\tfor( int i=0; i<MAXSTEPS; i++ )\\t{\\n\\t\\tmm = step(dis.xyz, dis.zyx);\\n\\t\\tdis += mm * rs * ri;\\n        pos += mm * rs;\\t\\t\\n        \\n\\t\\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\\n\\t\\tfloat t = max ( mini.x, mini.z );\\t\\n        \\n        ivec4 map = w(ivec2(pos.xz));\\n        \\n        \\n        vec3 h = ro + rd*t;     \\n        if( h.y > 1. || h.y < 0. ) {\\n            if( rd.y < 0. ) {\\n                getFloorColor(ro, rd, col);\\n            } else {\\n                getCeilingColor(ro, rd, col);\\n            }\\n            return true;\\n        }\\n        \\n\\t\\tif( map.x > 0 ) { \\t\\t\\n\\t\\t\\thit = getMapColorForPosition( ro, rd, pos, ro+rd*t, -mm*sign(rd), t, map, col );\\n        }\\n        ivec4 monster = m(ivec2(pos.xz));\\n        if( monster.x > 0 && !hit) { \\t\\t\\n\\t\\t\\thit = getMonsterColorForPosition( ro, rd, pos, ro+rd*t, -mm*sign(rd), t, \\n                                                  col, monster );\\n        }\\n        if( hit ) return true;\\n\\t}\\n\\treturn hit;\\n}\\n\\nvec4 render(in vec2 fragCoord) {\\n    float time = iTime;\\n    vec2 q = fragCoord.xy / iResolution.xy;\\n    vec2 p = -1.0 + 2.0*q;\\n    p.x *= iResolution.x/ iResolution.y;\\n\\t\\n\\tvec3 ro = vec3( mod(iTime, 31.) + 1.,.5, mod(iTime*1.1, 31.) + 1. );\\n    \\n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\\n    \\n    vec2 USERCOORD = vec2(ud1.xy);\\n    int USERDIR = ud1.z;\\n    int actionCount = ud1.w;\\n    int action = ud2.x;\\n \\n    vec3 dir = vec3(DIRECTION[USERDIR].x, 0, DIRECTION[USERDIR].y);\\n    \\n    ro = vec3(USERCOORD.x + .5, .5, USERCOORD.y + .5 );\\n    float angle = 0.;\\n    \\n    if( action == FORWARD ) {\\n        float progress = float(actionCount)/float(USERMOVESTEPS);\\n        ro -= dir * progress;\\n    }\\n\\tif( action == BACK ) {\\n        float progress = float(actionCount)/float(USERMOVESTEPS);\\n        ro += dir * progress;\\n    }\\n    if( action == ROT_RIGHT ) {\\n        float progress = float(actionCount)/float(USERROTATESTEPS);\\n        angle = -progress * 1.57079632679;\\n    }\\n    if( action == ROT_LEFT ) {\\n        float progress = float(actionCount)/float(USERROTATESTEPS);\\n        angle = progress * 1.57079632679;\\n    }\\n    \\n    \\n    vec3 rd = rotate( dir, angle );\\n    USERRD = rd;\\n    rd.y -= 0.025;\\n    vec3 uu = normalize(cross( vec3(0.,1.,0.), rd ));\\n    vec3 vv = normalize(cross(rd,uu));\\n    rd = normalize( p.x*uu + p.y*vv + 2.25*rd );\\n    \\n\\tvec3 col = vec3(0.);\\n    castRay( ro, rd, col );\\n    return vec4(col,1);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 col = debugMap( fragCoord );\\n    col = render( fragCoord );\\n   // col = mix( col, debugMap( fragCoord ), .5);\\n    \\n    int flash = ivec4( texelFetch( iChannel3, ivec2(0), 0 ) ).y;\\n    \\n    col.rgb = mix( col.rgb, vec3(1,0,0), float(flash) / 120. );\\n    \\n    vec4 ui = texture(iChannel3, fragCoord/iResolution.xy);    \\n    col = mix( col, ui, min(1.,ui.a) );\\n    \\n\\tfragColor = col;\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Legend of the Gelatinous Cube. Created by Reinder Nijhoff 2017\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/Xs2Bzy\\n//\\n// I created this shader in one long night for the Shadertoy Competition 2017\\n// \\n\\n// GAME LOGIC\\n\\nconst int MOVESTEPS = 60;\\nconst int USERMOVESTEPS = 30;\\nconst int USERROTATESTEPS = 30;\\nconst int USERACTIONSTEPS = 30;\\nconst int DOORMOVESTEPS = 30;\\nconst int DOOROPENSTEPS = 300;\\nconst int MAXSWORD = 30;\\n\\nconst ivec2 DIRECTION[] = ivec2[] (\\n    ivec2(0,1),\\n    ivec2(1,0),\\n    ivec2(0,-1),\\n    ivec2(-1,0)\\n);\\n\\nivec2 USERCOORD = ivec2(0);\\nivec2 USERACTIONCOORD = ivec2(0);\\nint USERDIR = 0;\\nint USERACTION = 0;\\nint USERACTIONCOUNT = 0;\\nivec4 USERINV = ivec4(0);\\n\\nconst int NONE = 0;\\nconst int FORWARD = 1;\\nconst int BACK = 2;\\nconst int ROT_LEFT = 3;\\nconst int ROT_RIGHT = 4;\\nconst int ACTION = 5;\\n\\n\\n#define HASHSCALE1 .1031\\nfloat hash12(vec2 p)\\n{\\n\\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\n// store functions\\n\\n\\nivec4 LoadVec4( in ivec2 vAddr ) {\\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\\n}\\n\\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\\n\\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\\n}\\n\\nvoid StoreIVec4( in ivec2 vAddr, in ivec4 vValue, inout ivec4 fragColor, in ivec2 fragCoord ) {\\n    fragColor = AtAddress( fragCoord, vAddr ) ? ivec4(vValue) : fragColor;\\n}\\n\\n// key functions\\n\\n// Keyboard constants definition\\nconst int KEY_SPACE = 32;\\nconst int KEY_LEFT  = 37;\\nconst int KEY_UP    = 38;\\nconst int KEY_RIGHT = 39;\\nconst int KEY_DOWN  = 40;\\nconst int KEY_A     = 65;\\nconst int KEY_D     = 68;\\nconst int KEY_S     = 83;\\nconst int KEY_W     = 87;\\n\\n\\nbool KP(int key) {\\n\\treturn texelFetch( iChannel2, ivec2(key, 0), 0 ).x > 0.0;\\n}\\n\\nbool KT(int key) {\\n\\treturn texelFetch( iChannel2, ivec2(key, 2), 0 ).x > 0.0;\\n}\\n\\n\\n// map functions\\n\\nivec4 createStatic(int level, ivec2 coord) {\\n    ivec4 data = ivec4(0);\\n    if( coord.x < 32 ) { // static data\\n        // create walls\\n  \\t\\tint wall = 1-int(step(texelFetch(iChannel1, coord, 0).x,.575));\\n    \\tif( coord.x % 31 == 0 || coord.y % 31 == 0) wall = 1;\\n        data = ivec4(wall,0,0,0);\\n\\n        if( wall == 0 ) {\\n            float hash = hash12( vec2(coord*9) );\\n            // swords\\n            if( hash > .96) {\\n                data = ivec4( 6, 0, 1 + \\n                       int( max(0., .35*( hash12( vec2(coord.yx) ) * 32. + float(coord.x) + float(coord.y)) )), 0 );\\n            }\\n            if( hash < .05 ) {\\n                data = ivec4(10, 0, 8 + (coord.x+coord.y)/10, 0);\\n            }\\n        }\\n\\n        \\n        // doors\\n        StoreIVec4( ivec2( 2, 9), ivec4(2,2,0,0), data, coord);\\n        StoreIVec4( ivec2( 8,16), ivec4(2,2,0,0), data, coord);\\n        StoreIVec4( ivec2( 9, 8), ivec4(2,2,0,0), data, coord);\\n        StoreIVec4( ivec2(24, 9), ivec4(2,2,0,0), data, coord);\\n        StoreIVec4( ivec2(17,15), ivec4(2,2,0,0), data, coord);\\n        StoreIVec4( ivec2(24,13), ivec4(2,2,0,0), data, coord);\\n        StoreIVec4( ivec2(14, 3), ivec4(2,2,0,0), data, coord);\\n        \\n        StoreIVec4( ivec2(10, 5), ivec4(2,1,0,0), data, coord);\\n        StoreIVec4( ivec2( 3,13), ivec4(2,1,0,0), data, coord);        \\n        \\n        \\n        StoreIVec4( ivec2( 3,21), ivec4(3,2,0,0), data, coord); // red door\\n        StoreIVec4( ivec2(17,18), ivec4(4,2,0,0), data, coord); // blue door\\n        StoreIVec4( ivec2(20,24), ivec4(5,1,0,0), data, coord);\\n        \\n        // data\\n        \\n        StoreIVec4( ivec2( 2, 2), ivec4(6,0,5,0), data, coord); // sword\\n        \\n        StoreIVec4( ivec2( 6,11), ivec4(7,0,1,0), data, coord); // red key\\n        StoreIVec4( ivec2( 2,26), ivec4(8,0,1,0), data, coord); // blue key\\n        StoreIVec4( ivec2(29,16), ivec4(9,0,1,0), data, coord); // blue key \\n    }\\n    return data;\\n}\\n\\nivec4 createMonsters(int level, ivec2 coord ) {\\n    ivec4 data = ivec4(0);\\n    if (coord.x < 64 ) { // monsters\\n        coord -= ivec2(32,0);\\n        \\n        if( createStatic( level, coord ).x < 1 &&\\n\\t\\t\\thash12( vec2(coord) ) > (1. - float(coord.x) * .005 - float(coord.y) * .005) ) {\\n            data.x = 1;\\n            data.w = 5 + (coord.x+coord.y)/2;\\n        }\\n    }\\n    \\n    return data;\\n}\\n\\nivec4 createMap(int level, ivec2 coord) {\\n    if( coord.x < 32 ) {\\n    \\treturn createStatic(0, coord);\\n    } else {\\n    \\treturn createMonsters(0, coord);\\n    }\\n}\\n\\nivec4 m(ivec2 uv) {\\n    return ivec4(texelFetch(iChannel0, uv + ivec2(32,0), 0));\\n}\\n\\nivec4 w(ivec2 uv) {\\n    return ivec4( texelFetch(iChannel0, uv, 0) );\\n}\\n\\nbool isMonster(ivec4 data) {\\n    return data.x > 0;\\n}\\n\\nbool monsterIsMoving(ivec4 data) {\\n    return abs(data.y) > 0;\\n}\\n\\nbool isEmpty(ivec2 coord) {\\n    // return true;\\n    ivec4 wall = w(coord);\\n    ivec4 monster = m(coord);\\n    \\n    return !isMonster(monster) &&\\n        (wall.x < 1 ||  // no wall or\\n        (wall.x > 1 && wall.z == 1) || // open door\\n        wall.x > 5) // swords and keys\\n        && !(coord.x == USERCOORD.x && coord.y == USERCOORD.y);\\n}\\n\\nivec4 updateMap(int level, ivec2 coord) {\\n    ivec4 data = w(coord);\\n    if (coord.y > 32 || coord.x > 64 ) return data;\\n    \\n    \\n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\\n    USERINV = LoadVec4( ivec2(2,32 ) );\\n        \\n    USERCOORD = ud1.xy;\\n    USERDIR = ud1.z;\\n\\tUSERACTIONCOUNT = ud1.w;\\n    \\n    USERACTIONCOORD = USERCOORD + DIRECTION[USERDIR];\\n\\tUSERACTION = ud2.x;\\n        \\n    int SWORD = USERINV[0];\\n    \\n    bool tryaction = USERACTIONCOUNT == USERACTIONSTEPS &&\\n                  USERACTION == ACTION;\\n    \\n    if (coord.x < 32 ) { // static data\\n        bool action = tryaction &&\\n                      coord.x == USERACTIONCOORD.x && coord.y == USERACTIONCOORD.y;\\n        \\n        if( data.x == 1 ) {\\n            // wall\\n        } else if( data.x > 1 && data.x < 6 ) { // door\\n            if( action ) {\\n                // try to open door\\n                if( data.x == 2 || USERINV[data.x-2] > 0) {                \\n                \\tdata.z = 1;\\n               \\t \\tdata.w == 0;\\n                }\\n            }\\n            if( data.z > 0 ) {\\n                data.w ++;\\n                if( data.w > DOOROPENSTEPS ) {\\n                    // try to close the door\\n                    if( isEmpty(coord) ) {\\n                        data.z = 0;\\n                        data.w = DOORMOVESTEPS;\\n                    }\\n                }\\n            } else {\\n                data.w = max(data.w-1, 0);\\n            }\\n        } else if( data.x > 5 && coord.x == USERCOORD.x && coord.y == USERCOORD.y) { // item - pick up\\n            data = ivec4(0);\\n        }\\n    } else { // monsters\\n        coord -= ivec2(32,0);\\n        bool action = tryaction &&\\n                      coord.x == USERACTIONCOORD.x && coord.y == USERACTIONCOORD.y;\\n        \\n        if( isMonster(data) ) { // monster, move if possible\\n            if( action ) {\\n                data.w -= int(hash12( vec2(iTime) ) * float(SWORD) + 1.);\\n                if( data.w < 0 ) {\\n                    data = ivec4(0);\\n                }\\n            } if( monsterIsMoving(data) ) {\\n                if( data.y > 1 ) {\\n                    ivec4 check = m(coord + DIRECTION[data.z-1]);\\n                    if( check.z == data.z ) {\\n                        data.y ++;\\n                        if( data.y > MOVESTEPS ) {\\n                            data = ivec4(0);\\n                        }\\n                    } else {\\n                        data.y = 0;\\n                        data.z = 0;\\n                    }\\n                } else {\\n                   data.y ++;\\n                }\\n            } else if( abs(coord.x-USERCOORD.x)+abs(coord.y-USERCOORD.y) == 1 ) {\\n                // attack!\\n            } else {\\n                // try to move - multiple times\\n                float userDistance = distance( vec2(coord), vec2(USERCOORD));\\n                for(int i=0; i<4; i++) {\\n                    int d = int(hash12(vec2(coord) + iTime + float(i)) * 4.);\\n                    ivec2 dir = DIRECTION[d];\\n                    if( isEmpty( coord + dir ) ) {\\n                        data.z = d + 1;\\n                        data.y = 1;\\n                        \\n                        if( userDistance < 5. &&\\n                            distance( vec2(coord+dir),vec2(USERCOORD)) < userDistance ) {\\n                            i=100;\\n                        }\\n                    }\\n                }\\n            }\\n        } else { // check if a monster moves to this spot\\n            for(int i=0; i<4; i++) {\\n                ivec4 check = m( coord - DIRECTION[i] );\\n                if(check.z == i + 1 && check.y > 0) {\\n                    data.x = check.x;\\n                    data.y = -MOVESTEPS;\\n                    data.z = check.z;\\n                    data.w = check.w;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return data;\\n}\\n\\n// game logic\\n\\nvoid gameSetup( int level, inout vec4 fragColor, in ivec2 coord ) {\\n    StoreVec4( ivec2(0,32 ), ivec4(4,1,3,0), fragColor, coord );\\n    StoreVec4( ivec2(1,32 ), ivec4(0,0,60,0), fragColor, coord );\\n    StoreVec4( ivec2(2,32 ), ivec4(0,0,0,0), fragColor, coord );\\n    StoreVec4( ivec2(3,32 ), ivec4(0), fragColor, coord );\\n}\\n\\nvoid gameLoop( inout vec4 fragColor, in ivec2 coord ) {\\n    if( coord.y > 33 || coord.y < 32 ) return;\\n    if( coord.x > 16 ) return;\\n    \\n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\\n    ivec4 ud3 = LoadVec4( ivec2(2,32 ) );\\n    \\n    USERCOORD = ud1.xy;\\n    USERDIR = ud1.z;\\n    int actionCount = ud1.w;\\n    \\n    int action = ud2.x;\\n    int newAction = ud2.y;\\n    int live = ud2.z;\\n    \\n    USERINV = ud3;\\n    \\n    if( actionCount > 0 ) {\\n        actionCount --;\\n    }\\n    \\n    if( KP(KEY_UP) || KP(KEY_W) ) {\\n        newAction = FORWARD;\\n    }\\n    if( KP(KEY_DOWN) || KP(KEY_S) ) {\\n        newAction = BACK;\\n    }\\n    if( KP(KEY_LEFT) || KP(KEY_A) ) {\\n        newAction = ROT_LEFT;\\n    }\\n    if( KP(KEY_RIGHT) || KP(KEY_D) ) {\\n        newAction = ROT_RIGHT;\\n    }\\n    if( KP(KEY_SPACE) ) {\\n        newAction = ACTION;\\n    }\\n    \\n    if( actionCount > 8 ) {\\n        newAction = NONE;\\n    }\\n    \\n    if( actionCount == 0 ) {\\n        action = newAction;\\n        newAction = NONE;\\n        \\n        if( action == FORWARD ) {\\n            if( isEmpty( USERCOORD + DIRECTION[USERDIR] ) ) {\\n                USERCOORD += DIRECTION[USERDIR];\\n                actionCount = USERMOVESTEPS;\\n            }\\n        }\\n        if( action == BACK ) {\\n            if( isEmpty( USERCOORD - DIRECTION[USERDIR] ) ) {\\n                USERCOORD -= DIRECTION[USERDIR];\\n                actionCount = USERMOVESTEPS;\\n            }\\n        }\\n        if( action == ROT_RIGHT ) {\\n            USERDIR = (USERDIR + 1) % 4;\\n            actionCount = USERROTATESTEPS;\\n        }\\n        if( action == ROT_LEFT ) {\\n            USERDIR = (USERDIR + 3) % 4;\\n            actionCount = USERROTATESTEPS;\\n        }\\n        if( action == ACTION ) {\\n            actionCount = USERACTIONSTEPS;\\n        }\\n    }\\n    \\n    // store data\\n    ud1.xy = USERCOORD;\\n    ud1.z = USERDIR;\\n    ud1.w = actionCount;\\n    \\n    ud2.x = action;\\n    ud2.y = newAction;\\n    \\n    ivec4 map = w(USERCOORD);\\n    if( map.x > 9 ) {\\n        live += map.z;\\n    \\tStoreVec4( ivec2(3,32 ), ivec4(map.x,map.z,0,0), fragColor, coord );\\n    } else if( map.x > 5 ) {\\n        // item\\n        USERINV[ map.x-6 ] = max( USERINV[ map.x-6], map.z );\\n    \\tStoreVec4( ivec2(3,32 ), ivec4(map.x,map.z,0,0), fragColor, coord );\\n    } else {\\n    \\tStoreVec4( ivec2(3,32 ), ivec4(0), fragColor, coord );\\n    }        \\n    \\n    \\n    if( live > 120 ) {\\n        live = 120;\\n    }\\n    \\n    for(int i=0; i<4; i++) {\\n        ivec2 c = USERCOORD + DIRECTION[i];\\n        ivec4 mo = m(c);\\n        if( isMonster(mo) && mo.y == 0 ) {\\n            if( hash12( vec2(c)+iTime ) > .993 - float(mo.w)*.0007 ) {\\n                live -= 2+int(hash12( vec2(c)-iTime ) * (float(mo.w) + 5.));\\n            }\\n        }\\n    }\\n    \\n    ud2.z = live;\\n    if( live < 0 ) {\\n        ud2.w = 1;\\n    \\tStoreVec4( ivec2(3,32 ), ivec4(-1), fragColor, coord );\\n    }\\n        \\n    StoreVec4( ivec2(0,32 ), ud1, fragColor, coord );\\n    StoreVec4( ivec2(1,32 ), ud2, fragColor, coord );\\n    StoreVec4( ivec2(2,32 ), USERINV, fragColor, coord );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n\\tivec2 uv = ivec2(fragCoord.xy);\\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\\n    \\n\\tint wall = 1-int(step(texelFetch(iChannel1, ivec2(2,1), 0).x,.575));\\n    \\n    if( ud2.w > 0 || wall != w(ivec2(2,1)).x ) {\\n    \\tfragColor = vec4(createMap(0, uv));\\n        gameSetup(0, fragColor, ivec2(fragCoord) );\\n    } else {\\n        fragColor = vec4(updateMap(0, uv));\\n        gameLoop( fragColor, ivec2(fragCoord) );\\n    }    \\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Legend of the Gelatinous Cube. Created by Reinder Nijhoff 2017\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/Xs2Bzy\\n//\\n// I created this shader in one long night for the Shadertoy Competition 2017\\n// \\n\\n// UI CODE\\n\\nconst int USERACTIONSTEPS = 30;\\nconst int MAXSWORD = 30;\\nconst int REDFLASHSTEPS = 60;\\n\\nconst int NONE = 0;\\nconst int FORWARD = 1;\\nconst int BACK = 2;\\nconst int ROT_LEFT = 3;\\nconst int ROT_RIGHT = 4;\\nconst int ACTION = 5;\\n\\nivec4 LoadVec4( in ivec2 vAddr ) {\\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\\n}\\n\\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\\n\\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\\n}\\n\\nvoid StoreIVec4( in ivec2 vAddr, in ivec4 vValue, inout ivec4 fragColor, in ivec2 fragCoord ) {\\n    fragColor = AtAddress( fragCoord, vAddr ) ? ivec4(vValue) : fragColor;\\n}\\n\\nvoid StoreIVec4B( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\\n}\\n\\nivec4 LoadVec4B( in ivec2 vAddr ) {\\n    return ivec4( texelFetch( iChannel2, vAddr, 0 ) );\\n}\\n\\n\\n// FONT RENDER CODE\\n//\\n// copied from https://www.shadertoy.com/view/MtyXDV\\n\\nvec2 uv = vec2(0.0);  // -1 .. 1\\n\\n//== font handling ================================================\\n\\n#define FONT_SPACE 0.5\\n\\nvec2 tp = vec2(0.0);  // text position\\nconst vec2 vFontSize = vec2(8.0, 15.0);  // multiples of 4x5 work best\\n\\n//----- access to the image of ascii code characters ------\\n\\n#define SPACE tp.x-=FONT_SPACE;\\n#define _     tp.x-=FONT_SPACE;\\n\\n#define S(a) c+=char(a);  tp.x-=FONT_SPACE;\\n\\n#define _note  S(10);   //\\n#define _star  S(28);   // *\\n#define _smily S(29);   // :-)        \\n#define _exc   S(33);   // !\\n#define _add   S(43);   // +\\n#define _comma S(44);   // ,\\n#define _sub   S(45);   // -\\n#define _dot   S(46);   // .\\n#define _slash S(47);   // /\\n\\n#define _0 S(48);\\n#define _1 S(49);\\n#define _2 S(50);\\n#define _3 S(51);\\n#define _4 S(52);\\n#define _5 S(53);\\n#define _6 S(54);\\n#define _7 S(55);\\n#define _8 S(56);\\n#define _9 S(57);\\n#define _ddot S(58);   // :\\n#define _sc   S(59);   // ;\\n#define _less S(60);   // <\\n#define _eq   S(61);   // =\\n#define _gr   S(62);   // >\\n#define _qm   S(63);   // ?\\n#define _at   S(64);   // at sign\\n\\n#define _A S(65);\\n#define _B S(66);\\n#define _C S(67);\\n#define _D S(68);\\n#define _E S(69);\\n#define _F S(70);\\n#define _G S(71);\\n#define _H S(72);\\n#define _I S(73);\\n#define _J S(74);\\n#define _K S(75);\\n#define _L S(76);\\n#define _M S(77);\\n#define _N S(78);\\n#define _O S(79);\\n#define _P S(80);\\n#define _Q S(81);\\n#define _R S(82);\\n#define _S S(83);\\n#define _T S(84);\\n#define _U S(85);\\n#define _V S(86);\\n#define _W S(87);\\n#define _X S(88);\\n#define _Y S(89);\\n#define _Z S(90);\\n\\n#define _a S(97);\\n#define _b S(98);\\n#define _c S(99);\\n#define _d S(100);\\n#define _e S(101);\\n#define _f S(102);\\n#define _g S(103);\\n#define _h S(104);\\n#define _i S(105);\\n#define _j S(106);\\n#define _k S(107);\\n#define _l S(108);\\n#define _m S(109);\\n#define _n S(110);\\n#define _o S(111);\\n#define _p S(112);\\n#define _q S(113);\\n#define _r S(114);\\n#define _s S(115);\\n#define _t S(116);\\n#define _u S(117);\\n#define _v S(118);\\n#define _w S(119);\\n#define _x S(120);\\n#define _y S(121);\\n#define _z S(122);\\n   \\nfloat char(int ch) {\\n  vec4 f = any(lessThan(vec4(tp,1,1), vec4(0,0,tp))) \\n               ? vec4(0) \\n               : texture(iChannel3,0.0625*(tp + vec2(ch - ch/16*16,15 - ch/16)));  \\n  return f.x;\\n}\\n\\nvoid SetTextPosition(float x, float y)  //\\n{\\n  tp = 10.0*uv;\\n  tp.x = tp.x - x;\\n  tp.y = tp.y - y;\\n}\\n                                                                                                        \\nfloat drawInt(int value, int minDigits)\\n{\\n  float c = 0.;\\n  if (value < 0) \\n  { value = -value;\\n    if (minDigits < 1) minDigits = 1;\\n    else minDigits--;\\n    _sub                   // add minus char\\n  } \\n  int fn = value, digits = 1; // get number of digits \\n  for (int ni=0; ni<10; ni++)\\n  {\\n    fn /= 10;\\n    if (fn == 0) break;\\n    digits++;\\n  } \\n  digits = max(minDigits, digits);\\n  tp.x -= FONT_SPACE * float(digits);\\n  for (int ni=1; ni < 11; ni++) \\n  { \\n    tp.x += FONT_SPACE; // space\\n    c += char(48 + (value-((value/=10)*10))); // add 0..9 \\n    if (ni >= digits) break;\\n  } \\n  tp.x -= FONT_SPACE * float(digits);\\n  return c;\\n}\\n\\nfloat drawInt(int value) {return drawInt(value,1);}\\n\\n\\nvoid updateText(  inout vec4 color, vec2 coord ) {\\n    uv = (2.*coord/iResolution.y-1.);\\n    if( abs(uv.y) < .2 ) {\\n        ivec4 data = LoadVec4(ivec2(3,32));\\n        \\n        if( data.x > 0 ) {\\n\\t\\t   SetTextPosition(2.5,-0.5);   \\n\\t\\t   float c = 0.0;\\n\\t\\t   _Y _o _u _ _f _o _u _n _d _ \\n                \\n           if( data.x == 6 ) {    \\n              _a _ _n _e _w _ _s _w _o _r _d _ _add\\n\\t\\t\\t    c += drawInt(data.y);  \\n           } else if( data.x == 10 ) {\\n                _f _o _o _d _ _add\\n\\t\\t\\t    c += drawInt(data.y);  \\n           } else {\\n               _a _\\n               if( data.x == 7 ) {\\n                   _R _e _d\\n               }\\n               else if( data.x == 8 ) {\\n                   _G _r _e _e _n\\n               }\\n               else if( data.x == 9 ) {\\n                   _B _l _u _e\\n               }\\n               _ _K _e _y\\n           }\\n\\t\\t   color = vec4(1,1,1,min(2.,c * 2.));\\n        } else if( data.x < 0 ) {   \\n\\t\\t   SetTextPosition(2.5,-0.5);\\n\\t\\t   float c = 0.0;\\n           _Y _o _u _ _d _i _e _d\\n\\t\\t   color = vec4(1,1,1,min(2.,c * 2.));               \\n        } else {\\n           color = texelFetch(iChannel2, ivec2(coord),0); \\n           color.a = max(0., color.a - 1./60.);\\n        }         \\n    }\\n}\\n\\n\\n// UI ELEMENTS\\n\\nvec4 drawSword( vec2 uv, int level ) {\\n    uv = floor(fract(uv)*32.) - 16.;\\n        float l = step(abs(uv.y), .5); \\n        l = max(l, step(abs(uv.y), 1.5) * step(uv.x, 13.));   \\n        l = max(l, step(abs(uv.y), 5.5) * step(abs(uv.x+9.), 1.));\\n                        \\n\\t    vec3 col = mix( vec3(.8), vec3(.5,.3,.2), step(uv.x, -11.));\\n        vec3 scol = mix( vec3(.5,.3,.2), vec3(1.), clamp(float(level) / float(MAXSWORD/2), 0., 1.) );\\n        scol = mix( scol, vec3(0.,.9, 1.), clamp(float(level-MAXSWORD/2) / float(MAXSWORD/2), 0., 1.) );\\n        col = mix( scol, col, step(uv.x, -8.));        \\n        \\n        return vec4( l * (.75 + .25 * texture(iChannel1, uv/64.).x) * col, l );\\n}\\n\\nvec4 drawKey( vec2 uv, int color ) {\\n    uv = floor(fract(uv)*32.) - 16.;\\n        float l = step(abs(uv.y), 1.);\\n        l = max(l, step(length(uv+vec2(8,0)), 7.5));\\n        l -= step(length(uv+vec2(8,0)), 4.5);\\n        l = max(l, step(6.,uv.x)*step(uv.x, 7.)*step(0.,uv.y)*step(abs(uv.y), 5.));\\n        l = max(l, step(10.,uv.x)*step(uv.x, 11.)*step(0.,uv.y)*step(abs(uv.y), 7.));\\n        l = max(l, step(14.,uv.x)*step(0.,uv.y)*step(abs(uv.y), 6.));\\n        \\n\\t    vec3 col = vec3(0);\\n    \\tcol[color] = 1.;\\n        return vec4( l * (.75 + .25 * texture(iChannel1, uv/64.).x) * col, l );\\n\\n}\\n\\nvoid drawKeyIcon( vec2 lt, vec2 size, inout vec4 color, vec2 coord, int keyColor ) {\\n    coord = (coord-lt) / size;\\n    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    \\n\\t\\tvec4 col = drawKey(-coord, keyColor);\\n        color = mix( color, col, col.a );\\n    }\\n}\\n\\n\\nvoid drawSwordIcon( vec2 lt, vec2 size, inout vec4 color, vec2 coord, int level ) {\\n    coord = (coord-lt) / size;\\n    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    \\n\\t\\tvec4 col = drawSword(coord, level);\\n        color = mix( color, col, col.a );\\n    }\\n}\\n\\n\\nvoid drawSwordIconLarge( vec2 lt, vec2 size, inout vec4 color, vec2 coord, int level ) {\\n    coord = (coord-lt) / size;\\n    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    \\n\\t\\tvec4 col = drawSword(coord.yx, level);\\n        color = mix( color, col, col.a );\\n    }\\n}\\n\\nvoid drawLifeBar(  vec2 lt, vec2 size, inout vec4 color, vec2 coord, int level ) {\\n     coord = (coord-lt) / size;\\n    if( coord.x >= 0. && coord.x <= 1. && coord.y >= 0. && coord.y <= 1. ) {    \\n\\t\\tvec4 col = mix(vec4(.5,0,0,1), vec4(.5,1,0,1), float(level)/60.);  \\n\\t\\tcol = mix(col, vec4(0,1,0,1), float(level-60)/60.);\\n        col = mix( vec4(0,0,0,.6), col, step( 120. * coord.x,  float(level) ));\\n        col.rgb *= (.75 + .5 * texture(iChannel1, coord/vec2(8.,64.)).x);\\n        color = mix( color, col, col.a );\\n    }   \\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec2 res = iResolution.xy;\\n    \\n    ivec4 ud1 = LoadVec4( ivec2(0,32 ) );\\n    ivec4 ud2 = LoadVec4( ivec2(1,32 ) );\\n    ivec4 USERINV = LoadVec4( ivec2(2,32 ) );\\n        \\n\\tint USERACTIONCOUNT = ud1.w;\\n    int USERACTION = ud2.x;\\n    \\n    fragColor = vec4(0);\\n\\n    float iconSize = res.y*.1;\\n    \\n    if( USERINV[0] > 0) {\\n       drawSwordIcon( vec2( res.x - iconSize*1.5, .125*iconSize ), vec2(iconSize), fragColor, fragCoord, USERINV[0] );\\n    }\\n    \\n    for( int i=0; i<3; i++) {\\n        if( USERINV[i+1] > 0 ) {\\n            drawKeyIcon( vec2( res.x - (float(i)*1.2+2.7)*iconSize, .125*iconSize  ), vec2(iconSize), fragColor, fragCoord, i);\\n        }\\n    }\\n    if( USERACTION == ACTION && USERACTIONCOUNT > 0 && USERINV[0] > 0) {\\n       float h = smoothstep(0., 1., abs(float(USERACTIONCOUNT-USERACTIONSTEPS/2-10)/float(USERACTIONSTEPS/2))) + .4;\\n       float size = res.y * .5; \\n        \\n       drawSwordIconLarge( vec2( res.x * .5 - size*.5, -h*size ), vec2(size), fragColor, fragCoord, USERINV[0] );\\n    }\\n    drawLifeBar( vec2(iconSize * .5, .375*iconSize), vec2( iconSize*6., iconSize*.25), fragColor, fragCoord, ud2.z );\\n    \\n    updateText( fragColor, fragCoord );\\n    \\n    \\n    ivec4 bd = LoadVec4B( ivec2(0,0) );\\n    if( bd.x > ud2.z ) {\\n        bd.y = REDFLASHSTEPS;\\n    }\\n    bd.y--;\\n    if( bd.y < 0 ) bd.y = 0;\\n    bd.x = ud2.z;\\n    \\n    StoreIVec4B( ivec2(0,0), bd, fragColor, ivec2(fragCoord) );\\n}","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4dSBz3","date":"1501424191","viewed":5057,"name":"Super simple raymarching example","description":"Please have a look at the [url=https://www.shadertoy.com/view/4dSfRc]tutorial[/url].","likes":38,"published":"Public API","usePreview":0,"tags":["raymarching","example","simple","distance","fields","sh17c"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Super simple raymarching example. Created by Reinder Nijhoff 2017\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/4dSBz3\\n//\\n// This is the shader used as example in my ray march tutorial: https://www.shadertoy.com/view/4dSfRc\\n//\\n// Created for the Shadertoy Competition 2017 \\n//\\n\\n//\\n// Distance field function for the scene. It combines\\n// the seperate distance field functions of three spheres\\n// and a plane using the min-operator.\\n//\\nfloat map(vec3 p) {\\n    float d = distance(p, vec3(-1, 0, -5)) - 1.;     // sphere at (-1,0,5) with radius 1\\n    d = min(d, distance(p, vec3(2, 0, -3)) - 1.);    // second sphere\\n    d = min(d, distance(p, vec3(-2, 0, -2)) - 1.);   // and another\\n    d = min(d, p.y + 1.);                            // horizontal plane at y = -1\\n    return d;\\n}\\n\\n//\\n// Calculate the normal by taking the central differences on the distance field.\\n//\\nvec3 calcNormal(in vec3 p) {\\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\\n    return normalize(\\n        e.xyy * map(p + e.xyy) +\\n        e.yyx * map(p + e.yyx) +\\n        e.yxy * map(p + e.yxy) +\\n        e.xxx * map(p + e.xxx));\\n}\\n\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    vec3 ro = vec3(0, 0, 1);                           // ray origin\\n\\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\\n    vec3 rd = normalize(vec3(q, 0.) - ro);             // ray direction for fragCoord.xy\\n\\n    // March the distance field until a surface is hit.\\n    float h, t = 1.;\\n    for (int i = 0; i < 256; i++) {\\n        h = map(ro + rd * t);\\n        t += h;\\n        if (h < 0.01) break;\\n    }\\n\\n    if (h < 0.01) {\\n        vec3 p = ro + rd * t;\\n        vec3 normal = calcNormal(p);\\n        vec3 light = vec3(0, 2, 0);\\n        \\n        // Calculate diffuse lighting by taking the dot product of \\n        // the light direction (light-p) and the normal.\\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\\n\\t\\t\\n        // Multiply by light intensity (5) and divide by the square\\n        // of the distance to the light.\\n        dif *= 5. / dot(light - p, light - p);\\n        \\n        \\n        fragColor = vec4(vec3(pow(dif, 0.4545)), 1);     // Gamma correction\\n    } else {\\n        fragColor = vec4(0, 0, 0, 1);\\n    }\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dSfRc","date":"1501424188","viewed":34159,"name":"[SH17C] Raymarching tutorial","description":"The shader used as example in this tutorial can be found [url=https://www.shadertoy.com/view/4dSBz3]here[/url].\\n\\nYou can navigate the slides using your arrow keys.","likes":409,"published":"Public API","usePreview":1,"tags":["raymarching","tutorial","distance","fields","sh17c"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/4dSfRc\\n//\\n// In this tutorial you will learn how to render a 3d-scene in Shadertoy\\n// using distance fields.\\n//\\n// The tutorial itself is created in Shadertoy, and is rendered\\n// using ray marching a distance field.\\n//\\n// The shader studied in the tutorial can be found here: \\n//     https://www.shadertoy.com/view/4dSBz3\\n//\\n// Created for the Shadertoy Competition 2017 \\n//\\n// Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\\n//\\n// You can find this shader here:\\n//     https://www.shadertoy.com/view/Xds3zN\\n//\\n\\n// COMPOSITE IMAGE\\n\\n#define SLIDE_FADE_STEPS 60\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    int SLIDE_STEPS_VISIBLE = int(texelFetch( iChannel0, ivec2(0,0), 0 ).y);\\n    \\n    vec4 current = texelFetch(iChannel1, ivec2(fragCoord), 0);\\n    vec4 prev    = texelFetch(iChannel2, ivec2(fragCoord), 0);\\n    vec4 font    = texelFetch(iChannel3, ivec2(fragCoord), 0);\\n\\n\\tfragColor = mix( prev, current, clamp( float(SLIDE_STEPS_VISIBLE)/float(SLIDE_FADE_STEPS), 0., 1.) );\\n    fragColor = mix( fragColor * .75, font, font.a );\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/4dSfRc\\n//\\n// In this tutorial you will learn how to render a 3d-scene in Shadertoy\\n// using distance fields.\\n//\\n// The tutorial itself is created in Shadertoy, and is rendered\\n// using ray marching a distance field.\\n//\\n// The shader studied in the tutorial can be found here: \\n//     https://www.shadertoy.com/view/4dSBz3\\n//\\n// Created for the Shadertoy Competition 2017 \\n//\\n// Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\\n//\\n// You can find this shader here:\\n//     https://www.shadertoy.com/view/Xds3zN\\n//\\n\\n// SLIDE NAVIGATION FUNCTIONS\\n\\n// Load & store functions\\n\\n#define SLIDE_FADE_STEPS 45\\n\\n#define TITLE_DELAY   45\\n#define BODY_DELAY   90\\n#define CODE_DELAY   135\\n#define FOOTER_DELAY 180\\n\\n#define NUM_SLIDES 25\\n\\nint SLIDE = 0;\\nint SLIDE_STEPS_VISIBLE = 0;\\n\\nivec4 LoadVec4( in ivec2 vAddr ) {\\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\\n}\\n\\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\\n\\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\\n}\\n\\nvec4 LoadFVec4( in ivec2 vAddr ) {\\n    return texelFetch( iChannel0, vAddr, 0 );\\n}\\n\\nvoid StoreFVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\\n}\\n\\n// key functions\\n\\n// Keyboard constants definition\\nconst int KEY_SPACE = 32;\\nconst int KEY_LEFT  = 37;\\nconst int KEY_UP    = 38;\\nconst int KEY_RIGHT = 39;\\nconst int KEY_DOWN  = 40;\\nconst int KEY_A     = 65;\\nconst int KEY_D     = 68;\\nconst int KEY_S     = 83;\\nconst int KEY_W     = 87;\\n\\n\\nbool KP(int key) {\\n\\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\\n}\\n\\nbool KT(int key) {\\n\\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\\n}\\n\\n// slide logic\\n\\nstruct SlideDataStruct {\\n    int title;\\n    int titleDelay;\\n    int body;\\n    int bodyDelay;\\n    int code;\\n    int codeDelay;\\n    vec3 ro;\\n    vec3 ta;\\n    int sceneMode;\\n    int codeS;\\n    int codeE;\\n    int distMode;\\n};\\n\\nSlideDataStruct temp;\\nint tempCounter;\\n\\nbool createSlideData( \\n    const int title,\\n    const int titleDelay,\\n    const int body,\\n    const int bodyDelay,\\n    const int code,\\n    const int codeDelay,\\n    const vec3 ro,\\n    const vec3 ta,\\n    const int sceneMode,\\n    const int codeS,\\n    const int codeE,\\n\\tconst int distMode ) {\\n        \\n    if(tempCounter == SLIDE) {\\n        temp.title = title;\\n  \\t  \\ttemp.titleDelay = titleDelay;\\n   \\t \\ttemp.body = body;\\n   \\t \\ttemp.bodyDelay =bodyDelay;\\n   \\t \\ttemp.code = code;\\n   \\t\\ttemp.codeDelay =codeDelay;\\n   \\t\\ttemp.ro = ro;\\n   \\t\\ttemp.ta = ta;\\n   \\t \\ttemp.sceneMode = sceneMode;\\n  \\t \\ttemp.codeS = codeS;\\n  \\t  \\ttemp.codeE = codeE;\\n\\t\\ttemp.distMode = distMode;\\n        return true;\\n    } else {\\n    \\ttempCounter++;\\n        return false;\\n    }\\n}\\n\\nSlideDataStruct getSlideData() {\\n    tempCounter = 0;\\n    \\n    // intro\\n   if( createSlideData(1,TITLE_DELAY,1,BODY_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), 0, 0, 0, 0) ) return temp;\\n\\n    // intro - show bw scene\\n   if( createSlideData(1,0,2,0,0,0, vec3(.0,0.,1.), vec3(0.,0.,-5.), -1, 0, 0, 0)) return temp;\\n    \\n    // create a ray - origin\\n   if( createSlideData(2,TITLE_DELAY,3,BODY_DELAY,0,0, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 1, 0, 0, 0)) return temp;\\n        \\n    // create a ray - origin / code    \\n   if( createSlideData(2,0,4,0,1,TITLE_DELAY, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 1, 1, 3, 0)) return temp;\\n    \\n    // place screen\\n   if( createSlideData(2,0,5,TITLE_DELAY,0,0, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 2, 0, 0, 0)) return temp;\\n    \\n    // create rd\\n   if( createSlideData(2,0,6,TITLE_DELAY,0,0, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\\n\\n\\t// create rd / code\\n   if( createSlideData(2,0,7,0,1,TITLE_DELAY, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 3, 0, 0)) return temp;\\n   \\n    // interact with scene\\n   if( createSlideData(2,0,8,0,0,0, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 3, 0, 0)) return temp;\\n    \\n    // distance fields intro\\n   if( createSlideData(3,TITLE_DELAY,9,BODY_DELAY,0,0, vec3(1.,6.,2.),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\\n    \\n    // distance fields def\\n   if( createSlideData(3,0,10,TITLE_DELAY,0,0, vec3(1.,6.,2.),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\\n        \\n    // distance fields one sphere\\n   if( createSlideData(3,TITLE_DELAY,11,BODY_DELAY,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 0, 0)) return temp;\\n    \\n     // distance fields one sphere\\n   if( createSlideData(3,0,11,0,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 0, 1)) return temp;\\n      \\n    // distance fields one sphere - code\\n   if( createSlideData(3,0,12,0,2,TITLE_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 3, 1)) return temp;\\n    \\n    // distance fields one three spheres\\n   if( createSlideData(3,0,13,TITLE_DELAY,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 5, 2)) return temp;\\n    \\n    // distance fields one three spheres - in code\\n   if( createSlideData(3,0,14,0,2,TITLE_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 5, 2)) return temp;\\n    \\n    // distance fields one three spheres - full code\\n   if( createSlideData(3,0,15,TITLE_DELAY,2,BODY_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 0, 3)) return temp;\\n        \\n    // distance fields one three spheres - march\\n   if( createSlideData(3,0,16,TITLE_DELAY,0,0, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 5, 0, 0, 4)) return temp;\\n    \\n    // distance fields one three spheres - march code\\n   if( createSlideData(3,0,17,0,3,TITLE_DELAY, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 5, 0, 0, 4)) return temp;\\n        \\n    // distance fields one three spheres - interact\\n   if( createSlideData(3,0,8,TITLE_DELAY,0,0, vec3(.5,2.,2.5),vec3(0.,0.2,-.3), 5, 0, 0, 4)) return temp;\\n\\n    // lighting - normal intro\\n   if( createSlideData(4,TITLE_DELAY,18,BODY_DELAY,0,0, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\\n\\n   // lighting - normal full\\n   if( createSlideData(4,0,19,TITLE_DELAY,4,BODY_DELAY, vec3(4.5,3.,-1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\\n\\n   // lighting - interact\\n   if( createSlideData(4,0,8,TITLE_DELAY,0,0, vec3(4.5,3.,-1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\\n\\n   // lighting - diffuse\\n   if( createSlideData(4,0,20,TITLE_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), 0, 0, 0, 0)) return temp;\\n\\n   // lighting - diffuse\\n   if( createSlideData(4,0,21,0,5,TITLE_DELAY, vec3(.0,0.,1.),vec3(0.,0.,-.5), -1, 0, 0, 0)) return temp;\\n \\n   // done\\n   if( createSlideData(1,TITLE_DELAY,22,BODY_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), -1, 0, 0, 0)) return temp;\\n \\n    \\n    return temp;\\n}\\n    \\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\\n{\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n\\tvec3 oc = ro - sph.xyz;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - sph.w*sph.w;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return 10000.0;\\n\\treturn -b - sqrt( h );\\n}\\n\\nfloat iPlane(in vec3 ro, in vec3 rd, in float d) {\\n\\t// equation of a plane, y=0 = ro.y + t*rd.y\\n    return -(ro.y+d)/rd.y;\\n}\\n\\nvec3 intersectScene( vec3 ro, vec3 ta, vec2 p,  bool intersectPlane ) {    \\n    mat3 ca = setCamera( ro, ta, 0.0 );\\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\\n    \\n    float d = 1000.;\\n    // sphere intersections ..\\n    if( intersectPlane ) {\\n\\t    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 0.));\\n    } else {\\n    \\td = min( d, sphIntersect( ro, rd, vec4(-1,0,-5,1) ));\\n   \\t\\td = min( d, sphIntersect( ro, rd, vec4(2,0,-3,1) ));\\n  \\t  \\td = min( d, sphIntersect( ro, rd, vec4(-2,0,-2,1) ));\\n\\n\\t    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 1.));\\n    }\\n    \\n    if( d < 100. ) {\\n        return ro + d*rd;\\n    } else {\\n        return vec3(-1,0,-4);\\n    }\\n}\\n    \\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tivec2 uv = ivec2(fragCoord.xy);\\n    \\n    // wait for font-texture to load\\n    if( iFrame == 0 || texelFetch(iChannel2, ivec2(0,0), 0).b < .1) {\\n        vec4 ro = vec4(0,0,1,0);\\n\\t\\tvec4 ta = vec4(0);\\n        \\n\\t\\tStoreFVec4( ivec2(0,0), vec4(0), fragColor, uv);\\n\\t\\tStoreFVec4( ivec2(0,3), ro, fragColor, uv);\\n\\t\\tStoreFVec4( ivec2(0,4), ta, fragColor, uv);\\n    } else if( uv.x < 2 && uv.y < 6) {\\n        ivec4 slideData = LoadVec4( ivec2(0,0) );\\n        SLIDE = slideData.x;\\n        SLIDE_STEPS_VISIBLE = slideData.y;\\n        SLIDE_STEPS_VISIBLE++;\\n\\n        if( SLIDE_STEPS_VISIBLE > 16 ) {\\n            if( KP(KEY_SPACE) || KP(KEY_RIGHT) || KP(KEY_D) ) {\\n                SLIDE++;\\n                SLIDE_STEPS_VISIBLE=0;\\n            }\\n            if( KP(KEY_LEFT) || KP(KEY_W) ) {\\n                SLIDE = (SLIDE + NUM_SLIDES - 1);\\n                SLIDE_STEPS_VISIBLE=0;\\n            }\\n            \\n            SLIDE = SLIDE % NUM_SLIDES; \\n        }\\n        \\n        SlideDataStruct slide = getSlideData();\\n        \\n        // screen resolution\\n        ivec4 res = LoadVec4( ivec2(1,0) );\\n        if( res.x != int(iResolution.x) || res.y != int(iResolution.y) ) {\\n            SLIDE_STEPS_VISIBLE = 0;\\n        }\\n        StoreVec4( ivec2(1,0), ivec4(iResolution.xy, 0,0), fragColor, uv );\\n        \\n\\t\\t// slide navigation               \\n\\t\\tStoreVec4( ivec2(0,0), ivec4(SLIDE, SLIDE_STEPS_VISIBLE, slide.sceneMode, slide.distMode), fragColor, uv);\\n        \\n        // text \\n        ivec4 showText1 = ivec4(0);\\n        ivec4 showText2 = ivec4(0);\\n        \\n        if( SLIDE_STEPS_VISIBLE == 0) showText1.x = 1;\\n        \\n        if( slide.titleDelay == SLIDE_STEPS_VISIBLE) showText2.x = slide.title;\\n        if( slide.bodyDelay == SLIDE_STEPS_VISIBLE) showText2.y = slide.body;\\n        if( slide.codeDelay == SLIDE_STEPS_VISIBLE) showText2.z = slide.code;\\n\\n        showText1.y = slide.codeS;\\n        showText1.z = slide.codeE;\\n        \\n\\t\\tStoreVec4( ivec2(0,1), showText1, fragColor, uv);\\n\\t\\tStoreVec4( ivec2(0,2), showText2, fragColor, uv);\\n        \\n        // camera\\n        \\n        vec4 ro = LoadFVec4( ivec2(0,3) );\\n        vec4 ta = LoadFVec4( ivec2(0,4) );\\n        \\n\\t\\tif(SLIDE_STEPS_VISIBLE > SLIDE_FADE_STEPS) {\\n            ro.xyz = mix( ro.xyz, slide.ro, 0.055 );\\n            ta.xyz = mix( ta.xyz, slide.ta, 0.055 );\\n        }\\n        \\n\\t\\tStoreFVec4( ivec2(0,3), ro, fragColor, uv);\\n\\t\\tStoreFVec4( ivec2(0,4), ta, fragColor, uv);\\n                \\n        if(iMouse.z > 0.) {\\n            vec2 q = (iMouse.xy - .5 * iResolution.xy ) / iResolution.y;\\n\\t\\t\\tStoreFVec4( ivec2(0,5), vec4(intersectScene(ro.xyz, ta.xyz, q, slide.sceneMode == 5),1), fragColor, uv);\\n        } else {\\n\\t\\t\\tStoreFVec4( ivec2(0,5), vec4(intersectScene(vec3(0,0,1), vec3(1,0,0), vec2(0), slide.sceneMode == 5),1), fragColor, uv);\\n        }\\n    } else {  \\n\\t    fragColor = vec4(0);\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/4dSfRc\\n//\\n// In this tutorial you will learn how to render a 3d-scene in Shadertoy\\n// using distance fields.\\n//\\n// The tutorial itself is created in Shadertoy, and is rendered\\n// using ray marching a distance field.\\n//\\n// The shader studied in the tutorial can be found here: \\n//     https://www.shadertoy.com/view/4dSBz3\\n//\\n// Created for the Shadertoy Competition 2017 \\n//\\n// Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\\n//\\n// You can find this shader here:\\n//     https://www.shadertoy.com/view/Xds3zN\\n//\\n\\n// RENDER SCENE\\n\\n\\n// Load & store functions\\n\\n#define SLIDE_FADE_STEPS 60\\n\\nint SLIDE = 0;\\nint SLIDE_STEPS_VISIBLE = 0;\\nint SCENE_MODE = 0;\\nint DIST_MODE = 0;\\nint MAX_MARCH_STEPS;\\n\\nvec3 intersections[7];\\nvec3 intersectionNormal;\\n\\nfloat aspect;\\nvec3 USER_INTERSECT;\\n\\nivec4 LoadVec4( in ivec2 vAddr ) {\\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\\n}\\n\\nvec4 LoadFVec4( in ivec2 vAddr ) {\\n    return texelFetch( iChannel0, vAddr, 0 );\\n}\\n\\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\\n\\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\\n}\\n\\nvoid loadData() {\\n    ivec4 slideData = LoadVec4( ivec2(0,0) );\\n    SLIDE = slideData.x;\\n    SLIDE_STEPS_VISIBLE = slideData.y;\\n    SCENE_MODE = slideData.z;\\n\\tDIST_MODE = slideData.w;\\n}\\n\\n\\n// tutorial Scene\\nfloat tut_map(vec3 p) {\\n    float d = distance(p, vec3(-1, 0, -5)) - 1.;\\n    d = min(d, distance(p, vec3(2, 0, -3)) - 1.);\\n    d = min(d, distance(p, vec3(-2, 0, -2)) - 1.);\\n    d = min(d, p.y + 1.);\\n    return d;\\n}\\n\\nvec3 tut_calcNormal(in vec3 pos) {\\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\\n    return normalize(\\n        e.xyy * tut_map(pos + e.xyy) +\\n        e.yyx * tut_map(pos + e.yyx) +\\n        e.yxy * tut_map(pos + e.yxy) +\\n        e.xxx * tut_map(pos + e.xxx));\\n}\\n\\nvec4 tut_render(in vec2 uv, const int steps) {\\n    vec3 ro = vec3(0, 0, 1);\\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\\n\\n    float h, t = 1.;\\n    for (int i = 0; i < steps; i++) {\\n        h = tut_map((ro + rd * t));\\n        t += h;\\n        if (h < 0.01) break;\\n    }\\n\\n    if (h < 0.01) {\\n        vec3 p = ro + rd * t;\\n        vec3 normal = tut_calcNormal(p);\\n        vec3 light = vec3(0, 2, 0);\\n\\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\\n        dif *= 5. / dot(light - p, light - p);\\n        return vec4(pow(vec3(dif), vec3(1. / 2.2)), 1);\\n    } else {\\n        return vec4(0, 0, 0, 1);\\n    }\\n}\\n\\n//\\n// render full scene\\n//\\n// Most of this is taken from: 'Raymarching - Primitives' by Inigo Quilez.\\n//\\n// You can find this shader here:\\n//     https://www.shadertoy.com/view/Xds3zN\\n//\\n\\n//------------------------------------------------------------------\\n\\nfloat sdPlane( vec3 p, float d ) {\\n\\treturn p.y - d;\\n}\\n\\nfloat sdSphere( vec3 p, float s ) {\\n    return length(p)-s;\\n}\\n\\nfloat sdBox( vec3 p, vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\\n\\tvec3 pa = p-a, ba = b-a;\\n\\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\\n\\treturn length( pa - ba*h ) - r;\\n}\\n\\n//------------------------------------------------------------------\\n\\nvec2 opU( vec2 d1, vec2 d2 ) {\\n\\treturn (d1.x<d2.x) ? d1 : d2;\\n}\\n\\n//------------------------------------------------------------------\\n\\nvec2 map_0( in vec3 pos ) { // basic scene\\n    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),\\n\\t                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );\\n    res = opU( res, vec2( sdSphere(    pos-vec3(2,0,-3),1.), 65. ) );\\n    res = opU( res, vec2( sdSphere(    pos-vec3(-2,0,-2),1.),41. ) );\\n        \\n    return res;\\n}\\n\\nvec2 map_1( in vec3 pos ) { // scene + ro\\n    vec2 res = map_0(pos);\\n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),2. ) );\\n    return res;\\n}\\n\\nvec2 map_2( in vec3 pos ) { // scene + ro + screen\\n    vec2 res = map_0(pos);\\n            \\n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );\\n    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));\\n    return res;\\n}\\n\\nvec2 map_3( in vec3 pos ) { // scene + ro + rd + intersection\\n    vec2 res = map_2(pos);\\n    \\n    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),2. ) );\\n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),2. ) );\\n    \\n    return res;\\n}\\n\\nvec2 map_4( in vec3 pos ) { // scene + ro + one sphere\\n    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),\\n\\t                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );\\n    \\n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );\\n    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));\\n    \\n    return res;\\n}\\n\\nvec2 map_5( in vec3 pos ) { // scene + ro + screen + march steps\\n    vec2 res = map_2(pos);\\n    \\n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );\\n    for( int i=0; i<intersections.length(); i++ ){\\n        if (i <= MAX_MARCH_STEPS) {\\n\\t    \\tres = opU( res, vec2( sdSphere( pos-intersections[i],.1), (i==MAX_MARCH_STEPS)?2.:3. ) );\\n        }\\n    }\\n    \\n    return res;\\n}\\n\\nvec2 map_6( in vec3 pos ) { // scene + ro + rd + intersection + normal\\n    vec2 res = map_2(pos);\\n    \\n    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),3. ) );\\n    res = opU( res, vec2( sdCapsule(    pos, USER_INTERSECT + intersectionNormal, USER_INTERSECT,.025),2. ) );\\n    \\n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );\\n    return res;\\n}\\n\\n\\nvec2 castRay( in vec3 ro, in vec3 rd )\\n{\\n    float tmin = .5;\\n    float tmax = 20.0;\\n       \\n    float t = tmin;\\n    float m = -1.0;\\n\\n    if( SCENE_MODE == 0 ) {\\n        for( int i=0; i<64; i++ )\\n        {\\n            float precis = 0.00005*t;\\n            vec2 res = map_0( ro+rd*t );\\n            if( res.x<precis || t>tmax ) break;\\n            t += res.x;\\n            m = res.y;\\n        }\\n    } else if( SCENE_MODE == 1 ) {\\n        for( int i=0; i<64; i++ )\\n        {\\n            float precis = 0.00005*t;\\n            vec2 res = map_1( ro+rd*t );\\n            if( res.x<precis || t>tmax ) break;\\n            t += res.x;\\n            m = res.y;\\n        }\\n    } else if( SCENE_MODE == 2 ) {\\n        for( int i=0; i<64; i++ )\\n        {\\n            float precis = 0.00005*t;\\n            vec2 res = map_2( ro+rd*t );\\n            if( res.x<precis || t>tmax ) break;\\n            t += res.x;\\n            m = res.y;\\n        }\\n    } else if( SCENE_MODE == 3 ) {\\n        for( int i=0; i<64; i++ )\\n        {\\n            float precis = 0.00005*t;\\n            vec2 res = map_3( ro+rd*t );\\n            if( res.x<precis || t>tmax ) break;\\n            t += res.x;\\n            m = res.y;\\n        }\\n    } else if( SCENE_MODE == 4 ) {\\n        for( int i=0; i<64; i++ )\\n        {\\n            float precis = 0.00005*t;\\n            vec2 res = map_4( ro+rd*t );\\n            if( res.x<precis || t>tmax ) break;\\n            t += res.x;\\n            m = res.y;\\n        }\\n    } else if( SCENE_MODE == 5 ) {\\n        for( int i=0; i<64; i++ )\\n        {\\n            float precis = 0.00005*t;\\n            vec2 res = map_5( ro+rd*t );\\n            if( res.x<precis || t>tmax ) break;\\n            t += res.x;\\n            m = res.y;\\n        }\\n    }  else if( SCENE_MODE == 6 ) {\\n        for( int i=0; i<64; i++ )\\n        {\\n            float precis = 0.00005*t;\\n            vec2 res = map_6( ro+rd*t );\\n            if( res.x<precis || t>tmax ) break;\\n            t += res.x;\\n            m = res.y;\\n        }\\n    } \\n\\n    if( t>tmax ) m=-1.0;\\n    return vec2( t, m );\\n}\\n\\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\\n{\\n\\tfloat res = 1.0;\\n    float t = mint, h;\\n    for( int i=0; i<16; i++ )\\n    {\\n        \\n\\t    if( SCENE_MODE == 0 ) {\\n\\t\\t\\th = map_0( ro + rd*t ).x;\\n    \\t} else if( SCENE_MODE == 1 ) {\\n\\t\\t\\th = map_1( ro + rd*t ).x;\\n    \\t} else if( SCENE_MODE == 2 ) {\\n\\t\\t\\th = map_2( ro + rd*t ).x;\\n   \\t\\t} else if( SCENE_MODE == 3 ) {\\n\\t\\t\\th = map_3( ro + rd*t ).x;\\n   \\t\\t} else if( SCENE_MODE == 4 ) {\\n\\t\\t\\th = map_4( ro + rd*t ).x;\\n   \\t\\t} else if( SCENE_MODE == 5 ) {\\n\\t\\t\\th = map_5( ro + rd*t ).x;\\n   \\t\\t} else if( SCENE_MODE == 6 ) {\\n\\t\\t\\th = map_6( ro + rd*t ).x;\\n   \\t\\t}\\n        \\n        res = min( res, 8.0*h/t );\\n        t += clamp( h, 0.02, 0.10 );\\n        if( h<0.001 || t>tmax ) break;\\n    }\\n    return clamp( res, 0.0, 1.0 );\\n}\\n\\nvec3 calcNormal( in vec3 pos )\\n{\\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\\n    \\n    if( SCENE_MODE == 0 ) {\\n \\t   return normalize( e.xyy*map_0( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map_0( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map_0( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map_0( pos + e.xxx ).x );\\n    } else if( SCENE_MODE == 1 ) {\\n            return normalize( e.xyy*map_1( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map_1( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map_1( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map_1( pos + e.xxx ).x );\\n    } else if( SCENE_MODE == 2 ) {\\n            return normalize( e.xyy*map_2( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map_2( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map_2( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map_2( pos + e.xxx ).x );\\n    } else if( SCENE_MODE == 3 ) {\\n            return normalize( e.xyy*map_3( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map_3( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map_3( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map_3( pos + e.xxx ).x );\\n    } else if( SCENE_MODE == 4 ) {\\n            return normalize( e.xyy*map_4( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map_4( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map_4( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map_4( pos + e.xxx ).x );\\n    } else if( SCENE_MODE == 5 ) {\\n            return normalize( e.xyy*map_5( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map_5( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map_5( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map_5( pos + e.xxx ).x );\\n    } else if( SCENE_MODE == 6 ) {\\n            return normalize( e.xyy*map_6( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map_6( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map_6( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map_6( pos + e.xxx ).x );\\n    }\\n}\\n\\nfloat calcAO( in vec3 pos, in vec3 nor )\\n{\\n\\tfloat occ = 0.0;\\n    float sca = 1.0, dd;\\n    for( int i=0; i<5; i++ )\\n    {\\n        float hr = 0.01 + 0.12*float(i)/4.0;\\n        vec3 aopos =  nor * hr + pos;\\n\\t    if( SCENE_MODE == 0 ) {\\n\\t\\t\\tdd = map_0( aopos ).x;\\n    \\t} else if( SCENE_MODE == 1 ) {\\n\\t\\t\\tdd = map_1( aopos ).x;\\n    \\t} else if( SCENE_MODE == 2 ) {\\n\\t\\t\\tdd = map_2( aopos ).x;\\n   \\t\\t} else if( SCENE_MODE == 3 ) {\\n\\t\\t\\tdd = map_3( aopos ).x;\\n   \\t\\t} else if( SCENE_MODE == 4 ) {\\n\\t\\t\\tdd = map_4( aopos ).x;\\n   \\t\\t} else if( SCENE_MODE == 5 ) {\\n\\t\\t\\tdd = map_5( aopos ).x;\\n   \\t\\t} else if( SCENE_MODE == 6 ) {\\n\\t\\t\\tdd = map_6( aopos ).x;\\n   \\t\\t}\\n        occ += -(dd-hr)*sca;\\n        sca *= 0.95;\\n    }\\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \\n}\\n\\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\\n{\\n    return a + b*cos( 6.28318*(c*t+d) );\\n}\\n\\nvec3 render( in vec3 ro, in vec3 rd )\\n{ \\n    vec3 col = vec3(0.75,0.9,1.0) + max(rd.y*.8,0.);\\n    vec2 res = castRay(ro,rd);\\n    float t = res.x;\\n\\tfloat m = res.y;\\n    if( m>-0.5 )\\n    {\\n        vec3 pos = ro + t*rd;\\n        vec3 nor = calcNormal( pos );\\n        vec3 ref = reflect( rd, nor );\\n        \\n        // material        \\n\\t\\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\\n        if( m<1.5 ) {            \\n            float f = mod( floor(1.0*pos.z) + floor(1.0*pos.x), 2.0);\\n            col = 0.35 + 0.05*f*vec3(1.0);\\n        } else if (m < 2.5 ) {\\n            col = vec3(.5 + .3*sin(iTime*6.28318530718 ),0,0);\\n        } else if (m < 3.5 ) {\\n            col = vec3(.8,0,0);\\n        } else if (m < 4.5 ) {\\n            col = tut_render(pos.xy, 64).rgb;\\n        }\\n\\n        // lighitng        \\n        float occ = calcAO( pos, nor );\\n\\t\\tvec3  lig = normalize( vec3(0.4, 0.7, 0.6) );\\n\\t\\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\\n        float dom = smoothstep( -0.1, 0.1, ref.y );\\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\\n\\t\\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\\n        \\n        dif *= softshadow( pos, lig, 0.02, 2.5 );\\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\\n\\n\\t\\tvec3 lin = vec3(0.0);\\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\\n\\t\\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\\n\\t\\tcol = col*lin;\\n\\n        \\n        if( DIST_MODE > 0 ) {\\n            // intersect with plane;\\n            float d = -(ro.y)/rd.y;\\n            vec3 dint = ro + d*rd;\\n            \\n            float m = sdSphere(dint-vec3(-1,0,-5),1.);\\n            \\n            if( DIST_MODE > 1 ) { \\n                m = min( m, sdSphere(dint-vec3(2,0,-3),1.));\\n                m = min( m, sdSphere(dint-vec3(-2,0,-2),1.));\\n            }\\n            if( DIST_MODE > 2 ) { \\n                m = min( m, dint.y + 1.);\\n            }\\n            vec3 dcol = vec3(abs(mod(m, 0.1)/0.1 - 0.5));\\n            dcol = mix( dcol, pal( m*.115+.6, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) ), .7);\\n            \\n            if( SCENE_MODE == 5) {\\n                for( int i=0; i<intersections.length(); i++ ){\\n                    if (i<MAX_MARCH_STEPS) {\\n                        float dti = distance(intersections[i], dint);\\n                        float mai = map_0(intersections[i]).x;\\n                        float outer = smoothstep( mai-0.15, mai, dti);\\n                        dcol = mix( dcol, vec3(1,0,0), .3*smoothstep( mai+0.01, mai, dti)*(outer+1.) );\\n                    }\\n                }            \\n            }\\n            if( d < t ) {\\n                col = mix(col, dcol, .6);\\n            }\\n        }\\n        \\n    \\tcol = mix( col, vec3(0.75,0.9,1.0), .05+.95* smoothstep(10.,20.,t) );\\n    }\\n\\n\\treturn vec3( clamp(col,0.0,1.0) );\\n}\\n\\nvec3 calcNormal_0( in vec3 pos )\\n{\\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\\n    \\n    return normalize( e.xyy*map_0( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map_0( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map_0( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map_0( pos + e.xxx ).x );\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\\n{\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\n\\nvec3 renderScene( vec2 p, vec3 ro, vec3 ta ) {\\n    // camera-to-world transformation\\n    mat3 ca = setCamera( ro, ta, 0.0 );\\n    // ray direction\\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\\n    // render\\t\\n    vec3 col = render( ro, rd );\\n    \\n    return col;\\n}\\n\\n\\nvoid initIntersecions( in vec3 ro, in vec3 rd ) {\\n    float t = 1.;\\n    \\n    for( int i=0; i<intersections.length(); i++ ){\\n        vec2 res = map_0( ro+rd*t );\\n        t += res.x;\\n        intersections[i] = ro + rd*t;\\n    }\\n}\\n\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\\n    \\n    aspect = iResolution.x/iResolution.y;\\n    \\n    loadData();\\n    \\n    if(SCENE_MODE == -1) {\\n        fragColor = tut_render(q, 96);\\n    } else {\\n        vec3 ro = LoadFVec4( ivec2(0,3) ).xyz;\\n        vec3 ta = LoadFVec4( ivec2(0,4) ).xyz;\\n        USER_INTERSECT = LoadFVec4( ivec2(0,5) ).xyz;\\n        \\n        if( SCENE_MODE == 5 ) {\\n            MAX_MARCH_STEPS = min(max(int( SLIDE_STEPS_VISIBLE/40-1),0), intersections.length()-1);\\n            \\n            initIntersecions(vec3(0,0,1), normalize(USER_INTERSECT - vec3(0,0,1)) );\\n            for (int i=0; i<intersections.length(); i++) {\\n                if (i<MAX_MARCH_STEPS+1) {\\n            \\t\\tUSER_INTERSECT = intersections[i];\\n                }\\n            }\\n        }\\n        if( SCENE_MODE == 6 ) {\\n            intersectionNormal = calcNormal_0(USER_INTERSECT) * .5;\\n        }\\n        \\n        fragColor = vec4(renderScene(q, ro, ta),1);\\n    }\\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/4dSfRc\\n//\\n// In this tutorial you will learn how to render a 3d-scene in Shadertoy\\n// using distance fields.\\n//\\n// The tutorial itself is created in Shadertoy, and is rendered\\n// using ray marching a distance field.\\n//\\n// The shader studied in the tutorial can be found here: \\n//     https://www.shadertoy.com/view/4dSBz3\\n//\\n// Created for the Shadertoy Competition 2017 \\n//\\n// Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\\n//\\n// You can find this shader here:\\n//     https://www.shadertoy.com/view/Xds3zN\\n//\\n\\n// COPY LAST FRAME FOR FADES\\n\\n#define SLIDE_FADE_STEPS 60 \\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    int SLIDE_STEPS_VISIBLE = int(texelFetch( iChannel0, ivec2(0,0), 0 ).y);\\n    \\n    if(iFrame == 0) {\\n  \\t\\tfragColor = vec4(0,0,0,1);\\n    } else if(SLIDE_STEPS_VISIBLE > SLIDE_FADE_STEPS) {\\n  \\t\\tfragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\\n    } else {\\n    \\tfragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\\n    }\\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/4dSfRc\\n//\\n// In this tutorial you will learn how to render a 3d-scene in Shadertoy\\n// using distance fields.\\n//\\n// The tutorial itself is created in Shadertoy, and is rendered\\n// using ray marching a distance field.\\n//\\n// The shader studied in the tutorial can be found here: \\n//     https://www.shadertoy.com/view/4dSBz3\\n//\\n// Created for the Shadertoy Competition 2017 \\n//\\n// Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\\n//\\n// You can find this shader here:\\n//     https://www.shadertoy.com/view/Xds3zN\\n//\\n\\n// FONT RENDERING\\n\\n#define FONT_UV_WIDTH 160.\\n\\nivec4 LoadVec4( in ivec2 vAddr ) {\\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\\n}\\n\\nvoid drawStr(const uint str, const ivec2 c, const vec2 uv, const vec2 caret, const float size, const vec3 fontCol, inout vec4 outCol) {    \\n    if( !(str == 0x0U || c.y < 0 || c.x < 0) ) {\\n        int x = c.x % 4;\\n        uint xy = (str >> ((3 - x) * 8)) % 256U;\\n\\n        if( xy > 0x0aU ) {\\n            vec2 K = fract((uv - caret) / vec2(size * .45, size));\\n            K.x = K.x * .6 + .2;\\n            K.y = K.y * .95 - .05;\\n            float d = textureLod(iChannel2, (K + vec2( xy & 0xFU, 0xFU - (xy >> 4))) / 16.,0.).a;\\n\\n            outCol.rgb = mix( fontCol, vec3(0) , smoothstep(.0,1.,smoothstep(.47,.53,d)) * .9 );\\n            outCol.a = smoothstep(1.,0., smoothstep(.53,.59,d));\\n        } \\n    }\\n}\\n\\nvoid mainImage( out vec4 outCol, in vec2 fragCoord ) {\\n    ivec4 slideData = LoadVec4( ivec2(0,0) );\\n    ivec4 text1 = LoadVec4(ivec2(0,1));\\n    ivec4 text2 = LoadVec4(ivec2(0,2));\\n\\n    if( text1.x == 1 ) {\\n        outCol = vec4(0);\\n    } else {\\n        outCol = texelFetch(iChannel1, ivec2(fragCoord), 0);    \\n    }\\n\\n    vec2 uv = ((fragCoord-iResolution.xy*.5)/iResolution.y) * FONT_UV_WIDTH;\\n\\n    if(text2.x > 0) { // title\\n        int i = text2.x;\\n\\t\\tuint f = 0x0U;\\n\\t\\tif( i == 1 ) {\\n\\t\\t\\tivec2 c = ivec2( (uv - vec2(-79, 60)) * (1./vec2(5.85, -13)) + vec2(1,2)) - 1;\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x5261796dU : c.x < 8 ? 0x61726368U : c.x < 12 ? 0x696e6720U : c.x < 16 ? 0x64697374U : c.x < 20 ? 0x616e6365U : c.x < 24 ? 0x20666965U : c.x < 28 ? 0x6c647320U : f;\\n\\t\\t\\tdrawStr( f, c, uv, vec2(-79, 60), 13., vec3(255./255., 208./255., 128./255.), outCol );\\t\\t}\\n\\t\\telse if( i == 2 ) {\\n\\t\\t\\tivec2 c = ivec2( (uv - vec2(-35.1, 60)) * (1./vec2(5.85, -13)) + vec2(1,2)) - 1;\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x43726561U : c.x < 8 ? 0x74652061U : c.x < 12 ? 0x20726179U : f;\\n\\t\\t\\tdrawStr( f, c, uv, vec2(-35.1, 60), 13., vec3(255./255., 208./255., 128./255.), outCol );\\t\\t}\\n\\t\\telse if( i == 3 ) {\\n\\t\\t\\tivec2 c = ivec2( (uv - vec2(-43.9, 60)) * (1./vec2(5.85, -13)) + vec2(1,2)) - 1;\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x44697374U : c.x < 8 ? 0x616e6365U : c.x < 12 ? 0x20666965U : c.x < 16 ? 0x6c647320U : f;\\n\\t\\t\\tdrawStr( f, c, uv, vec2(-43.9, 60), 13., vec3(255./255., 208./255., 128./255.), outCol );\\t\\t}\\n\\t\\telse if( i == 4 ) {\\n\\t\\t\\tivec2 c = ivec2( (uv - vec2(-23.4, 60)) * (1./vec2(5.85, -13)) + vec2(1,2)) - 1;\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x4c696768U : c.x < 8 ? 0x74696e67U : f;\\n\\t\\t\\tdrawStr( f, c, uv, vec2(-23.4, 60), 13., vec3(255./255., 208./255., 128./255.), outCol );\\t\\t}\\n\\n    }\\n    if(text2.y > 0) { // body\\n        int i = text2.y;\\n\\t\\tivec2 c = ivec2( (uv - vec2(-120, 40)) * (1./vec2(3.6, -8)) + vec2(1,2)) - 1;\\n\\t\\tuint f = 0x0U;\\n\\t\\tif( i == 1 || i == 2 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x496e2074U : c.x < 8 ? 0x68697320U : c.x < 12 ? 0x7475746fU : c.x < 16 ? 0x7269616cU : c.x < 20 ? 0x20796f75U : c.x < 24 ? 0x2077696cU : c.x < 28 ? 0x6c206c65U : c.x < 32 ? 0x61726e20U : c.x < 36 ? 0x686f7720U : c.x < 40 ? 0x746f2072U : c.x < 44 ? 0x656e6465U : c.x < 48 ? 0x7220200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x61203364U : c.x < 8 ? 0x2d736365U : c.x < 12 ? 0x6e652069U : c.x < 16 ? 0x6e205368U : c.x < 20 ? 0x61646572U : c.x < 24 ? 0x746f7920U : c.x < 28 ? 0x7573696eU : c.x < 32 ? 0x67206469U : c.x < 36 ? 0x7374616eU : c.x < 40 ? 0x63652066U : c.x < 44 ? 0x69656c64U : c.x < 48 ? 0x732e2020U : f;\\n\\t\\t}\\n\\t\\tif( i == 2 ) {\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x41732061U : c.x < 8 ? 0x6e206578U : c.x < 12 ? 0x616d706cU : c.x < 16 ? 0x652c2077U : c.x < 20 ? 0x65207769U : c.x < 24 ? 0x6c6c2063U : c.x < 28 ? 0x72656174U : c.x < 32 ? 0x65207468U : c.x < 36 ? 0x69732062U : c.x < 40 ? 0x6c61636bU : c.x < 44 ? 0x20616e64U : c.x < 48 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 4) f = c.x < 4 ? 0x77686974U : c.x < 8 ? 0x65207363U : c.x < 12 ? 0x656e6520U : c.x < 16 ? 0x6f662074U : c.x < 20 ? 0x68726565U : c.x < 24 ? 0x20737068U : c.x < 28 ? 0x65726573U : c.x < 32 ? 0x206f6e20U : c.x < 36 ? 0x6120706cU : c.x < 40 ? 0x616e652eU : f;\\n\\t\\t}\\n\\t\\telse if( i == 3 || i == 4 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x46697273U : c.x < 8 ? 0x74207765U : c.x < 12 ? 0x20637265U : c.x < 16 ? 0x61746520U : c.x < 20 ? 0x61207261U : c.x < 24 ? 0x792e200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x72617920U : c.x < 12 ? 0x6f726967U : c.x < 16 ? 0x696e2028U : c.x < 20 ? 0x726f2920U : c.x < 24 ? 0x77696c6cU : c.x < 28 ? 0x20626520U : c.x < 32 ? 0x61742028U : c.x < 36 ? 0x302c302cU : c.x < 40 ? 0x31292e20U : f;\\n\\t\\t}\\n\\t\\tif( i == 4 ) {\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\\n\\t\\t}\\n\\t\\telse if( i == 5 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x77652070U : c.x < 12 ? 0x6c616365U : c.x < 16 ? 0x20612076U : c.x < 20 ? 0x69727475U : c.x < 24 ? 0x616c2073U : c.x < 28 ? 0x63726565U : c.x < 32 ? 0x6e20696eU : c.x < 36 ? 0x20746865U : c.x < 40 ? 0x20736365U : c.x < 44 ? 0x6e652e0aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x49742069U : c.x < 8 ? 0x73206c6fU : c.x < 12 ? 0x63617465U : c.x < 16 ? 0x64206174U : c.x < 20 ? 0x20746865U : c.x < 24 ? 0x206f7269U : c.x < 28 ? 0x67696e20U : c.x < 32 ? 0x616e6420U : c.x < 36 ? 0x6861730aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x64696d65U : c.x < 8 ? 0x6e73696fU : c.x < 12 ? 0x6e73206fU : c.x < 16 ? 0x66206173U : c.x < 20 ? 0x70656374U : c.x < 24 ? 0x5f726174U : c.x < 28 ? 0x696f2078U : c.x < 32 ? 0x20312e20U : f;\\n\\t\\t}\\n\\t\\telse if( i == 6 || i == 7 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x6f6d7075U : c.x < 12 ? 0x74652074U : c.x < 16 ? 0x68652072U : c.x < 20 ? 0x61792064U : c.x < 24 ? 0x69726563U : c.x < 28 ? 0x74696f6eU : c.x < 32 ? 0x20287264U : c.x < 36 ? 0x2920666fU : c.x < 40 ? 0x72206561U : c.x < 44 ? 0x6368200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x70697865U : c.x < 8 ? 0x6c202866U : c.x < 12 ? 0x72616743U : c.x < 16 ? 0x6f6f7264U : c.x < 20 ? 0x2e787929U : c.x < 24 ? 0x206f6620U : c.x < 28 ? 0x6f757220U : c.x < 32 ? 0x76697274U : c.x < 36 ? 0x75616c20U : c.x < 40 ? 0x73637265U : c.x < 44 ? 0x656e2e20U : f;\\n\\t\\t}\\n\\t\\tif( i == 7 ) {\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\\n\\t\\t}\\n\\t\\telse if( i == 8 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x55736520U : c.x < 8 ? 0x796f7572U : c.x < 12 ? 0x206d6f75U : c.x < 16 ? 0x73652074U : c.x < 20 ? 0x6f20696eU : c.x < 24 ? 0x74657261U : c.x < 28 ? 0x63742077U : c.x < 32 ? 0x69746820U : c.x < 36 ? 0x74686520U : c.x < 40 ? 0x7363656eU : c.x < 44 ? 0x652e2020U : f;\\n\\t\\t}\\n\\t\\telse if( i == 9 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x41206469U : c.x < 8 ? 0x7374616eU : c.x < 12 ? 0x63652066U : c.x < 16 ? 0x69656c64U : c.x < 20 ? 0x20697320U : c.x < 24 ? 0x75736564U : c.x < 28 ? 0x20746f20U : c.x < 32 ? 0x66696e64U : c.x < 36 ? 0x20746865U : c.x < 40 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x696e7465U : c.x < 8 ? 0x72736563U : c.x < 12 ? 0x74696f6eU : c.x < 16 ? 0x206f6620U : c.x < 20 ? 0x6f757220U : c.x < 24 ? 0x72617920U : c.x < 28 ? 0x28726f2cU : c.x < 32 ? 0x20726429U : c.x < 36 ? 0x20616e64U : c.x < 40 ? 0x20746865U : c.x < 44 ? 0x20737068U : c.x < 48 ? 0x65726573U : c.x < 52 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x616e6420U : c.x < 8 ? 0x706c616eU : c.x < 12 ? 0x65206f66U : c.x < 16 ? 0x20746865U : c.x < 20 ? 0x20736365U : c.x < 24 ? 0x6e652e20U : f;\\n\\t\\t}\\n\\t\\telse if( i == 10 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x41206469U : c.x < 8 ? 0x7374616eU : c.x < 12 ? 0x63652066U : c.x < 16 ? 0x69656c64U : c.x < 20 ? 0x20697320U : c.x < 24 ? 0x61206675U : c.x < 28 ? 0x6e637469U : c.x < 32 ? 0x6f6e2074U : c.x < 36 ? 0x68617420U : c.x < 40 ? 0x67697665U : c.x < 44 ? 0x7320616eU : c.x < 48 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x65737469U : c.x < 8 ? 0x6d617465U : c.x < 12 ? 0x20286120U : c.x < 16 ? 0x6c6f7765U : c.x < 20 ? 0x7220626fU : c.x < 24 ? 0x756e6420U : c.x < 28 ? 0x6f662920U : c.x < 32 ? 0x74686520U : c.x < 36 ? 0x64697374U : c.x < 40 ? 0x616e6365U : c.x < 44 ? 0x20746f20U : c.x < 48 ? 0x7468650aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x636c6f73U : c.x < 8 ? 0x65737420U : c.x < 12 ? 0x73757266U : c.x < 16 ? 0x61636520U : c.x < 20 ? 0x61742061U : c.x < 24 ? 0x6e792070U : c.x < 28 ? 0x6f696e74U : c.x < 32 ? 0x20696e20U : c.x < 36 ? 0x73706163U : c.x < 40 ? 0x652e2020U : f;\\n\\t\\t}\\n\\t\\telse if( i == 11 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x64697374U : c.x < 12 ? 0x616e6365U : c.x < 16 ? 0x2066756eU : c.x < 20 ? 0x6374696fU : c.x < 24 ? 0x6e20666fU : c.x < 28 ? 0x72206120U : c.x < 32 ? 0x73706865U : c.x < 36 ? 0x72652069U : c.x < 40 ? 0x73207468U : c.x < 44 ? 0x65206469U : c.x < 48 ? 0x7374616eU : c.x < 52 ? 0x63652074U : c.x < 56 ? 0x6f20200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x63656e74U : c.x < 12 ? 0x6572206fU : c.x < 16 ? 0x66207468U : c.x < 20 ? 0x65207370U : c.x < 24 ? 0x68657265U : c.x < 28 ? 0x206d696eU : c.x < 32 ? 0x75732074U : c.x < 36 ? 0x68652072U : c.x < 40 ? 0x61646975U : c.x < 44 ? 0x73206f66U : c.x < 48 ? 0x20746865U : c.x < 52 ? 0x20737068U : c.x < 56 ? 0x6572652eU : f;\\n\\t\\t}\\n\\t\\telse if( i == 12 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x636f6465U : c.x < 12 ? 0x20666f72U : c.x < 16 ? 0x20612073U : c.x < 20 ? 0x70686572U : c.x < 24 ? 0x65206c6fU : c.x < 28 ? 0x63617465U : c.x < 32 ? 0x64206174U : c.x < 36 ? 0x20282d31U : c.x < 40 ? 0x2c302c2dU : c.x < 44 ? 0x35293a20U : f;\\n\\t\\t}\\n\\t\\telse if( i == 13 || i == 14 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x6f6d6269U : c.x < 12 ? 0x6e652064U : c.x < 16 ? 0x69666665U : c.x < 20 ? 0x72656e74U : c.x < 24 ? 0x20646973U : c.x < 28 ? 0x74616e63U : c.x < 32 ? 0x65206675U : c.x < 36 ? 0x6e637469U : c.x < 40 ? 0x6f6e7320U : c.x < 44 ? 0x62792074U : c.x < 48 ? 0x616b696eU : c.x < 52 ? 0x6720200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x6d696e69U : c.x < 12 ? 0x6d756d20U : c.x < 16 ? 0x76616c75U : c.x < 20 ? 0x65206f66U : c.x < 24 ? 0x20746865U : c.x < 28 ? 0x73652066U : c.x < 32 ? 0x756e6374U : c.x < 36 ? 0x696f6e73U : c.x < 40 ? 0x2e202020U : f;\\n\\t\\t}\\n\\t\\tif( i == 14 ) {\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\\n\\t\\t}\\n\\t\\telse if( i == 15 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x746f7461U : c.x < 12 ? 0x6c206469U : c.x < 16 ? 0x7374616eU : c.x < 20 ? 0x63652066U : c.x < 24 ? 0x756e6374U : c.x < 28 ? 0x696f6e20U : c.x < 32 ? 0x666f7220U : c.x < 36 ? 0x74686973U : c.x < 40 ? 0x20736365U : c.x < 44 ? 0x6e65200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x28696e63U : c.x < 8 ? 0x6c756469U : c.x < 12 ? 0x6e672074U : c.x < 16 ? 0x68652070U : c.x < 20 ? 0x6c616e65U : c.x < 24 ? 0x29206973U : c.x < 28 ? 0x20676976U : c.x < 32 ? 0x656e2062U : c.x < 36 ? 0x793a2020U : f;\\n\\t\\t}\\n\\t\\telse if( i == 16 || i == 17 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x77652063U : c.x < 12 ? 0x616e206dU : c.x < 16 ? 0x61726368U : c.x < 20 ? 0x20746865U : c.x < 24 ? 0x20736365U : c.x < 28 ? 0x6e652066U : c.x < 32 ? 0x726f6d20U : c.x < 36 ? 0x726f2069U : c.x < 40 ? 0x6e206469U : c.x < 44 ? 0x72656374U : c.x < 48 ? 0x696f6e20U : c.x < 52 ? 0x72642e0aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x45616368U : c.x < 8 ? 0x20737465U : c.x < 12 ? 0x70207369U : c.x < 16 ? 0x7a652069U : c.x < 20 ? 0x73206769U : c.x < 24 ? 0x76656e20U : c.x < 28 ? 0x62792074U : c.x < 32 ? 0x68652064U : c.x < 36 ? 0x69737461U : c.x < 40 ? 0x6e636520U : c.x < 44 ? 0x6669656cU : c.x < 48 ? 0x642e2020U : f;\\n\\t\\t}\\n\\t\\tif( i == 17 ) {\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x57652073U : c.x < 8 ? 0x746f7020U : c.x < 12 ? 0x74686520U : c.x < 16 ? 0x6d617263U : c.x < 20 ? 0x68207768U : c.x < 24 ? 0x656e2077U : c.x < 28 ? 0x65206669U : c.x < 32 ? 0x6e642061U : c.x < 36 ? 0x6e20696eU : c.x < 40 ? 0x74657273U : c.x < 44 ? 0x65637469U : c.x < 48 ? 0x6f6e3a20U : f;\\n\\t\\t}\\n\\t\\telse if( i == 18 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x74686174U : c.x < 12 ? 0x20776520U : c.x < 16 ? 0x68617665U : c.x < 20 ? 0x20666f75U : c.x < 24 ? 0x6e642074U : c.x < 28 ? 0x68652069U : c.x < 32 ? 0x6e746572U : c.x < 36 ? 0x73656374U : c.x < 40 ? 0x696f6e20U : c.x < 44 ? 0x2870203dU : c.x < 48 ? 0x20726f20U : c.x < 52 ? 0x2b207264U : c.x < 56 ? 0x202a2074U : c.x < 60 ? 0x2920200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x666f7220U : c.x < 8 ? 0x6f757220U : c.x < 12 ? 0x7261792cU : c.x < 16 ? 0x20776520U : c.x < 20 ? 0x63616e20U : c.x < 24 ? 0x67697665U : c.x < 28 ? 0x20746865U : c.x < 32 ? 0x20736365U : c.x < 36 ? 0x6e652073U : c.x < 40 ? 0x6f6d6520U : c.x < 44 ? 0x6c696768U : c.x < 48 ? 0x74696e67U : c.x < 52 ? 0x2e20200aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x546f2061U : c.x < 8 ? 0x70706c79U : c.x < 12 ? 0x20646966U : c.x < 16 ? 0x66757365U : c.x < 20 ? 0x206c6967U : c.x < 24 ? 0x6874696eU : c.x < 28 ? 0x67207765U : c.x < 32 ? 0x20686176U : c.x < 36 ? 0x6520746fU : c.x < 40 ? 0x2063616cU : c.x < 44 ? 0x63756c61U : c.x < 48 ? 0x7465200aU : f;\\n\\t\\t\\tif(c.y == 4) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x6e6f726dU : c.x < 12 ? 0x616c206fU : c.x < 16 ? 0x66207368U : c.x < 20 ? 0x6164696eU : c.x < 24 ? 0x6720706fU : c.x < 28 ? 0x696e7420U : c.x < 32 ? 0x702e2020U : f;\\n\\t\\t}\\n\\t\\telse if( i == 19 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x6e6f726dU : c.x < 12 ? 0x616c2063U : c.x < 16 ? 0x616e2062U : c.x < 20 ? 0x65206361U : c.x < 24 ? 0x6c63756cU : c.x < 28 ? 0x61746564U : c.x < 32 ? 0x20627920U : c.x < 36 ? 0x74616b69U : c.x < 40 ? 0x6e672074U : c.x < 44 ? 0x68652063U : c.x < 48 ? 0x656e7472U : c.x < 52 ? 0x616c200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x64696666U : c.x < 8 ? 0x6572656eU : c.x < 12 ? 0x63657320U : c.x < 16 ? 0x6f6e2074U : c.x < 20 ? 0x68652064U : c.x < 24 ? 0x69737461U : c.x < 28 ? 0x6e636520U : c.x < 32 ? 0x6669656cU : c.x < 36 ? 0x643a2020U : f;\\n\\t\\t}\\n\\t\\telse if( i == 20 || i == 21 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x616c6375U : c.x < 12 ? 0x6c617465U : c.x < 16 ? 0x20746865U : c.x < 20 ? 0x20646966U : c.x < 24 ? 0x66757365U : c.x < 28 ? 0x206c6967U : c.x < 32 ? 0x6874696eU : c.x < 36 ? 0x6720666fU : c.x < 40 ? 0x7220610aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x706f696eU : c.x < 8 ? 0x74206c69U : c.x < 12 ? 0x67687420U : c.x < 16 ? 0x61742070U : c.x < 20 ? 0x6f736974U : c.x < 24 ? 0x696f6e20U : c.x < 28 ? 0x28302c32U : c.x < 32 ? 0x2c30292eU : f;\\n\\t\\t}\\n\\t\\tif( i == 21 ) {\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\\n\\t\\t}\\n\\t\\telse if( i == 22 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x416e6420U : c.x < 8 ? 0x77652061U : c.x < 12 ? 0x72652064U : c.x < 16 ? 0x6f6e6521U : c.x < 20 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x41646469U : c.x < 8 ? 0x6e672061U : c.x < 12 ? 0x6d626965U : c.x < 16 ? 0x6e74206fU : c.x < 20 ? 0x63636c75U : c.x < 24 ? 0x73696f6eU : c.x < 28 ? 0x2c202866U : c.x < 32 ? 0x616b6529U : c.x < 36 ? 0x20726566U : c.x < 40 ? 0x6c656374U : c.x < 44 ? 0x696f6e73U : c.x < 48 ? 0x2c20200aU : f;\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x736f6674U : c.x < 8 ? 0x20736861U : c.x < 12 ? 0x646f7773U : c.x < 16 ? 0x2c20666fU : c.x < 20 ? 0x672c2061U : c.x < 24 ? 0x6d626965U : c.x < 28 ? 0x6e74206cU : c.x < 32 ? 0x69676874U : c.x < 36 ? 0x696e6720U : c.x < 40 ? 0x616e6420U : c.x < 44 ? 0x73706563U : c.x < 48 ? 0x756c6172U : c.x < 52 ? 0x206c6967U : c.x < 56 ? 0x6874696eU : c.x < 60 ? 0x6720200aU : f;\\n\\t\\t\\tif(c.y == 4) f = c.x < 4 ? 0x6973206cU : c.x < 8 ? 0x65667420U : c.x < 12 ? 0x61732061U : c.x < 16 ? 0x6e206578U : c.x < 20 ? 0x65726369U : c.x < 24 ? 0x73652066U : c.x < 28 ? 0x6f722074U : c.x < 32 ? 0x68652072U : c.x < 36 ? 0x65616465U : c.x < 40 ? 0x722e2020U : f;\\n\\t\\t}\\n\\t\\tdrawStr( f, c, uv, vec2(-120, 40), 8., vec3(1), outCol );\\n    }\\n    if(text2.z > 0) { // code\\n        int i = text2.z;\\n\\t\\tivec2 c = ivec2( (uv - vec2(-120, 0)) * (1./vec2(3.6, -8)) + vec2(1,2)) - 1;\\n\\t\\tuint f = 0x0U;\\n\\t\\tif( i == 1 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x766f6964U : c.x < 8 ? 0x206d6169U : c.x < 12 ? 0x6e496d61U : c.x < 16 ? 0x6765286fU : c.x < 20 ? 0x75742076U : c.x < 24 ? 0x65633420U : c.x < 28 ? 0x66726167U : c.x < 32 ? 0x436f6c6fU : c.x < 36 ? 0x722c2069U : c.x < 40 ? 0x6e207665U : c.x < 44 ? 0x63322066U : c.x < 48 ? 0x72616743U : c.x < 52 ? 0x6f6f7264U : c.x < 56 ? 0x29207b0aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x20726f20U : c.x < 16 ? 0x3d207665U : c.x < 20 ? 0x63332830U : c.x < 24 ? 0x2c20302cU : c.x < 28 ? 0x2031293bU : c.x < 32 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656332U : c.x < 12 ? 0x2071203dU : c.x < 16 ? 0x20286672U : c.x < 20 ? 0x6167436fU : c.x < 24 ? 0x6f72642eU : c.x < 28 ? 0x7879202dU : c.x < 32 ? 0x202e3520U : c.x < 36 ? 0x2a206952U : c.x < 40 ? 0x65736f6cU : c.x < 44 ? 0x7574696fU : c.x < 48 ? 0x6e2e7879U : c.x < 52 ? 0x2029202fU : c.x < 56 ? 0x20695265U : c.x < 60 ? 0x736f6c75U : c.x < 64 ? 0x74696f6eU : c.x < 68 ? 0x2e793b0aU : f;\\n\\t\\t\\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x20726420U : c.x < 16 ? 0x3d206e6fU : c.x < 20 ? 0x726d616cU : c.x < 24 ? 0x697a6528U : c.x < 28 ? 0x76656333U : c.x < 32 ? 0x28712c20U : c.x < 36 ? 0x302e2920U : c.x < 40 ? 0x2d20726fU : c.x < 44 ? 0x293b200aU : f;\\n\\t\\t}\\n\\t\\telse if( i == 2 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x666c6f61U : c.x < 8 ? 0x74206d61U : c.x < 12 ? 0x70287665U : c.x < 16 ? 0x63332070U : c.x < 20 ? 0x29207b0aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x666c6f61U : c.x < 12 ? 0x74206420U : c.x < 16 ? 0x3d206469U : c.x < 20 ? 0x7374616eU : c.x < 24 ? 0x63652870U : c.x < 28 ? 0x2c207665U : c.x < 32 ? 0x6333282dU : c.x < 36 ? 0x312c2030U : c.x < 40 ? 0x2c202d35U : c.x < 44 ? 0x2929202dU : c.x < 48 ? 0x20312e3bU : c.x < 52 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2064U : c.x < 20 ? 0x69737461U : c.x < 24 ? 0x6e636528U : c.x < 28 ? 0x702c2076U : c.x < 32 ? 0x65633328U : c.x < 36 ? 0x322c2030U : c.x < 40 ? 0x2c202d33U : c.x < 44 ? 0x2929202dU : c.x < 48 ? 0x20312e29U : c.x < 52 ? 0x3b20200aU : f;\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2064U : c.x < 20 ? 0x69737461U : c.x < 24 ? 0x6e636528U : c.x < 28 ? 0x702c2076U : c.x < 32 ? 0x65633328U : c.x < 36 ? 0x2d322c20U : c.x < 40 ? 0x302c202dU : c.x < 44 ? 0x32292920U : c.x < 48 ? 0x2d20312eU : c.x < 52 ? 0x293b200aU : f;\\n\\t\\t\\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2070U : c.x < 20 ? 0x2e79202bU : c.x < 24 ? 0x20312e29U : c.x < 28 ? 0x3b20200aU : f;\\n\\t\\t\\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x72657475U : c.x < 12 ? 0x726e2064U : c.x < 16 ? 0x3b20200aU : f;\\n\\t\\t\\tif(c.y == 6) f = c.x < 4 ? 0x7d202020U : f;\\n\\t\\t}\\n\\t\\telse if( i == 3 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x666c6f61U : c.x < 8 ? 0x7420682cU : c.x < 12 ? 0x2074203dU : c.x < 16 ? 0x20312e3bU : c.x < 20 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x666f7220U : c.x < 8 ? 0x28696e74U : c.x < 12 ? 0x2069203dU : c.x < 16 ? 0x20303b20U : c.x < 20 ? 0x69203c20U : c.x < 24 ? 0x3235363bU : c.x < 28 ? 0x20692b2bU : c.x < 32 ? 0x29207b0aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x68203d20U : c.x < 12 ? 0x6d617028U : c.x < 16 ? 0x726f202bU : c.x < 20 ? 0x20726420U : c.x < 24 ? 0x2a207429U : c.x < 28 ? 0x3b20200aU : f;\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x74202b3dU : c.x < 12 ? 0x20683b0aU : f;\\n\\t\\t\\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x69662028U : c.x < 12 ? 0x68203c20U : c.x < 16 ? 0x302e3031U : c.x < 20 ? 0x29206272U : c.x < 24 ? 0x65616b3bU : c.x < 28 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 5) f = c.x < 4 ? 0x7d202020U : f;\\n\\t\\t}\\n\\t\\telse if( i == 4 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x76656333U : c.x < 8 ? 0x2063616cU : c.x < 12 ? 0x634e6f72U : c.x < 16 ? 0x6d616c28U : c.x < 20 ? 0x696e2076U : c.x < 24 ? 0x65633320U : c.x < 28 ? 0x7029207bU : c.x < 32 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656332U : c.x < 12 ? 0x2065203dU : c.x < 16 ? 0x20766563U : c.x < 20 ? 0x3228312eU : c.x < 24 ? 0x302c202dU : c.x < 28 ? 0x312e3029U : c.x < 32 ? 0x202a2030U : c.x < 36 ? 0x2e303030U : c.x < 40 ? 0x353b200aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x72657475U : c.x < 12 ? 0x726e206eU : c.x < 16 ? 0x6f726d61U : c.x < 20 ? 0x6c697a65U : c.x < 24 ? 0x2820200aU : f;\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7879U : c.x < 16 ? 0x79202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7879U : c.x < 32 ? 0x7929202bU : c.x < 36 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7979U : c.x < 16 ? 0x78202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7979U : c.x < 32 ? 0x7829202bU : c.x < 36 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7978U : c.x < 16 ? 0x79202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7978U : c.x < 32 ? 0x7929202bU : c.x < 36 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 6) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7878U : c.x < 16 ? 0x78202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7878U : c.x < 32 ? 0x7829293bU : c.x < 36 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 7) f = c.x < 4 ? 0x7d202020U : f;\\n\\t\\t}\\n\\t\\telse if( i == 5 ) {\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x69662028U : c.x < 8 ? 0x68203c20U : c.x < 12 ? 0x302e3031U : c.x < 16 ? 0x29207b0aU : f;\\n\\t\\t\\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x2070203dU : c.x < 16 ? 0x20726f20U : c.x < 20 ? 0x2b207264U : c.x < 24 ? 0x202a2074U : c.x < 28 ? 0x3b20200aU : f;\\n\\t\\t\\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x206e6f72U : c.x < 16 ? 0x6d616c20U : c.x < 20 ? 0x3d206361U : c.x < 24 ? 0x6c634e6fU : c.x < 28 ? 0x726d616cU : c.x < 32 ? 0x2870293bU : c.x < 36 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x206c6967U : c.x < 16 ? 0x6874203dU : c.x < 20 ? 0x20766563U : c.x < 24 ? 0x3328302cU : c.x < 28 ? 0x20322c20U : c.x < 32 ? 0x30293b0aU : f;\\n\\t\\t\\tif(c.y == 4) f = c.x < 4 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x666c6f61U : c.x < 12 ? 0x74206469U : c.x < 16 ? 0x66203d20U : c.x < 20 ? 0x636c616dU : c.x < 24 ? 0x7028646fU : c.x < 28 ? 0x74286e6fU : c.x < 32 ? 0x726d616cU : c.x < 36 ? 0x2c206e6fU : c.x < 40 ? 0x726d616cU : c.x < 44 ? 0x697a6528U : c.x < 48 ? 0x6c696768U : c.x < 52 ? 0x74202d20U : c.x < 56 ? 0x7029292cU : c.x < 60 ? 0x20302e2cU : c.x < 64 ? 0x20312e29U : c.x < 68 ? 0x3b20200aU : f;\\n\\t\\t\\tif(c.y == 6) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64696620U : c.x < 12 ? 0x2a3d2035U : c.x < 16 ? 0x2e202f20U : c.x < 20 ? 0x646f7428U : c.x < 24 ? 0x6c696768U : c.x < 28 ? 0x74202d20U : c.x < 32 ? 0x702c206cU : c.x < 36 ? 0x69676874U : c.x < 40 ? 0x202d2070U : c.x < 44 ? 0x293b200aU : f;\\n\\t\\t\\tif(c.y == 7) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x66726167U : c.x < 12 ? 0x436f6c6fU : c.x < 16 ? 0x72203d20U : c.x < 20 ? 0x76656334U : c.x < 24 ? 0x28766563U : c.x < 28 ? 0x3328706fU : c.x < 32 ? 0x77286469U : c.x < 36 ? 0x662c2030U : c.x < 40 ? 0x2e343534U : c.x < 44 ? 0x3529292cU : c.x < 48 ? 0x2031293bU : c.x < 52 ? 0x2020200aU : f;\\n\\t\\t\\tif(c.y == 8) f = c.x < 4 ? 0x7d202020U : f;\\n\\t\\t}\\n\\t\\tdrawStr( f, c, uv, vec2(-120, 0), 8., vec3(.8,.95,1.), outCol );\\n        if( text1.y > 0 ) {\\n           if(uv.y >  - (-1.+float(text1.y))*8. && c.y >= 0 ) {\\n                outCol *= vec4(.5,.2,.6,.8);\\n            }\\n        }\\n        if( text1.z > 0 ) {\\n            if(uv.y <  - (-2.+float(text1.z))*8. && c.y >= 0 ) {\\n                outCol *= vec4(.5,.2,.6,.8);\\n            }\\n        }\\n    }\\n    if(slideData.y == 120) { // footer\\n        int i = 1;\\n\\t\\tuint f = 0x0U;\\n\\t\\tif( i == 1 ) {\\n\\t\\t\\tivec2 c = ivec2( (uv - vec2(-38.8, -78)) * (1./vec2(3.38, -7.5)) + vec2(1,2)) - 1;\\n\\t\\t\\tif(c.y == 0) f = c.x < 4 ? 0x50726573U : c.x < 8 ? 0x73207370U : c.x < 12 ? 0x61636520U : c.x < 16 ? 0x746f2063U : c.x < 20 ? 0x6f6e7469U : c.x < 24 ? 0x6e756520U : f;\\n\\t\\t\\tdrawStr( f, c, uv, vec2(-38.8, -78), 7.5, vec3(.9), outCol );\\t\\t}\\n\\n    }\\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MtfBDN","date":"1511863416","viewed":1406,"name":"Contrast speed illusion","description":"Both rectangles are moving at exactly the same speed.\\n\\nBased on the [url=https://scratch.mit.edu/projects/188838060/]flash implementation[/url] by Jim Cash and https://quote.ucsd.edu/anstislab/files/2012/11/2001-Footsteps-and-inchworms.pdf.","likes":25,"published":"Public API","usePreview":0,"tags":["contrast","illusion","speed","perception"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Contrast speed illusion. Created by Reinder Nijhoff 2017\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n// \\n// https://www.shadertoy.com/view/MtfBDN\\n//\\n// Both rectangles are moving at exactly the same speed.\\n//\\n// Based on the flash implementation by Jim Cash: https://scratch.mit.edu/projects/188838060/\\n//\\n// Research paper:\\n//\\n// https://quote.ucsd.edu/anstislab/files/2012/11/2001-Footsteps-and-inchworms.pdf\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec2 uv = fragCoord.xy / iResolution.xy;\\n    float scale = iResolution.x / 300.;\\n    \\n    float fade = smoothstep(0.1,0.2,abs(fract(iTime*.05+.5)-.5));\\n    \\n    vec3 bgpattern = vec3(round(fract(uv.x*20.*scale)-.02*scale));\\n    // vec3 bgpattern = .6+.6*cos(6.28*uv.x*20.*scale+vec3(0,-2.1,2.1));\\n    // vec3 bgpattern = vec3(.5+.5*sin(6.28*uv.x*20.*scale));\\n    \\n    vec3 c = mix(vec3(.7), bgpattern, fade);\\n    \\n    float p = fract(iTime*.1/scale);\\n    float x = step(uv.x,p+.3/scale)*step(p,uv.x);\\n    \\n    c = mix(c, vec3(1,1,0), x*step(abs(uv.y-.3),.03));\\n    c = mix(c, vec3(0,0,0.7), x*step(abs(uv.y-.7),.03));\\n    \\n\\tfragColor = vec4(c,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lscBW4","date":"1525112497","viewed":21447,"name":"Old watch (IBL)","description":"This shader uses Image Based Lighting (IBL) to render an old watch. The materials of the objects have physically-based properties. I have used the IBL technique as explained in the article 'Real Shading in Unreal Engine 4' by Brian Karis of Epic Games.","likes":278,"published":"Public API","usePreview":1,"tags":["lighting","clock","image","ibl","vr","pbr","watch","based"]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lscBW4\\n//\\n// This shader uses Image Based Lighting (IBL) to render an old watch. The\\n// materials of the objects have physically-based properties.\\n//\\n// A material is defined by its albedo and roughness value and it can be a \\n// metal or a non-metal.\\n//\\n// I have used the IBL technique as explained in the article 'Real Shading in\\n// Unreal Engine 4' by Brian Karis of Epic Games.[1] According to this article,\\n// the lighting of a material is the sum of two components:\\n// \\n// 1. Diffuse: a look-up (using the normal vector) in a pre-computed environment map.\\n// 2. Specular: a look-up (based on the reflection vector and the roughness of the\\n//       material) in a pre-computed environment map, combined with a look-up in a\\n//       pre-calculated BRDF integration map (Buf B).  \\n// \\n// Note that I do NOT (pre)compute the environment maps needed in this shader. Instead,\\n// I use (the lod levels of) a Shadertoy cubemap that I have remapped using a random \\n// function to get something HDR-ish. This is not correct and not how it is described\\n// in the article, but I think that for this scene the result is good enough.\\n//\\n// I made a shader that renders this same scene using a simple path tracer. You can\\n// compare the result here:\\n//\\n// https://www.shadertoy.com/view/MlyyzW\\n//\\n// [1] http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\\n//\\n\\n#define MAX_LOD 8.\\n#define DIFFUSE_LOD 6.75\\n#define AA 2\\n// #define P_MALIN_AO \\n\\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\\n    return pow(textureLod(iChannel0, N, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\\n}\\n\\nvec3 getDiffuseLightColor( vec3 N ) {\\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\\n    return .25 +pow(textureLod(iChannel0, N, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\\n}\\n\\n//\\n// Modified FrenelSchlick: https://seblagarde.wordpress.com/2011/08/17/hello-world/\\n//\\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\\n}\\n\\n//\\n// Image based lighting\\n//\\n\\nvec3 lighting(in vec3 ro, in vec3 pos, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\\n    vec3 V = normalize(ro - pos); \\n    vec3 R = reflect(-V, N);\\n    float NdotV = max(0.0, dot(N, V));\\n\\n    vec3 F0 = vec3(0.04); \\n    F0 = mix(F0, albedo, metallic);\\n\\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\\n\\n    vec3 kS = F;\\n\\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\\n    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\\n\\n    vec3 kD = vec3(1.0) - kS;\\n\\n    kD *= 1.0 - metallic;\\n\\n    vec3 irradiance = getDiffuseLightColor(N);\\n\\n    vec3 diffuse  = albedo * irradiance;\\n\\n#ifdef P_MALIN_AO\\n    vec3 color = kD * diffuse * ao + specular * calcAO(pos, R);\\n#else\\n    vec3 color = (kD * diffuse + specular) * ao;\\n#endif\\n\\n    return color;\\n}\\n\\n//\\n// main \\n//\\n\\nvec3 render( const in vec3 ro, const in vec3 rd ) {\\n    vec3 col = vec3(0); \\n    vec2 res = castRay( ro, rd );\\n\\n    if (res.x > 0.) {\\n        vec3 pos = ro + rd * res.x;\\n        vec3 N, albedo;\\n        float roughness, metallic, ao;\\n\\n        getMaterialProperties(pos, res.y, N, albedo, ao, roughness, metallic, iChannel1, iChannel2, iChannel3);\\n\\n        col = lighting(ro, pos, N, albedo, ao, roughness, metallic);\\n        col *= max(0.0, min(1.1, 10./dot(pos,pos)) - .15);\\n    }\\n\\n    // Glass. \\n    float glass = castRayGlass( ro, rd );\\n    if (glass > 0. && (glass < res.x || res.x < 0.)) {\\n        vec3 N = calcNormalGlass(ro+rd*glass);\\n        vec3 pos = ro + rd * glass;\\n\\n        vec3 V = normalize(ro - pos); \\n        vec3 R = reflect(-V, N);\\n        float NdotV = max(0.0, dot(N, V));\\n\\n        float roughness = texture(iChannel2, pos.xz*.5 + .5).g;\\n\\n        vec3 F = FresnelSchlickRoughness(NdotV, vec3(.08), roughness);\\n        vec3 prefilteredColor = getSpecularLightColor(R, roughness);\\n        vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\\n        vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\\n\\n        col = col * (1.0 -  (F * envBRDF.x + envBRDF.y) ) + specular;\\n    } \\n\\n    // gamma correction\\n    col = max( vec3(0), col - 0.004);\\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\\n    \\n    return col;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec2 uv = fragCoord/iResolution.xy;\\n    vec2 mo = iMouse.xy/iResolution.xy - .5;\\n    if(iMouse.z <= 0.) {\\n        mo = vec2(.2*sin(-iTime*.1+.3)+.045,.1-.2*sin(-iTime*.1+.3));\\n    }\\n    float a = 5.05;\\n    vec3 ro = vec3( .25 + 2.*cos(6.0*mo.x+a), 2. + 2. * mo.y, 2.0*sin(6.0*mo.x+a) );\\n    vec3 ta = vec3( .25, .5, .0 );\\n    mat3 ca = setCamera( ro, ta );\\n\\n    vec3 colT = vec3(0);\\n    \\n    for (int x=0; x<AA; x++) {\\n        for(int y=0; y<AA; y++) {\\n\\t\\t    vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(x,y)/float(AA) - .5))/iResolution.y;\\n   \\t\\t\\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );  \\n            colT += render( ro, rd);           \\n        }\\n    }\\n    \\n    colT /= float(AA*AA);\\n    \\n    fragColor = vec4(colT, 1.0);\\n}\\n\\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\\n\\tMAX_T = 1000.;\\n    fragColor = vec4(render(ro * 25. + vec3(0.5,4.,1.5), rd), 1.);\\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lscBW4\\n//\\n// I have moved all ray-march code to this tab, in order to keep the IBL-code in the \\n// 'Image tab' more readable. The physically-based properties of the materials are also \\n// defined here.\\n//\\n// All (signed) distance field (SDF) code is copy-paste from the excellent framework by \\n// Inigo Quilez:\\n//\\n// https://www.shadertoy.com/view/Xds3zN\\n//\\n// More info here: https://iquilezles.org/articles/distfunctions\\n//\\n\\n#define MAT_TABLE    1.\\n#define MAT_PENCIL_0 2.\\n#define MAT_PENCIL_1 3.\\n#define MAT_PENCIL_2 4.\\n#define MAT_DIAL     5.\\n#define MAT_HAND     6.\\n#define MAT_METAL_0  7.\\n#define MAT_METAL_1  8.\\n\\n#define CLOCK_ROT_X -0.26\\n#define CLOCK_ROT_Y 0.2\\n#define CLOCK_OFFSET_Y 0.42\\n#define PENCIL_POS vec3(-0.31,-0.2, -.725)\\n\\nfloat MAX_T = 10.;\\n\\n//\\n// SDF functions (by Inigo Quilez).\\n//\\n\\nfloat sdPlane( const vec3 p ) {\\n\\treturn p.y;\\n}\\n\\nfloat sdTorus( const vec3 p, const vec2 t ) {\\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\\n  return length(q)-t.y;\\n}\\n\\nfloat sdTorusYZ( const vec3 p, const vec2 t ) {\\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\\n  return length(q)-t.y;\\n}\\n\\nfloat sdTorusYX( const vec3 p, const vec2 t ) {\\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\\n  return length(q)-t.y;\\n}\\n\\nfloat sdCylinder( const vec3 p, const vec2 h ) {\\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\n\\nfloat sdHexPrism( const vec3 p, const vec2 h ) {\\n    vec3 q = abs(p);\\n#if 0\\n    return max(q.x-h.y,max((q.z*0.866025+q.y*0.5),q.y)-h.x);\\n#else\\n    float d1 = q.x-h.y;\\n    float d2 = max((q.z*0.866025+q.y*0.5),q.y)-h.x;\\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\\n#endif\\n}\\n\\nfloat sdEllipsoid( const vec3 p, const vec3 r ) {\\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\\n}\\n\\nfloat sdCapsule( const vec3 p, const vec3 a, const vec3 b, const float r ) {\\n\\tvec3 pa = p-a, ba = b-a;\\n\\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\\n\\treturn length( pa - ba*h ) - r;\\n}\\n\\nfloat sdSphere( const vec3 p, const float r ) {\\n    return length(p) - r;\\n}\\n\\nfloat sdCone( const vec3 p, const vec2 c ) {\\n    float q = length(p.yz);\\n    return dot(c,vec2(q,p.x));\\n}\\n\\nfloat sdSegment2D( const vec2 p, const vec2 a, const vec2 b, const float w ) {\\n\\tvec2 pa = p-a, ba = b-a;\\n\\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\\n\\treturn length( pa - ba*h ) - w;\\n}\\n\\nfloat opS( const float d1, const float d2 ) {\\n    return max(-d1,d2);\\n}\\n\\nfloat opU( const float d1, const float d2 ) {\\n    return min(d1,d2);\\n}\\n\\nvec3 rotateX( in vec3 p, const float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    p.yz = mat2(co,-si,si,co)*p.yz;\\n    return p;\\n}\\n\\nvec3 rotateY( in vec3 p, const float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    p.xz = mat2(co,-si,si,co)*p.xz;\\n    return p;\\n}\\n\\nvec3 rotateZ( in vec3 p, const float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    p.xy = mat2(co,-si,si,co)*p.xy;\\n    return p;\\n}\\n\\nvec2 rotate( in vec2 p, const float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    p = mat2(co,-si,si,co) * p;\\n    return p;\\n}\\n\\n//\\n// Hash without Sine by Dave Hoskins.\\n//\\n\\nfloat hash11(float p) {\\n\\tvec3 p3  = fract(vec3(p) * .1031);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\n//\\n// SDF of the scene.\\n//\\n\\nfloat mapHand( const vec3 pos, const float w, const float l, const float r ) {\\n    float d = sdSegment2D(pos.xz, vec2(0,-w*10.), vec2(0,l), w);\\n    d = min(d, length(pos.xz) - (.03+r));\\n    return max(d, abs(pos.y)-.005);\\n}\\n\\nvec2 map( in vec3 pos, in vec3 p1, in vec3 ps, in vec3 pm, in vec3 ph, \\n         const bool watchIntersect, const bool pencilIntersect ) {\\n    //--- table\\n    vec2 res = vec2(sdPlane(pos), MAT_TABLE);\\n    \\n    // chain\\n    if (pos.z > 1.1) {\\n        float h = smoothstep(3., -.4, pos.z)*.74 + .045;\\n        float dChain0 = length(pos.xy+vec2(.3*sin(pos.z), -h))-.1;\\n        if (dChain0 < 0.1) {\\n            dChain0 = 10.;\\n            float pth1z = floor(pos.z*5.);\\n            if (pth1z > 5.) {\\n\\t            float pth1 = hash11(floor(pos.z*5.));\\n    \\t        vec3 pt1 = vec3(pos.x + .3*sin(pos.z)- pth1 *.02 + 0.02, pos.y-h - pth1 *.03, mod(pos.z, .2) - .1);\\n        \\t    pt1 = rotateZ(pt1, .6 * smoothstep(2.,3., pos.z));\\n            \\tdChain0 = sdTorus(pt1, vec2(.071, .02)); \\n            }\\n            \\n            float pth2z = floor(pos.z*5. + .5);\\n            float pth2 = hash11(pth2z); \\n            vec3 pt2 = vec3(pos.x + .3*sin(pos.z)- pth2 *.02 + 0.02, pos.y-h - pth2 *.03, mod(pos.z + .1, .2) - .1);\\n            pt2 = rotateZ(pt2, 1.1 * smoothstep(2.,3., pos.z));\\n            dChain0 = opU(dChain0, sdTorusYZ(pt2, vec2(.071, .02)));          \\n        }\\n        if (dChain0 < res.x) res = vec2(dChain0, MAT_METAL_1);\\n    }\\n    //--- pencil\\n    if (pencilIntersect) {\\n        float dPencil0 = sdHexPrism(pos + PENCIL_POS, vec2(.2, 2.));\\n        dPencil0 = opS(-sdCone(pos + (PENCIL_POS + vec3(-2.05,0,0)), vec2(.95,0.3122)),dPencil0);\\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.4,-2.82,-1.03)), 3.), dPencil0);\\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.5,-0.82,2.86)), 3.), dPencil0);\\n        if (dPencil0 < res.x) res = vec2(dPencil0, MAT_PENCIL_0);\\n\\n        float dPencil1 = sdCapsule(pos, -PENCIL_POS - vec3(2.2,0.,0.), -PENCIL_POS-vec3(2.55, 0., 0.), .21);\\n        if (dPencil1 < res.x) res = vec2(dPencil1, MAT_PENCIL_1);\\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\\n        float r = .02*abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\\n\\n        float dPencil2 = sdCylinderZY(pos + PENCIL_POS + vec3(2.25,-0.0125,0), vec2(.22 - r,.25));\\n        if (dPencil2 < res.x) res = vec2(dPencil2, MAT_PENCIL_2);\\n    }\\n    \\n    //--- watch\\n    if (watchIntersect) {\\n        float dDial = sdCylinder(p1, vec2(1.05,.13));\\n        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);\\n\\n        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));\\n        if (dC < res.x) res = vec2(dC, MAT_METAL_1);\\n        \\n        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   \\n        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));\\n        if(bb < 0.5) {\\n            float a = atan(p1.y, p1.x);\\n            float c = abs(fract(a*3.1415)-.5);\\n            float d = min(abs(p1.z-1.3), .02);\\n            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15 - 40.*d*d - .1*c*c,0.04));\\n        } \\n        dM = opU(dM, bb);\\n         \\n        dM = opU(dM, sdCylinderZY(p1+vec3(0,0,-1.18), vec2(0.06,0.2)));\\n        float rr = min(abs(p1.z-1.26), .2);\\n        dM = opU(dM, sdCylinderXY(p1+vec3(0,0,-1.2), vec2(0.025 + 0.35*rr,0.1)));\\n       \\n        p1.y = abs(p1.y);\\n        dM = opU(dM, sdTorus(p1 + vec3(0,-.1,0), vec2(1.025,.075)));\\n        dM = opU(dM, sdCylinder(p1, vec2(1.1,.1)));\\n        dM = opS(sdTorus(p1 + vec3(0,-.1,0), vec2(1.11,.015)), dM);\\n        dM = opU(dM, sdCylinder(p1, vec2(0.01,0.175)));\\n        dM = opU(dM, sdCylinder(p1+vec3(0,0,.6), vec2(0.01,0.155)));\\n        if (dM < res.x) res = vec2(dM, MAT_METAL_0);\\n\\n        // minutes hand\\n        float dMin = mapHand(pm + vec3(0,-.16,0), .02, 0.7, 0.015);\\n        if (dMin < res.x) res = vec2(dMin, MAT_HAND);\\n        // hours hand\\n        float dHour = mapHand(ph + vec3(0,-.15,0), .02, 0.4, 0.03);\\n        if (dHour < res.x) res = vec2(dHour, MAT_HAND);\\n        // seconds hand\\n        float dSeconds = mapHand(ps + vec3(0,-.14,0), .01, 0.17, 0.006);\\n        if (dSeconds < res.x) res = vec2(dSeconds, MAT_HAND);\\n    }\\n    \\n    return res;\\n}\\n\\nvec2 map( in vec3 pos ) {\\n    vec3 p1 = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\\n    p1 = rotateY( p1, CLOCK_ROT_Y );\\n    \\n\\tfloat secs = mod( floor(iDate.w),        60.0 );\\n\\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\\n\\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\\n    \\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\\n    \\n    return map( pos, p1, ps, pm, ph, true, true );\\n}\\n\\nfloat mapGlass( in vec3 pos ) {\\n    return sdEllipsoid( pos - vec3(0,.10,0), vec3(1.,.2,1.) );\\n}\\n\\n//\\n// Ray march code.\\n//\\n\\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float r ) {\\n\\tvec3 oc = ro;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - r * r;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return vec2(-1.0);\\n    h = sqrt( h );\\n\\treturn vec2(-b - h, -b + h);\\n}\\n\\nbool boxIntserct( in vec3 ro, in vec3 rd, in vec3 rad ) {\\n    vec3 m = 1.0/rd;\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*rad;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n\\tif( tN > tF || tF < 0.0) return false;\\n\\n\\treturn true;\\n}\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    const vec2 e = vec2(1.0,-1.0)*0.0075;\\n    return normalize( e.xyy*map( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map( pos + e.xxx ).x );\\n}\\n\\nvec2 castRay( in vec3 ro, in vec3 rd ) {\\n    float tmin = 0.5;\\n    float tmax = MAX_T;\\n    \\n    // bounding volume\\n    const float top = 0.95;\\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\\n    float tp2 = (top-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>top ) tmin = max( tmin, tp2 );\\n                                                 else           tmax = min( tmax, tp2 ); }\\n    \\n    float t = tmin;\\n    float mat = -1.;\\n    \\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\\n    p1 = rotateY( p1, CLOCK_ROT_Y );\\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\\n    \\n\\tfloat secs = mod( floor(iDate.w),        60.0 );\\n\\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\\n\\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\\n    \\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\\n    \\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\\n    \\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\\n    \\n    bool watchIntersect = boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\\n    bool pencilIntersect = boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\\n    \\n    for( int i=0; i<48; i++ ) {\\n\\t    float precis = 0.00025*t;\\n\\t    vec2 res = map( ro+rd*t, p1+rd1*t, ps+rds*t, pm+rdm*t, ph+rdh*t, \\n                       watchIntersect, pencilIntersect );\\n        if( res.x<precis || t>tmax ) break; //return vec2(t, mat);\\n        t += res.x;\\n        mat = res.y;\\n    }\\n\\n    if( t>tmax ) t=-1.0;\\n    return vec2(t, mat);\\n}\\n\\nvec3 calcNormalGlass( in vec3 pos ) {\\n    const vec2 e = vec2(1.0,-1.0)*0.005;\\n    return normalize( e.xyy*mapGlass( pos + e.xyy ) + \\n\\t\\t\\t\\t\\t  e.yyx*mapGlass( pos + e.yyx ) + \\n\\t\\t\\t\\t\\t  e.yxy*mapGlass( pos + e.yxy ) + \\n\\t\\t\\t\\t\\t  e.xxx*mapGlass( pos + e.xxx ) );\\n}\\n\\nfloat castRayGlass( in vec3 ro, in vec3 rd ) {\\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\\n    p1 = rotateY( p1, CLOCK_ROT_Y );\\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\\n\\n    float t = -1.;\\n    vec2 bb = sphIntersect( p1- vec3(0,.10,0), rd1, 1.);\\n    if (bb.y > 0.) {\\n        t = max(bb.x, 0.);\\n        float tmax = bb.y;\\n        for( int i=0; i<24; i++ ) {\\n            float precis = 0.00025*t;\\n            float res = mapGlass( p1+rd1*t );\\n            if( res<precis || t>tmax ) break; \\n            t += res;\\n        }\\n\\n        if( t>tmax ) t=-1.0;\\n    }\\n    return t;\\n}\\n\\n\\nfloat calcAO( in vec3 ro, in vec3 rd ) {\\n\\tfloat occ = 0.0;\\n    float sca = 1.0;\\n    \\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\\n    p1 = rotateY( p1, CLOCK_ROT_Y );\\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\\n    \\n\\tfloat secs = mod( floor(iDate.w),        60.0 );\\n\\tfloat mins = mod( floor(iDate.w/60.0),   60.0 );\\n\\tfloat hors = mod( floor(iDate.w/3600.0), 24.0 ) + mins/60.;\\n    \\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\\n    \\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\\n    \\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\\n    \\n    bool watchIntersect = true; //boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\\n    bool pencilIntersect = true; //boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\\n    \\n    \\n    for( int i=0; i<6; i++ ) {\\n        float h = 0.001 + 0.25*float(i)/5.0;\\n        float d = map( ro+rd*h, p1+rd1*h, ps+rds*h, pm+rdm*h, ph+rdh*h, \\n                       watchIntersect, pencilIntersect ).x;\\n        occ += (h-d)*sca;\\n        sca *= 0.95;\\n    }\\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \\n}\\n\\n//\\n// Material properties.\\n//\\n\\nvec4 texNoise( sampler2D sam, in vec3 p, in vec3 n ) {\\n\\tvec4 x = texture( sam, p.yz );\\n\\tvec4 y = texture( sam, p.zx );\\n\\tvec4 z = texture( sam, p.xy );\\n\\n\\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\\n}\\n\\nvoid getMaterialProperties(\\n    in vec3 pos, in float mat,\\n    inout vec3 normal, inout vec3 albedo, inout float ao, inout float roughness, inout float metallic,\\n\\tsampler2D tex1, sampler2D tex2, sampler2D tex3) {\\n    \\n    vec3 pinv = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\\n    pinv = rotateY( pinv, CLOCK_ROT_Y );\\n    \\n    normal = calcNormal( pos );\\n    ao = calcAO(pos, normal);\\n    metallic = 0.;\\n    \\n    vec4 noise = texNoise(tex1, pinv * .5, normal);\\n    float metalnoise = 1.- noise.r;\\n    metalnoise*=metalnoise;\\n\\n    mat -= .5;\\n    if (mat < MAT_TABLE) {\\n        albedo = .7 * pow(texture(tex1, rotate(pos.xz * .4 + .25, -.3)).rgb, 2.2*vec3(0.45,0.5,0.5));\\n        roughness = 0.95 - albedo.r * .6;\\n    }\\n    else if( mat < MAT_PENCIL_0 ) {\\n        vec2 npos = pos.yz + PENCIL_POS.yz;\\n        if (length(npos) < 0.055) {\\n        \\talbedo = vec3(0.02);\\n        \\troughness = .9;\\n        } else if(sdHexPrism(pos + PENCIL_POS, vec2(.195, 3.)) < 0.) {\\n        \\talbedo = .8* texture(tex1, pos.xz).rgb;\\n        \\troughness = 0.99;\\n        } else {\\n        \\talbedo = .5*pow(vec3(1.,.8,.15), vec3(2.2));\\n        \\troughness = .75 - noise.b * .4;\\n        }\\n        albedo *= noise.g * .75 + .7;\\n    }\\n    else if( mat < MAT_PENCIL_1 ) {\\n       \\talbedo = .4*pow(vec3(.85,.75,.55), vec3(2.2));\\n       \\troughness = 1.;\\n    }\\n    else if( mat < MAT_PENCIL_2 ) {\\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\\n        float r = 1. - abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\\n\\n        r -= 4. * metalnoise;  \\n        ao *= .5 + .5 * r;\\n\\t    albedo = mix(vec3(0.5, 0.3, 0.2),vec3(0.560, 0.570, 0.580), ao * ao); // Iron\\n   \\t\\troughness = 1.-.25*r;\\n   \\t\\tmetallic = 1.; \\n    }\\n    else if( mat < MAT_DIAL ) {\\n        float dial = texture(tex2, vec2(-.5 * pinv.x + .5, +.5 * pinv.z + .5)).r;\\n        albedo = vec3(dial);\\n        roughness = dial + .95;\\n    }\\n    else if( mat < MAT_HAND ) {\\n        albedo = vec3(0.02);\\n        roughness = .65;\\n    }\\n    else if( mat < MAT_METAL_0 ) {\\n\\t    albedo = vec3(1.000, 0.766, 0.336); // Gold\\n   \\t\\troughness = .6;\\n   \\t\\tmetallic = 1.; \\n    } \\n    else if( mat < MAT_METAL_1 ) {\\n\\t    albedo = vec3(0.972, 0.960, 0.915); // Silver\\n   \\t\\troughness = .7 + max(.15 * length(pos.xz)-.3, 0.); // prevent aliasing\\n   \\t\\tmetallic = 1.; \\n    }\\n    \\n    if (mat < MAT_PENCIL_2) {\\n        ao = min(ao, smoothstep(.95, 1.5, length(pos.xz)));\\n    }\\n    \\n    if (metallic > .5) {   \\n        albedo *= 1.-metalnoise;\\n        roughness += metalnoise*4.;\\n    }\\n    \\n    ao = clamp(.1+.9*ao, 0., 1.);\\n    roughness = clamp(roughness, 0., 1.);\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta ) {\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(0.0, 1.0,0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lscBW4\\n//\\n// In this buffer the albedo of the dial (red channel) and the roughness\\n// of the glass (green channel) is pre-calculated.\\n//\\n\\nbool resolutionChanged() {\\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\\n}\\n\\nfloat printChar(vec2 uv, uint char) {\\n    float d = textureLod(iChannel1, (uv + vec2( char & 0xFU, 0xFU - (char >> 4))) / 16.,0.).a;\\n\\treturn smoothstep(1.,0., smoothstep(.5,.51,d));\\n}\\n\\nfloat dialSub( in vec2 uv, float wr ) {\\n    float r = length( uv );\\n    float a = atan( uv.y, uv.x )+3.1415926;\\n\\n    float f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\\n    float g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\\n    float w = fwidth(f);\\n    f = 1.0 - smoothstep( 0.2*g+0.05-w, 0.2*g+0.05+w, f );\\n    float s = abs(fwidth(r));\\n    f *= smoothstep( 0.9 - wr -s, 0.9 - wr, r ) - smoothstep( 0.9, 0.9+s, r );\\n    float hwr = wr * .5;\\n    f -= 1.-smoothstep(hwr+s,hwr,abs(r-0.9+hwr)) - smoothstep(hwr-s,hwr,abs(r-0.9+hwr));\\n\\n    return .1 + .8 * clamp(1.-f,0.,1.);\\n}\\n\\nfloat dial(vec2 uv) {\\n    float d = dialSub(uv, 0.05);\\n\\n    vec2 uvs = uv;\\n    \\n    uvs.y += 0.6;\\n    uvs *= 1./(0.85-0.6);\\n\\n    d = min(d, dialSub(uvs, 0.1));\\n    \\n    vec2 center = vec2(0.5);\\n    vec2 radius = vec2(3.65, 0.);\\n    \\n    for (int i=0; i<9; i++) {\\n        if(i!=5) {\\n\\t        float a = 6.28318530718 * float(i+4)/12.;\\n    \\t    vec2 uvt = clamp(uv * 5. + center + rotate(radius, a), vec2(0), vec2(1));\\n        \\td = mix(d, 0.3, printChar(uvt, uint(49+i)));\\n        }\\n    }\\n    for (int i=0; i<3; i++) {\\n\\t    float a = 6.28318530718 * float(i+13)/12.;\\n    \\tvec2 uvt1 = clamp(uv * 5. + center + rotate(radius, a) + vec2(.25,0.), vec2(0), vec2(1));\\n        d = mix(d, 0.3, printChar(uvt1, uint(49)));\\n    \\tvec2 uvt = clamp(uv * 5. + center + rotate(radius, a)+ vec2(-.15,0.), vec2(0), vec2(1));\\n        d = mix(d, 0.3, printChar(uvt, uint(48+i)));\\n    }\\n    \\n    d *= .9 + .25*texture(iChannel2, uv*.5+.5).r;\\n    \\n    return pow(clamp(d, 0., 1.), 2.2);\\n}\\n\\nfloat roughnessGlass(vec2 uv) {\\n    uv = uv * .5 + .5;\\n    return smoothstep(0.2, 0.8, texture(iChannel2, uv * .3).r) * .4 + .2;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \\n    if(resolutionChanged() && iChannelResolution[1].x > 0.  && iChannelResolution[2].x > 0.) {\\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\\n            fragColor = floor(iResolution.xyxy);\\n        } else {\\n            vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.xy;\\n\\n            fragColor = vec4( dial(uv), roughnessGlass(uv), 0., 1.0 );      \\n        }\\n    } else {\\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Old watch (IBL). Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lscBW4\\n//\\n// In this buffer I pre-calculate the BRDF integration map, as described in:\\n// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\\n//\\n\\nconst float PI = 3.14159265359;\\n\\n// see: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\\nfloat PartialGeometryGGX(float NdotV, float a) {\\n    float k = a / 2.0;\\n\\n    float nominator   = NdotV;\\n    float denominator = NdotV * (1.0 - k) + k;\\n\\n    return nominator / denominator;\\n}\\n\\nfloat GeometryGGX_Smith(float NdotV, float NdotL, float roughness) {\\n    float a = roughness*roughness;\\n    float G1 = PartialGeometryGGX(NdotV, a);\\n    float G2 = PartialGeometryGGX(NdotL, a);\\n    return G1 * G2;\\n}\\n\\nfloat RadicalInverse_VdC(uint bits) {\\n    bits = (bits << 16u) | (bits >> 16u);\\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\\n}\\n\\nvec2 Hammersley(int i, int N) {\\n    return vec2(float(i)/float(N), RadicalInverse_VdC(uint(i)));\\n} \\n\\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness) {\\n    float a = roughness*roughness;\\n    float phi      = 2.0 * PI * Xi.x;\\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\\n\\n    vec3 HTangent;\\n    HTangent.x = sinTheta*cos(phi);\\n    HTangent.y = sinTheta*sin(phi);\\n    HTangent.z = cosTheta;\\n\\n    return HTangent;\\n}\\n\\nvec2 IntegrateBRDF(float roughness, float NdotV) {\\n    vec3 V;\\n    V.x = sqrt(1.0 - NdotV*NdotV);\\n    V.y = 0.0;\\n    V.z = NdotV;\\n\\n    float A = 0.0;\\n    float B = 0.0;\\n\\n    const int SAMPLE_COUNT = 128;\\n\\n    vec3 N = vec3(0.0, 0.0, 1.0);\\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\\n    vec3 TangentX = normalize(cross(UpVector, N));\\n    vec3 TangentY = cross(N, TangentX);\\n\\n    for(int i = 0; i < SAMPLE_COUNT; ++i)  {\\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\\n        vec3 HTangent = ImportanceSampleGGX(Xi, roughness);\\n        \\n        vec3 H = normalize(HTangent.x * TangentX + HTangent.y * TangentY + HTangent.z * N);\\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\\n\\n        float NdotL = max(L.z, 0.0);\\n        float NdotH = max(H.z, 0.0);\\n        float VdotH = max(dot(V, H), 0.0);\\n\\n        if(NdotL > 0.0) {\\n            float G = GeometryGGX_Smith(NdotV, NdotL, roughness);\\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\\n            float Fc = pow(1.0 - VdotH, 5.0);\\n\\n            A += (1.0 - Fc) * G_Vis;\\n            B += Fc * G_Vis;\\n        }\\n    }\\n    A /= float(SAMPLE_COUNT);\\n    B /= float(SAMPLE_COUNT);\\n    return vec2(A, B);\\n}\\n\\nbool resolutionChanged() {\\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    if(resolutionChanged()) {\\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\\n            fragColor = floor(iResolution.xyxy);\\n        } else {\\n\\t   \\t\\tvec2 uv = fragCoord / iResolution.xy;\\n    \\t\\tvec2 integratedBRDF = IntegrateBRDF(uv.y, uv.x);\\n   \\t \\t\\tfragColor = vec4(integratedBRDF, 0.0,1.0);\\n        }\\n    } else {\\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\\n    }\\n}","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MdGfzh","date":"1527594357","viewed":40254,"name":"Himalayas","description":"This is my first attempt to render volumetric clouds in a fragment shader. I started this shader by trying to model the clouds of Horizon Zero Dawn and render them using the integration method of volumetric media as described by Sbastien Hillaire (SebH).","likes":438,"published":"Public API","usePreview":0,"tags":["volume","clouds","light","sky","volumetric","scattering","realtime","atmospheric","cloudscape","himalayas"]},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Himalayas. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MdGfzh\\n//\\n// This is my first attempt to render volumetric clouds in a fragment shader.\\n//\\n// I started this shader by trying to implement the clouds of Horizon Zero Dawn, as\\n// described in \\"The real-time volumetric cloudscapes of Horizon Zero Dawn\\" by \\n// Andrew Schneider and Nathan Vos.[1] To model the shape of the clouds, two look-up\\n// textures are created with different frequencies of (Perlin -) Worley noise:\\n//\\n// Buffer A: The main look-up texture for the cloud shapes. \\n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \\n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\\n//           \\n// Because it is not possible (yet) to create buffers with fixed size, or 3D buffers, the\\n// look-up texture in Buffer A is 2D, and a slice of the volume that is described in the \\n// article. Therefore, and because I didn't have any slots left (in Buffer C) to use a \\n// cloud type/cloud coverage texture, the modelling of the cloud shapes in this shader is \\n// in the end mostly based on trial and error, and is probably far from the code used in \\n// Horizon Zero Dawn.\\n//\\n// Buffer D: Rendering of the clouds.\\n//\\n// I render the clouds using the improved integration method of volumetric media, as described \\n// in \\"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\\" by \\n// Sbastien Hillaire.[2]\\n//\\n// You can find the (excellent) example shaders of Sbastien Hillaire (SebH) here:\\n//\\n// https://www.shadertoy.com/view/XlBSRz\\n// https://www.shadertoy.com/view/MdlyDs\\n//\\n// Buffer C: Landscape\\n//\\n// To create an interesting scene and to add some scale to the clouds, I render a \\n// terrain using a simple heightmap, based on the work by igo Qulez on value noise and its \\n// analytical derivatives.[3]\\n//\\n// In fact, the heightmap of this shader is almost exactly the same as the heightmap that \\n// is used in igo Qulez' shader Elevated:\\n//\\n// https://www.shadertoy.com/view/MdX3Rr\\n//\\n// To reduce noise I use temporal reprojection (both for clouds (Buffer D) and the terrain \\n// (Buffer C)) separatly. The temporal reprojection code is based on code from the shader\\n// \\"Rain Forest\\" (again by igo Qulez):\\n//\\n// https://www.shadertoy.com/view/4ttSWf\\n// \\n// Finally, in the Image tab, clouds and terrain are combined, a small humanoid is added\\n// (by Hazel Quantock) and post processing is done.\\n//\\n// [1] https://www.guerrilla-games.com/read/the-real-time-volumetric-cloudscapes-of-horizon-zero-dawn\\n// [2] https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\\n// [3] https://iquilezles.org/articles/morenoise\\n//\\n\\n#define AA 3\\n\\n//\\n// Cheap 2D Humanoid SDF for dropping into scenes to add a sense of scale.\\n// Hazel Quantock 2018\\n//\\n// Based on: https://www.shadertoy.com/view/4scBWN\\n//\\nfloat RoundMax( float a, float b, float r ) {\\n    a += r; b += r;    \\n    float f = ( a > 0. && b > 0. ) ? sqrt(a*a+b*b) : max(a,b);    \\n    return f - r;\\n}\\n\\nfloat RoundMin( float a, float b, float r ) {\\n    return -RoundMax(-a,-b,r);\\n}\\n\\nfloat Humanoid( in vec2 uv, in float phase ) {\\n    float n3 = sin((uv.y-uv.x*.7)*11.+phase)*.014; // \\"pose\\"\\n    float n0 = sin((uv.y+uv.x*1.1)*23.+phase*2.)*.007;\\n    float n1 = sin((uv.y-uv.x*.8)*37.+phase*4.)*.004;\\n    float n2 = sin((uv.y+uv.x*.9)*71.+phase*8.)*.002;\\n\\n    \\n    float head = length((uv-vec2(0,1.65))/vec2(1,1.2))-.15/1.2;\\n    float neck = length(uv-vec2(0,1.5))-.05;\\n    float torso = abs(uv.x)-.25 - uv.x*.3;\\n\\n    torso = RoundMax( torso, uv.y-1.5, .2 );\\n    torso = RoundMax( torso, -(uv.y-.6), .0 );\\n\\n    float f = RoundMin(head,neck,.04);\\n    f = RoundMin(f,torso,.02);\\n    \\n    float leg = abs(abs(uv.x+(uv.y-.9)*.1*cos(phase*3.))-.15+.075*uv.y)-.07-.07*uv.y; \\n    leg = max( leg, uv.y-1. );\\n    \\n    f = RoundMin(f,leg,.1);\\n\\n    float stick = max(abs(uv.x+.4-uv.y*.04)-0.025, uv.y-1.15);\\n    float arm = max(max(abs(uv.y-1.-uv.x*.3) - .06, uv.x), -uv.x-.4);\\n    \\n    f = RoundMin(f, stick, 0.0);\\n    f = RoundMin(f, arm, 0.05);\\n    \\n    f += (-n0+n1+n2+n3)*(.1+.9*uv.y/1.6);\\n    \\n    return max( f, -uv.y );\\n}\\n\\n//\\n// Lens flare, original based on:\\n// musk's lens flare by mu6k  \\n//\\n// https://www.shadertoy.com/view/4sX3Rs\\n//\\nfloat lensflare(vec2 fragCoord) {\\n    vec3 ro, ta;\\n    mat3 cam = getCamera( iTime, iMouse/iResolution.xyxy, ro, ta );\\n    vec3 cpos = SUN_DIR*cam; \\n    vec2 pos = CAMERA_FL * cpos.xy / cpos.z;\\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\\n    \\n\\tvec2 uvd = uv*(length(uv));\\n\\tfloat f = 0.1/(length(uv-pos)*16.0+1.0);\\n\\tf += max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*0.25;\\n\\tvec2 uvx = mix(uv,uvd,-0.5);\\n\\tf += max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\\n\\tf += max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\\n\\tuvx = mix(uv,uvd,-0.4);\\n\\tf += max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\\n    \\n\\treturn f;\\n}\\n\\nbool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph ) {\\n    vec3  ds = ro - sph.xyz;\\n    float bs = dot(rd, ds);\\n    float cs = dot(ds, ds) - sph.w*sph.w;\\n    float ts = bs*bs - cs;\\n\\t\\n    if( ts > 0.0 ) {\\n        ts = -bs - sqrt( ts );\\n\\t\\tif( ts>0. ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n    }\\n    return false;\\n}\\n\\nbool intersectPlane (in vec3 ro, in vec3 rd, in vec3 n, in vec3 p0, inout float dist) {   \\n    dist = dot(p0 - ro, n)/dot(rd,n);\\n    return dist > 0.;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \\n    if( letterBox(fragCoord, iResolution.xy, 2.35) ) {\\n        fragColor = vec4( 0., 0., 0., 1. );\\n    } else {\\n        vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\\n        vec4 clouds = texelFetch(iChannel1, ivec2(fragCoord), 0);\\n    \\t\\n        col.rgb = clouds.rgb + col.rgb * clouds.a;\\n       \\n        vec3 ro, rd, ta;\\n\\t\\tmat3 cam = getCamera( iTime, iMouse/iResolution.xyxy, ro, ta );\\n        float dist;\\n        vec4 tcol = vec4(0.);\\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\\n        rd = cam * normalize(vec3(p,CAMERA_FL)); \\n        \\n        if (intersectSphere(ro,rd,vec4(FLAG_POSITION,HUMANOID_SCALE*INV_SCENE_SCALE*2.))) {\\n            for(int x=0; x<AA; x++) {\\n                for(int y=0; y<AA; y++) {\\n                    vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(x,y)/float(AA) - .5))/iResolution.y;\\n                    rd = cam * normalize(vec3(p,CAMERA_FL)); \\n\\n                    if (intersectPlane(ro, rd, vec3(0,0,1), FLAG_POSITION, dist) && dist < col.w) {\\n                        vec3 pos = ro + rd * dist;\\n                        vec2 uv = (pos.xy - FLAG_POSITION.xy)*(SCENE_SCALE/HUMANOID_SCALE);\\n                        uv.x = -uv.x + uv.y*0.05;\\n                        float sdf = Humanoid( uv, 3. );\\n                        float a = smoothstep(.4,.6,.5-.5*sdf/(abs(sdf)+.002));\\n                        float sdf2 = Humanoid( uv+vec2(.025,0.05), 3. );\\n                        float a2 = smoothstep(.4,.6,.5-.5*sdf2/(abs(sdf2)+.002));\\n                        float c = (a-a2)*2.;\\n                        c = clamp(c+uv.x*.2+.6,0.,1.); c*=c; c*=c;\\n                        tcol += vec4(mix(vec3(.04,0.05,0.06),SUN_COLOR,c),a);\\n                    }\\n                }\\n            }\\n            tcol /= float(AA*AA);\\n        }\\n        \\n        col.rgb = mix(col.rgb, tcol.rgb, tcol.w);    \\n            \\n        // lens flare\\n        col.rgb += SUN_COLOR*lensflare(fragCoord)*smoothstep(-.3,.5,dot(rd,SUN_DIR));       \\n        col.rgb = clamp(col.rgb, vec3(0), vec3(1));\\n        \\n        // gamma and contrast\\n        col.rgb = mix(col.rgb, pow(col.rgb, vec3(1./2.2)), .85);\\n        col.rgb = mix( col.rgb, col.bbb, 0.2 ); \\n     \\n        // vignette\\n        vec2 uv = fragCoord / iResolution.xy;\\n        col.rgb = mix(col.rgb*col.rgb, col.rgb, pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ));\\n        \\n        // noise\\n        col.rgb -= hash12(fragCoord)*.025;\\n        \\n        fragColor = vec4( col.rgb, 1. );\\n    }\\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Himalayas. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MdGfzh\\n//\\n// This is my first attempt to render volumetric clouds in a fragment shader.\\n//\\n// 1 unit correspondents to SCENE_SCALE meter.\\n\\n#define SCENE_SCALE (10.)\\n#define INV_SCENE_SCALE (.1)\\n\\n#define MOUNTAIN_HEIGHT (5000.)\\n#define MOUNTAIN_HW_RATIO (0.00016)\\n\\n#define SUN_DIR normalize(vec3(-.7,.5,.75))\\n#define SUN_COLOR (vec3(1.,.9,.85)*1.4)\\n\\n#define FLAG_POSITION (vec3(3900.5,720.,-2516.)*INV_SCENE_SCALE)\\n#define HUMANOID_SCALE (2.)\\n\\n#define CAMERA_RO (vec3(3980.,730.,-2650.)*INV_SCENE_SCALE)\\n#define CAMERA_FL 2.\\n\\n#define HEIGHT_BASED_FOG_B 0.02\\n#define HEIGHT_BASED_FOG_C 0.05\\n\\n\\nmat3 getCamera( in float time, in vec4 mouse, inout vec3 ro, inout vec3 ta ) {\\n    ro = CAMERA_RO;\\n    vec3 cw;\\n    if (mouse.z > 0.) {\\n        vec2 m = (mouse.xy - .5) * 2.3;\\n        float my = -sin(m.y);\\n        cw = normalize(vec3(-sin(-m.x), my+.15, cos(-m.x)));\\n    } else {\\n    \\tro.x += -cos(time*.13)*5.*INV_SCENE_SCALE;\\n    \\tro.z += (-cos(time*.1)*100.+20.)*INV_SCENE_SCALE;\\n    \\tcw = normalize(vec3(-.1,.18,1.));\\n    }   \\n    ta = ro + cw*(200.*INV_SCENE_SCALE);\\n\\tvec3 cp = vec3(0.0,1.0, 0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid getRay( in float time, in vec2 fragCoord, in vec2 resolution, in vec4 mouse, inout vec3 ro, inout vec3 rd) {\\n\\tvec3 ta;\\n\\tmat3 cam = getCamera( time, mouse, ro, ta );\\n    vec2 p = (-resolution.xy + 2.0*(fragCoord))/resolution.y;\\n    rd = cam * normalize(vec3(p,CAMERA_FL));     \\n}\\n\\n//\\n// To reduce noise I use temporal reprojection (both for clouds (Buffer D) and the terrain \\n// (Buffer C) seperatly. The temporal repojection code is based on code from the shader\\n// \\"Rain Forest\\" (again by igo Qulez):\\n//\\n// https://www.shadertoy.com/view/4ttSWf\\n// \\nvec4 saveCamera( in float time, in vec2 fragCoord, in vec4 mouse ) {   \\n    vec3 ro, ta;\\n    mat3 cam = getCamera( time, mouse, ro, ta );\\n    vec4 fragColor;\\n    \\n    if( abs(fragCoord.x-4.5)<0.5 ) fragColor = vec4( cam[2], -dot(cam[2],ro) );\\n    if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( cam[1], -dot(cam[1],ro) );\\n    if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( cam[0], -dot(cam[0],ro) );\\n    \\n    return fragColor;\\n}\\n\\nvec2 reprojectPos( in vec3 pos, in vec2 resolution, in sampler2D storage ) {\\n    mat4 oldCam = mat4( texelFetch(storage,ivec2(2,0),0),\\n                        texelFetch(storage,ivec2(3,0),0),\\n                        texelFetch(storage,ivec2(4,0),0),\\n                        0.0, 0.0, 0.0, 1.0 );\\n\\n    vec4 wpos = vec4(pos,1.0);\\n    vec3 cpos = (wpos*oldCam).xyz; \\n    vec2 npos = CAMERA_FL * cpos.xy / cpos.z;\\n    return 0.5 + 0.5*npos*vec2(resolution.y/resolution.x,1.0);\\n}\\n\\n//\\n// Fast skycolor function by igo Qulez\\n// https://www.shadertoy.com/view/MdX3Rr\\n//\\nvec3 getSkyColor(vec3 rd) {\\n    float sundot = clamp(dot(rd,SUN_DIR),0.0,1.0);\\n\\tvec3 col = vec3(0.2,0.5,0.85)*1.1 - max(rd.y,0.01)*max(rd.y,0.01)*0.5;\\n    col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow(1.0-max(rd.y,0.0), 6.0) );\\n\\n    col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\\n    col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\\n    col += 0.20*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\\n    \\n    col += clamp((0.1-rd.y)*10., 0., 1.) * vec3(.0,.1,.2);\\n    col += 0.2*vec3(1.0,0.8,0.6)*pow( sundot, 8.0 );\\n    return col;\\n}\\n\\nbool letterBox(vec2 fragCoord, const vec2 resolution, const float aspect) { \\n    if( fragCoord.x < 0. || fragCoord.x > resolution.x ||\\n        abs(2.*fragCoord.y-resolution.y) > resolution.x * (1./aspect) ) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\n//\\n// Noise functions\\n//\\n// Hash without Sine by DaveHoskins \\n//\\n// https://www.shadertoy.com/view/4djSRW\\n//\\nfloat hash12( vec2 p ) {\\n    p  = 50.0*fract( p*0.3183099 );\\n    return fract( p.x*p.y*(p.x+p.y) );\\n}\\n\\nfloat hash13(vec3 p3) {\\n    p3  = fract(p3 * 1031.1031);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\nvec3 hash33(vec3 p3) {\\n\\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\\n    p3 += dot(p3, p3.yxz+19.19);\\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\\n}\\n\\nfloat valueHash(vec3 p3) {\\n    p3  = fract(p3 * 0.1031);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\n//\\n// Noise functions used for cloud shapes\\n//\\nfloat valueNoise( in vec3 x, float tile ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n\\t\\n    return mix(mix(mix( valueHash(mod(p+vec3(0,0,0),tile)), \\n                        valueHash(mod(p+vec3(1,0,0),tile)),f.x),\\n                   mix( valueHash(mod(p+vec3(0,1,0),tile)), \\n                        valueHash(mod(p+vec3(1,1,0),tile)),f.x),f.y),\\n               mix(mix( valueHash(mod(p+vec3(0,0,1),tile)), \\n                        valueHash(mod(p+vec3(1,0,1),tile)),f.x),\\n                   mix( valueHash(mod(p+vec3(0,1,1),tile)), \\n                        valueHash(mod(p+vec3(1,1,1),tile)),f.x),f.y),f.z);\\n}\\n\\nfloat voronoi( vec3 x, float tile ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n\\n    float res = 100.;\\n    for(int k=-1; k<=1; k++){\\n        for(int j=-1; j<=1; j++) {\\n            for(int i=-1; i<=1; i++) {\\n                vec3 b = vec3(i, j, k);\\n                vec3 c = p + b;\\n\\n                if( tile > 0. ) {\\n                    c = mod( c, vec3(tile) );\\n                }\\n\\n                vec3 r = vec3(b) - f + hash13( c );\\n                float d = dot(r, r);\\n\\n                if(d < res) {\\n                    res = d;\\n                }\\n            }\\n        }\\n    }\\n\\n    return 1.-res;\\n}\\n\\nfloat tilableVoronoi( vec3 p, const int octaves, float tile ) {\\n    float f = 1.;\\n    float a = 1.;\\n    float c = 0.;\\n    float w = 0.;\\n\\n    if( tile > 0. ) f = tile;\\n\\n    for( int i=0; i<octaves; i++ ) {\\n        c += a*voronoi( p * f, f );\\n        f *= 2.0;\\n        w += a;\\n        a *= 0.5;\\n    }\\n\\n    return c / w;\\n}\\n\\nfloat tilableFbm( vec3 p, const int octaves, float tile ) {\\n    float f = 1.;\\n    float a = 1.;\\n    float c = 0.;\\n    float w = 0.;\\n\\n    if( tile > 0. ) f = tile;\\n\\n    for( int i=0; i<octaves; i++ ) {\\n        c += a*valueNoise( p * f, f );\\n        f *= 2.0;\\n        w += a;\\n        a *= 0.5;\\n    }\\n\\n    return c / w;\\n}\\n\\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Himalayas. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MdGfzh\\n//\\n// This is my first attempt to render volumetric clouds in a fragment shader.\\n//\\n// Buffer A: The main look-up texture for the cloud shapes. \\n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \\n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\\n// \\nbool resolutionChanged() {\\n    return floor(texelFetch(iChannel1, ivec2(0), 0).r) != floor(iResolution.x);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \\n    if (resolutionChanged()) {\\n        vec2 vUV = fragCoord / iResolution.xy;\\n        vec3 coord = fract(vec3(vUV + vec2(.2,0.62), .5));\\n        \\n        vec4 col = vec4(1);\\n        \\n        float mfbm = 0.9;\\n        float mvor = 0.7;\\n        \\n        col.r = mix(1., tilableFbm( coord, 7, 4. ), mfbm) * \\n            \\tmix(1., tilableVoronoi( coord, 8, 9. ), mvor);\\n        col.g = 0.625 * tilableVoronoi( coord + 0., 3, 15. ) +\\n        \\t\\t0.250 * tilableVoronoi(  coord + 0., 3, 19. ) +\\n        \\t\\t0.125 * tilableVoronoi( coord + 0., 3, 23. ) \\n            \\t-1.;\\n        col.b = 1. - tilableVoronoi( coord + 0.5, 6, 9. );\\n        \\n\\t    fragColor = col;\\n    } else {\\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Himalayas. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MdGfzh\\n//\\n// This is my first attempt to render volumetric clouds in a fragment shader.\\n//\\n// Buffer A: The main look-up texture for the cloud shapes. \\n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \\n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\\n// \\nbool resolutionChanged() {\\n    return floor(texelFetch(iChannel1, ivec2(0), 0).r) != floor(iResolution.x);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \\n    if (resolutionChanged()) {\\n        // pack 32x32x32 3d texture in 2d texture (with padding)\\n        float z = floor(fragCoord.x/34.) + 8.*floor(fragCoord.y/34.);\\n        vec2 uv = mod(fragCoord.xy, 34.) - 1.;\\n        vec3 coord = vec3(uv, z) / 32.;\\n\\n        float r = tilableVoronoi( coord, 16,  3. );\\n        float g = tilableVoronoi( coord,  4,  8. );\\n        float b = tilableVoronoi( coord,  4, 16. );\\n\\n        float c = max(0., 1.-(r + g * .5 + b * .25) / 1.75);\\n\\n        fragColor = vec4(c,c,c,c);\\n    } else {\\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\\n    }\\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Himalayas. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MdGfzh\\n//\\n// This is my first attempt to render volumetric clouds in a fragment shader.\\n//\\n//\\n// To create an interesting scene and to add some scale to the clouds, I render a \\n// terrain using a simple heightmap, based on the work by igo Qulez on value noise and its \\n// analytical derivatives.[3]\\n//\\n// In fact, the heightmap of this shader is almost exactly the same as the heightmap that \\n// is used in igo Qulez' shader Elevated:\\n//\\n// https://www.shadertoy.com/view/MdX3Rr\\n//\\n// To reduce noise I use temporal reprojection (both for clouds (Buffer D) and the terrain \\n// (Buffer C)) separatly. The temporal reprojection code is based on code from the shader\\n// \\"Rain Forest\\" (again by igo Qulez):\\n//\\n// https://www.shadertoy.com/view/4ttSWf\\n// \\nvec3 noised( in vec2 x ) {\\n    vec2 f = fract(x);\\n    vec2 u = f*f*(3.0-2.0*f);\\n    \\n    vec2 p = vec2(floor(x));\\n    float a = hash12( (p+vec2(0,0)) );\\n\\tfloat b = hash12( (p+vec2(1,0)) );\\n\\tfloat c = hash12( (p+vec2(0,1)) );\\n\\tfloat d = hash12( (p+vec2(1,1)) );\\n    \\n\\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\\n\\t\\t\\t\\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\\n}\\n\\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\\n\\nfloat terrainMap( in vec2 x, const int OCTAVES ) {\\n\\tvec2 p = x*(MOUNTAIN_HW_RATIO*SCENE_SCALE);\\n    float s = mix(1., smoothstep(.0,.4, abs(p.y)), .75);\\n    \\n    float a = 0.;\\n    float b = 1.;\\n\\tvec2  d = vec2(0.0);\\n    for( int i=0; i<OCTAVES; i++ ) {\\n        vec3 n = noised(p);\\n        d += n.yz;\\n        a += b*n.x/(1.0+dot(d,d));\\n\\t\\tb *= 0.5;\\n        p = m2*p;\\n    }\\n\\treturn s*a*(MOUNTAIN_HEIGHT*INV_SCENE_SCALE*.5);\\n}\\n\\nfloat terrainMapB( in vec2 x, const int OCTAVES ) {\\n\\tvec2 p = x*(MOUNTAIN_HW_RATIO*SCENE_SCALE);\\n    float s = mix(1., smoothstep(.0,.4, abs(p.y)), .75);\\n    \\n    float a = 0.;\\n    float b = 1.;\\n\\tvec2  d = vec2(0.0);\\n    for( int i=0; i<OCTAVES; i++ ) {\\n        vec3 n = noised(p);\\n        d += n.yz;\\n        a += b*n.x/(1.0+dot(d,d));\\n\\t\\tb *= 0.5;\\n        p = m2*p;\\n    }\\n\\treturn s*a*(MOUNTAIN_HEIGHT*INV_SCENE_SCALE*.5);\\n}\\nvec3 calcNormal(in vec3 pos, float t, const int OCTAVES) {\\n    vec2  eps = vec2( (0.0015)*t, 0.0 );\\n    return normalize( vec3( terrainMap(pos.xz-eps.xy, OCTAVES) - terrainMap(pos.xz+eps.xy, OCTAVES),\\n                            2.0*eps.x,\\n                            terrainMap(pos.xz-eps.yx, OCTAVES) - terrainMap(pos.xz+eps.yx, OCTAVES) ) );\\n}\\n\\nvec4 render( in vec3 ro, in vec3 rd ) {\\n\\tvec3 col, bgcol;\\n    \\n    float tmax = 10000.;\\n    // bouding top plane\\n    float topd = ((MOUNTAIN_HEIGHT*INV_SCENE_SCALE)-ro.y)/rd.y;\\n    if( rd.y > 0.0 && topd > 0.0 ) {\\n        tmax = min(tmax, topd);\\n    }\\n    \\n    // intersect with heightmap\\n    float t = 1.;\\n\\tfor( int i=0; i<128; i++ ) {\\n        vec3 pos = ro + t*rd;\\n\\t\\tfloat h = pos.y - terrainMap( pos.xz, 7 );\\n        if(abs(h)<(0.003*t) || t>tmax ) break; // use abs(h) to bounce back if under terrain\\n\\t    t += .9 * h;\\n\\t}\\n   \\t\\n    bgcol = col = getSkyColor(rd);\\n\\tif( t<tmax) {\\n\\t\\tvec3 pos = ro + t*rd;\\n        vec3 nor = calcNormal( pos, t, 15);\\n           \\n        // terrain color - just back and white\\n        float s = smoothstep(0.5,0.9,dot(nor, vec3(.3,1.,0.05)));\\n        col = mix( vec3(.01), vec3(0.5,0.52,0.6), smoothstep(.1,.7,s ));\\n\\t\\t\\n        // lighting\\t\\n        // shadow is calculated based on the slope of a low frequency version of the heightmap\\n        float shadow = .5 + clamp( -8.+ 16.*dot(SUN_DIR, calcNormal(pos, t, 5)), 0.0, .5 );\\n        shadow *= smoothstep(20.,80.,pos.y);\\n        \\n        float ao = terrainMap(pos.xz, 10)-terrainMap(pos.xz,7);\\n        ao = clamp(.25 + ao / (MOUNTAIN_HEIGHT*INV_SCENE_SCALE) * 200., 0., 1.);\\n\\n        float ambient  = max(0.5+0.5*nor.y,0.0);\\n\\t\\tfloat diffuse  = max(dot(SUN_DIR, nor), 0.0);\\n\\t\\tfloat backlight = max(0.5 + 0.5*dot( normalize( vec3(-SUN_DIR.x, 0., SUN_DIR.z)), nor), 0.0);\\n\\t \\t\\n        //\\n        // use a 3-light setup as described by igo Qulez\\n        // https://iquilezles.org/articles/outdoorslighting\\n        //\\n\\t\\tvec3 lin = (diffuse*shadow*3.) * SUN_COLOR;\\n\\t\\tlin += (ao*ambient)*vec3(0.40,0.60,1.00);\\n        lin += (backlight)*vec3(0.40,0.50,0.60);\\n\\t\\tcol *= lin;\\n        col *= (.6+.4*smoothstep(400.,100.,abs(pos.z))); // dark in the distance\\n    \\n        // height based fog, see https://iquilezles.org/articles/fog\\n        float fogAmount = HEIGHT_BASED_FOG_C * (1.-exp( -t*rd.y*HEIGHT_BASED_FOG_B))/rd.y;\\n        col = mix( col, bgcol, fogAmount);\\n    } else {\\n        t = 10000.;\\n    }\\n\\n\\treturn vec4( col, t );\\n}\\n\\n\\nbool resolutionChanged() {\\n    return floor(texelFetch(iChannel1, ivec2(0), 0).r) != floor(iResolution.x);\\n}\\n\\nbool mouseChanged() {\\n    return iMouse.z * texelFetch(iChannel1, ivec2(1,0), 1).w < 0.;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    if( letterBox(fragCoord, iResolution.xy, 2.25) ) {\\n        fragColor = vec4( 0., 0., 0., 1. );\\n        return;\\n    } else {\\n        vec3 ro, rd;\\n        vec3 o = hash33( vec3(fragCoord,iFrame) ) - 0.5; // dither\\n        getRay( iTime, (fragCoord+o.xy), iResolution.xy, iMouse/iResolution.xyxy, ro, rd);\\n\\n        vec4 res = render( ro + rd*o.z, rd );\\n\\n        vec2 spos = reprojectPos(ro+rd*res.w, iResolution.xy, iChannel1);\\n        spos -= o.xy/iResolution.xy; // undo dither\\n        \\n        vec2 rpos = spos * iResolution.xy;\\n        \\n        if( !letterBox(rpos.xy, iResolution.xy, 2.3) \\n            && !resolutionChanged() && !mouseChanged()) {\\n            vec4 ocol = texture( iChannel0, spos, 0.0 );\\n            res.rgb = mix(max(ocol.rgb,vec3(0)), res.rgb, .125);\\n        }\\n\\n        fragColor = res;\\n    }\\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Himalayas. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MdGfzh\\n//\\n// This is my first attempt to render volumetric clouds in a fragment shader.\\n//\\n// I started this shader by trying to implement the clouds of Horizon Zero Dawn, as\\n// described in \\"The real-time volumetric cloudscapes of Horizon Zero Dawn\\" by \\n// Andrew Schneider and Nathan Vos.[1] To model the shape of the clouds, two look-up\\n// textures are created with different frequencies of (Perlin -) Worley noise:\\n//\\n// Buffer A: The main look-up texture for the cloud shapes. \\n// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details \\n//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.\\n//           \\n// Because it is not possible (yet) to create buffers with fixed size, or 3D buffers, the\\n// look-up texture in Buffer A is 2D, and a slice of the volume that is described in the \\n// article. Therefore, and because I didn't have any slots left (in Buffer C) to use a \\n// cloud type/cloud coverage texture, the modelling of the cloud shapes in this shader is \\n// in the end mostly based on trial and error, and is probably far from the code used in \\n// Horizon Zero Dawn.\\n//\\n// Buffer D: Rendering of the clouds.\\n//\\n// I render the clouds using the improved integration method of volumetric media, as described \\n// in \\"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\\" by \\n// Sbastien Hillaire.[2]\\n//\\n// You can find the (excellent) example shaders of Sbastien Hillaire (SebH) here:\\n//\\n// https://www.shadertoy.com/view/XlBSRz\\n// https://www.shadertoy.com/view/MdlyDs\\n//\\n#define CLOUD_MARCH_STEPS 12\\n#define CLOUD_SELF_SHADOW_STEPS 6\\n\\n#define EARTH_RADIUS    (1500000.) // (6371000.)\\n#define CLOUDS_BOTTOM   (1350.)\\n#define CLOUDS_TOP      (2350.)\\n\\n#define CLOUDS_LAYER_BOTTOM   (-150.)\\n#define CLOUDS_LAYER_TOP      (-70.)\\n\\n#define CLOUDS_COVERAGE (.52)\\n#define CLOUDS_LAYER_COVERAGE (.41)\\n\\n#define CLOUDS_DETAIL_STRENGTH (.225)\\n#define CLOUDS_BASE_EDGE_SOFTNESS (.1)\\n#define CLOUDS_BOTTOM_SOFTNESS (.25)\\n#define CLOUDS_DENSITY (.03)\\n#define CLOUDS_SHADOW_MARGE_STEP_SIZE (10.)\\n#define CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE (4.)\\n#define CLOUDS_SHADOW_MARGE_STEP_MULTIPLY (1.3)\\n#define CLOUDS_FORWARD_SCATTERING_G (.8)\\n#define CLOUDS_BACKWARD_SCATTERING_G (-.2)\\n#define CLOUDS_SCATTERING_LERP (.5)\\n\\n#define CLOUDS_AMBIENT_COLOR_TOP (vec3(149., 167., 200.)*(1.5/255.))\\n#define CLOUDS_AMBIENT_COLOR_BOTTOM (vec3(39., 67., 87.)*(1.5/255.))\\n#define CLOUDS_MIN_TRANSMITTANCE .1\\n\\n#define CLOUDS_BASE_SCALE 1.51\\n#define CLOUDS_DETAIL_SCALE 20.\\n\\n//\\n// Cloud shape modelling and rendering \\n//\\nfloat HenyeyGreenstein( float sundotrd, float g) {\\n\\tfloat gg = g * g;\\n\\treturn (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);\\n}\\n\\nfloat interectCloudSphere( vec3 rd, float r ) {\\n    float b = EARTH_RADIUS * rd.y;\\n    float d = b * b + r * r + 2. * EARTH_RADIUS * r;\\n    return -b + sqrt( d );\\n}\\n\\nfloat linearstep( const float s, const float e, float v ) {\\n    return clamp( (v-s)*(1./(e-s)), 0., 1. );\\n}\\n\\nfloat linearstep0( const float e, float v ) {\\n    return min( v*(1./e), 1. );\\n}\\n\\nfloat remap(float v, float s, float e) {\\n\\treturn (v - s) / (e - s);\\n}\\n\\nfloat cloudMapBase(vec3 p, float norY) {\\n\\tvec3 uv = p * (0.00005 * CLOUDS_BASE_SCALE);\\n    vec3 cloud = texture(iChannel0, uv.xz).rgb;\\n   \\n    float n = norY*norY;\\n    n *= cloud.b ;\\n        n+= pow(1.-norY, 16.); \\n\\treturn remap( cloud.r - n, cloud.g, 1.);\\n}\\n\\nfloat cloudMapDetail(vec3 p) { \\n    // 3d lookup in 2d texture :(\\n    p = abs(p) * (0.0016 * CLOUDS_BASE_SCALE * CLOUDS_DETAIL_SCALE);\\n  \\n    float yi = mod(p.y,32.);\\n    ivec2 offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;\\n    float a = texture(iChannel3, (mod(p.xz,32.)+vec2(offset.xy)+1.)/iResolution.xy).r;\\n    \\n    yi = mod(p.y+1.,32.);\\n    offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;\\n    float b = texture(iChannel3, (mod(p.xz,32.)+vec2(offset.xy)+1.)/iResolution.xy).r;\\n    \\n    return mix(a,b,fract(p.y));\\n}\\n\\nfloat cloudGradient( float norY ) {\\n    return linearstep( 0., .05, norY ) - linearstep( .8, 1.2, norY);\\n}\\n\\nfloat cloudMap(vec3 pos, vec3 rd, float norY) {\\n    vec3 ps = pos;\\n    \\n    float m = cloudMapBase(ps, norY);\\n\\tm *= cloudGradient( norY );\\n\\n\\tfloat dstrength = smoothstep(1., 0.5, m);\\n    \\n    // erode with detail\\n    if(dstrength > 0.) {\\n\\t\\tm -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;\\n    }\\n\\n\\tm = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(CLOUDS_COVERAGE-1.) );\\n    m *= linearstep0(CLOUDS_BOTTOM_SOFTNESS, norY);\\n\\n    return clamp(m * CLOUDS_DENSITY * (1.+max((ps.x-7000.)*0.005,0.)), 0., 1.);\\n}\\n\\nfloat volumetricShadow(in vec3 from, in float sundotrd ) {\\n    float dd = CLOUDS_SHADOW_MARGE_STEP_SIZE;\\n    vec3 rd = SUN_DIR;\\n    float d = dd * .5;\\n    float shadow = 1.0;\\n\\n    for(int s=0; s<CLOUD_SELF_SHADOW_STEPS; s++) {\\n        vec3 pos = from + rd * d;\\n        float norY = (length(pos) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM));\\n\\n        if(norY > 1.) return shadow;\\n\\n        float muE = cloudMap( pos, rd, norY );\\n        shadow *= exp(-muE * dd);\\n\\n        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;\\n        d += dd;\\n    }\\n    return shadow;\\n}\\n\\nvec4 renderClouds( vec3 ro, vec3 rd, inout float dist ) {\\n    if( rd.y < 0. ) {\\n        return vec4(0,0,0,10);\\n    }\\n\\n    ro.xz *= SCENE_SCALE;\\n    ro.y = sqrt(EARTH_RADIUS*EARTH_RADIUS-dot(ro.xz,ro.xz));\\n\\n    float start = interectCloudSphere( rd, CLOUDS_BOTTOM );\\n    float end  = interectCloudSphere( rd, CLOUDS_TOP );\\n    \\n    if (start > dist) {\\n        return vec4(0,0,0,10);\\n    }\\n    \\n    end = min(end, dist);\\n    \\n    float sundotrd = dot( rd, -SUN_DIR);\\n\\n    // raymarch\\n    float d = start;\\n    float dD = (end-start) / float(CLOUD_MARCH_STEPS);\\n\\n    float h = hash13(rd + fract(iTime) );\\n    d -= dD * h;\\n\\n    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),\\n        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );\\n\\n    float transmittance = 1.0;\\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\\n\\n    dist = EARTH_RADIUS;\\n\\n    for(int s=0; s<CLOUD_MARCH_STEPS; s++) {\\n        vec3 p = ro + d * rd;\\n\\n        float norY = clamp( (length(p) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM)), 0., 1.);\\n\\n        float alpha = cloudMap( p, rd, norY );\\n\\n        if( alpha > 0. ) {\\n            dist = min( dist, d);\\n            vec3 ambientLight = mix( CLOUDS_AMBIENT_COLOR_BOTTOM, CLOUDS_AMBIENT_COLOR_TOP, norY );\\n\\n            vec3 S = (ambientLight + SUN_COLOR * (scattering * volumetricShadow(p, sundotrd))) * alpha;\\n            float dTrans = exp(-alpha * dD);\\n            vec3 Sint = (S - S * dTrans) * (1. / alpha);\\n            scatteredLight += transmittance * Sint; \\n            transmittance *= dTrans;\\n        }\\n\\n        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;\\n\\n        d += dD;\\n    }\\n\\n    return vec4(scatteredLight, transmittance);\\n}\\n\\n//\\n//\\n// !Because I wanted a second cloud layer (below the horizon), I copy-pasted \\n// almost all of the code above:\\n//\\n\\nfloat cloudMapLayer(vec3 pos, vec3 rd, float norY) {\\n    vec3 ps = pos;\\n\\n    float m = cloudMapBase(ps, norY);\\n\\t// m *= cloudGradient( norY );\\n\\tfloat dstrength = smoothstep(1., 0.5, m);\\n    \\n    // erode with detail\\n    if (dstrength > 0.) {\\n\\t\\tm -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;\\n    }\\n\\n\\tm = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(CLOUDS_LAYER_COVERAGE-1.) );\\n\\n    return clamp(m * CLOUDS_DENSITY, 0., 1.);\\n}\\n\\nfloat volumetricShadowLayer(in vec3 from, in float sundotrd ) {\\n    float dd = CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE;\\n    vec3 rd = SUN_DIR;\\n    float d = dd * .5;\\n    float shadow = 1.0;\\n\\n    for(int s=0; s<CLOUD_SELF_SHADOW_STEPS; s++) {\\n        vec3 pos = from + rd * d;\\n        float norY = clamp( (pos.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);\\n\\n        if(norY > 1.) return shadow;\\n\\n        float muE = cloudMapLayer( pos, rd, norY );\\n        shadow *= exp(-muE * dd);\\n\\n        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;\\n        d += dd;\\n    }\\n    return shadow;\\n}\\n\\nvec4 renderCloudLayer( vec3 ro, vec3 rd, inout float dist ) {\\n    if( rd.y > 0. ) {\\n        return vec4(0,0,0,10);\\n    }\\n\\n    ro.xz *= SCENE_SCALE;\\n    ro.y = 0.;\\n\\n    float start = CLOUDS_LAYER_TOP/rd.y;\\n    float end  = CLOUDS_LAYER_BOTTOM/rd.y;\\n    \\n    if (start > dist) {\\n        return vec4(0,0,0,10);\\n    }\\n    \\n    end = min(end, dist);\\n    \\n    float sundotrd = dot( rd, -SUN_DIR);\\n\\n    // raymarch\\n    float d = start;\\n    float dD = (end-start) / float(CLOUD_MARCH_STEPS);\\n\\n    float h = hash13(rd + fract(iTime) );\\n    d -= dD * h;\\n\\n    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),\\n        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );\\n\\n    float transmittance = 1.0;\\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\\n\\n    dist = EARTH_RADIUS;\\n\\n    for(int s=0; s<CLOUD_MARCH_STEPS; s++) {\\n        vec3 p = ro + d * rd;\\n\\n        float norY = clamp( (p.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);\\n\\n        float alpha = cloudMapLayer( p, rd, norY );\\n\\n        if( alpha > 0. ) {\\n            dist = min( dist, d);\\n            vec3 ambientLight = mix( CLOUDS_AMBIENT_COLOR_BOTTOM, CLOUDS_AMBIENT_COLOR_TOP, norY );\\n\\n            vec3 S = .7 * (ambientLight +  SUN_COLOR * (scattering * volumetricShadowLayer(p, sundotrd))) * alpha;\\n            float dTrans = exp(-alpha * dD);\\n            vec3 Sint = (S - S * dTrans) * (1. / alpha);\\n            scatteredLight += transmittance * Sint; \\n            transmittance *= dTrans;\\n        }\\n\\n        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;\\n\\n        d += dD;\\n    }\\n\\n    return vec4(scatteredLight, transmittance);\\n}\\n\\n//\\n// Main function\\n//\\nbool resolutionChanged() {\\n    return floor(texelFetch(iChannel1, ivec2(0), 0).r) != floor(iResolution.x);\\n}\\n\\nbool mouseChanged() {\\n    return iMouse.z * texelFetch(iChannel1, ivec2(1,0), 1).w < 0.;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {            \\n    if (fragCoord.y < 1.5) {\\n        fragColor = saveCamera(iTime, fragCoord, iMouse/iResolution.xyxy);\\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4(iMouse);\\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = mouseChanged() ? vec4(0) : vec4(iResolution.xy,0,0);\\n    } else {\\n        if( letterBox(fragCoord, iResolution.xy, 2.25) ) {\\n        \\tfragColor = vec4( 0., 0., 0., 1. );\\n       \\t\\treturn;\\n        } else {\\n            float dist = texelFetch(iChannel2, ivec2(fragCoord),0).w * SCENE_SCALE;\\n            vec4 col = vec4(0,0,0,1);\\n            \\n            vec3 ro, rd;\\n    \\t\\tgetRay( iTime, fragCoord, iResolution.xy, iMouse/iResolution.xyxy, ro, rd);\\n\\n            if( rd.y > 0. ) {\\n                // clouds\\n                col = renderClouds(ro, rd, dist);\\n                float fogAmount = 1.-(.1 + exp(-dist*0.0001));\\n                col.rgb = mix(col.rgb, getSkyColor(rd)*(1.-col.a), fogAmount);\\n            } else {\\n                // cloud layer below horizon\\n                col = renderCloudLayer(ro, rd, dist);\\n                // height based fog, see https://iquilezles.org/articles/fog\\n                float fogAmount = HEIGHT_BASED_FOG_C * \\n                    (1.-exp( -dist*rd.y*(INV_SCENE_SCALE*HEIGHT_BASED_FOG_B)))/rd.y;\\n                col.rgb = mix(col.rgb, getSkyColor(rd)*(1.-col.a), clamp(fogAmount,0.,1.));\\n            }\\n\\n            if( col.w > 1. ) {\\n                fragColor = vec4(0,0,0,1);\\n            } else {\\n                vec2 spos = reprojectPos(ro+rd*dist, iResolution.xy, iChannel1);\\n                vec2 rpos = spos * iResolution.xy;\\n\\n        \\t\\tif( !letterBox(rpos.xy, iResolution.xy, 2.3) \\n                    && !resolutionChanged() && !mouseChanged()) {\\n                    vec4 ocol = texture( iChannel1, spos, 0.0 ).xyzw;\\n                    col = mix(ocol, col, 0.05);\\n                }\\n                fragColor = col;\\n            }\\n        }\\n    }\\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XsyfD3","date":"1530720675","viewed":3389,"name":"Paratrooper (game)","description":"The numeric  key pad  controls  your gun and the firing of your bullets. Two keys start the gun moving:\\n     < and 4    counterclockwise\\n     > or 6      clockwise\\nUsing the ^ or 8 key stops  the movement of your gun and fires your bullets.","likes":45,"published":"Public API","usePreview":0,"tags":["2d","game","retro","pixel","paratrooper","arcade","dos"]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Paratrooper. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XsyfD3\\n//\\n// I made this shader because I wanted to try to create a simple \\n// but complete game on Shadertoy.\\n//\\n// Buffer A: Game logic. As usual this code started nice, but in the\\n//           end I added a lot of if-statements and it became a mess.\\n// Buffer B: Rendering of the screen (320x200).\\n// Buffer C: Encoding and decoding of bitmaps used.\\n//\\n// So here it is: Paratrooper (\\"The worst IBM program of 1983\\").\\n//\\n//\\n//             *Your Mission*\\n//\\n// Do not allow enemy  paratroopers to land\\n// on either side of your gun base. If four\\n// paratroopers  land on one  side of  your\\n// base,  they will overpower your defenses\\n// and blow  up your  gun.  After  you have\\n// survived the first round of helicopters,\\n// watch out for the jet bombers. Every jet\\n// pilot has a deadly aim!\\n// The numeric  key pad  controls  your gun\\n// and the firing of your bullets. Two keys\\n// start the gun moving:\\n//     < and 4    counterclockwise\\n//     > or 6     clockwise\\n// Using the ^ or 8 key stops  the movement\\n// of your gun and fires your bullets.\\n//\\n//                 *Scoring*\\n//     HELICOPTER or JET  .  .  10 points\\n//     ENEMY PARATROOPER  .  .   5 points\\n//     BOMB.  .  .  .  .  .  .  30 points\\n//\\n// Each bullet you fire costs you one point\\n//\\n//    PRESS space bar FOR KEYBOARD PLAY\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec2 scale = RES / (iResolution.xy - vec2(0,20));\\n    float s = max(scale.x, scale.y);\\n    vec2 uv = (fragCoord.xy * s - .5 * (iResolution.xy * s - RES));\\n    if( inBox(ivec2(uv), ivec2(0), ivec2(RES)) ) {    \\n\\t    if (iResolution.x < 320.) uv *= .5;\\n\\t    fragColor = vec4(texture(iChannel0, (uv + .5) / iResolution.xy).rgb, 1.0);\\n    } else {\\n        fragColor = vec4(0,0,0,1);\\n    }\\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Paratrooper. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XsyfD3\\n//\\n// I made this shader because I wanted to try  to create a simple \\n// but complete game in Shadertoy.\\n//\\n\\n#define FIXED_TIME_STEP\\n#define FORCE_NO_UNROLL +min(0,int(iFrame))\\n\\n#define RES vec2(320,200)\\n#define CANON_CENTER ivec2(160,157)\\n\\n#define COL_WHITE vec3(1)\\n#define COL_BLACK vec3(0)\\n#define COL_MAGENTA (vec3(253,93,252)/255.)\\n#define COL_CYAN (vec3(95,255,254)/255.)\\n\\n#define INF 1e10\\n\\n// game defines\\n\\n#define GAME_OVER 0.\\n#define GAME_HELICOPTER 1.\\n#define GAME_JET 2.\\n\\n#define EXPLOSION_DURATION 1.\\n#define GAME_OVER_DURATION 3.\\n\\n#define ROUND_HELICOPTER_TIME 20.\\n#define ROUND_JET_TIME 5.\\n#define ROUND_COOL_DOWN_TIME 1.\\n\\n#define CANON_ROT_SPEED 2.3\\n#define CANON_MAX_ANGLE 1.4\\n\\n#define MAX_BULLETS 8\\n#define BULLET_SPEED 125.\\n#define SHOT_COOLDOWN .21\\n\\n\\n#define MAX_AIRCRAFTS 6\\n#define MIN_AIRCRAFT_DT .75\\n#define MAX_AIRCRAFT_DT 5.5\\n#define AIRCRAFT_SPEED 70.\\n\\n#define MAX_PARATROOPERS 5\\n#define MIN_PARATROOP_DT 1.25\\n#define MAX_PARATROOP_DT 6.\\n\\n#define PARATROOPER_SPEED_0 92.\\n#define PARATROOPER_SPEED_1 47.5\\n#define MIN_PARATROOP_OPEN_DT .2\\n#define MAX_PARATROOP_OPEN_DT .8\\n\\n#define BOMB_DT 0.5\\n#define BOMBS_DT 2.\\n#define BOMB_SPEED 105.\\n\\n#define DEAD_PARATROOPER_DT 1.\\n\\n#define BULLET_DATA_OFFSET 10\\n#define AIRCRAFT_DATA_OFFSET 20\\n#define PARATROOPER_DATA_OFFSET 30\\n\\n// global game variables\\n\\nfloat gDT;\\nfloat gCanonMovement;\\nfloat gCanonAngle;\\nfloat gMode;\\n\\nfloat gScore;\\nfloat gHighScore;\\nfloat gEndRoundTime;\\nfloat gEndRoundTimeCoolDown;\\nfloat gGameOverTime;\\n\\nfloat gLastShot;\\nvec3 gBulletData[MAX_BULLETS];\\n    \\nfloat gLastAircraft;\\nvec2 gAircraftData[MAX_AIRCRAFTS];\\n\\nfloat gLastParatrooper;\\nvec4 gParatrooperData[MAX_PARATROOPERS];\\n\\nvec4 gDeadParatroopers;\\nvec4 gParatroopersLeft;\\nvec4 gParatroopersRight;\\n\\nvec4 gExplosion1;\\nvec4 gExplosion2;\\n\\nvoid saveGameState(ivec2 uv, float time, inout vec4 f) {\\n    if(uv.x == 0) f = vec4(time, gCanonMovement, gCanonAngle, gMode);\\n    if(uv.x == 1) f = vec4(gLastShot, gLastAircraft, gScore, gHighScore);\\n    if(uv.x == 2) f = vec4(gLastParatrooper,gEndRoundTime,gEndRoundTimeCoolDown,gGameOverTime);\\n    if(uv.x == 3) f = gDeadParatroopers;\\n    if(uv.x == 4) f = gParatroopersLeft;\\n    if(uv.x == 5) f = gParatroopersRight;\\n    if(uv.x == 6) f = gExplosion1;\\n    if(uv.x == 7) f = gExplosion2;\\n    \\n    for (int i=0; i<MAX_BULLETS; i++) {\\n        if(uv.x == i+BULLET_DATA_OFFSET) f = vec4(gBulletData[i],0);\\n    }\\n    for (int i=0; i<MAX_AIRCRAFTS/2; i++) {\\n        if(uv.x == i+AIRCRAFT_DATA_OFFSET) f = vec4(gAircraftData[i*2+0], gAircraftData[i*2+1]);\\n    }\\n    for (int i=0; i<MAX_PARATROOPERS; i++) {\\n        if(uv.x == i+PARATROOPER_DATA_OFFSET) f = gParatrooperData[i];\\n    }\\n}\\n\\nvoid loadGameStateMinimal(float time, sampler2D storage) {\\n    vec4 f;\\n\\n    f = texelFetch(storage, ivec2(0,0), 0);\\n#ifdef FIXED_TIME_STEP\\n    gDT = (1./60.);\\n#else\\n    gDT = time - f.x;\\n#endif\\n    gCanonMovement = f.y;\\n    gCanonAngle = f.z;\\n    gMode = f.w;\\n    \\n    f = texelFetch(storage, ivec2(1,0), 0);\\n    gLastShot = f.x;\\n    gLastAircraft = f.y;\\n    gScore = f.z;\\n    gHighScore = f.w;\\n    \\n    f = texelFetch(storage, ivec2(2,0), 0);\\n    gLastParatrooper = f.x;\\n    gEndRoundTime = f.y;\\n    gEndRoundTimeCoolDown = f.z;\\n    gGameOverTime = f.w;\\n    \\n    gDeadParatroopers = texelFetch(storage, ivec2(3,0), 0);\\n    gParatroopersLeft = texelFetch(storage, ivec2(4,0), 0);\\n    gParatroopersRight = texelFetch(storage, ivec2(5,0), 0);\\n    \\n    gExplosion1 = texelFetch(storage, ivec2(6,0), 0);\\n    gExplosion2 = texelFetch(storage, ivec2(7,0), 0);\\n}\\n\\nvoid loadGameStateFull(float time, sampler2D storage) {\\n    loadGameStateMinimal(time, storage);\\n        \\n    for (int i=0; i<MAX_BULLETS; i++) {\\n    \\tgBulletData[i] = texelFetch(storage, ivec2(i+BULLET_DATA_OFFSET,0), 0).xyz;\\n    }\\n    \\n    for (int i=0; i<MAX_AIRCRAFTS/2; i++) {\\n        vec4 f = texelFetch(storage, ivec2(i+AIRCRAFT_DATA_OFFSET,0), 0);\\n        gAircraftData[i*2+0] = f.xy;\\n        gAircraftData[i*2+1] = f.zw;\\n    } \\n    \\n    for (int i=0; i<MAX_PARATROOPERS; i++) {\\n    \\tgParatrooperData[i] = texelFetch(storage, ivec2(i+PARATROOPER_DATA_OFFSET,0), 0);\\n    }\\n}\\n\\n//\\n// Hash functions\\n//\\n// Hash without Sine by Dave_Hoskins\\n//\\n// https://www.shadertoy.com/view/4djSRW\\n//\\n\\n#define HASHSCALE1 .1031\\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\\n\\nfloat hash11(float p) {\\n\\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\nfloat hash12(vec2 p) {\\n\\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\nvec2 hash22(vec2 p) {\\n\\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\\n    p3 += dot(p3, p3.yzx+19.19);\\n    return fract((p3.xx+p3.yz)*p3.zy);\\n\\n}\\n\\n// game functions\\nivec2 getAircraftPos(vec2 data, float time) {\\n    float t = (time-abs(data.x));\\n    if (t > 0.) {\\n        int p = int(t * AIRCRAFT_SPEED) - 10;\\n        bool ltr = data.x > 0.;\\n    \\treturn ivec2(ltr ? p : int(RES.x) - p, ltr ? 18 : 6);\\n    } else {\\n        return ivec2(-1);\\n    }\\n}\\n\\n// draw functions\\n\\nbool inBox(const ivec2 uv, const ivec2 lt, const ivec2 rb) {\\n    return (uv.y >= lt.y && uv.y < rb.y && uv.x >= lt.x && uv.x < rb.x);\\n}\\n\\nvoid drawBox(const ivec2 uv, const ivec2 lt, const ivec2 rb, const vec3 color, inout vec3 f) {\\n\\tif (inBox(uv, lt, rb)) f = color;    \\n}\\n\\nvoid drawSprite(const ivec2 uv, const ivec2 lt, const ivec2 rb, const ivec2 offset, const in sampler2D d, const bool flip, inout vec3 f) {\\n    if (inBox(uv, lt, rb)) {\\n        ivec2 c = uv - lt;\\n    \\tc.x = flip ? (rb.x-lt.x)-c.x-1 : c.x;\\n    \\n        vec3 col = texelFetch(d, offset + c, 0).rgb;    \\n        f = col.r > 0. ? col : f;\\n    }\\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Paratrooper. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XsyfD3\\n//\\n// I made this shader because I wanted to try  to create a simple \\n// but complete game in Shadertoy.\\n//\\n// Buffer A: Game logic. As usual this code started nice, but in the\\n//           end I added a lot of if-statements and it became a mess.\\n//\\n\\nconst int KEY_SPACE = 32;\\nconst int KEY_LEFT  = 37;\\nconst int KEY_UP    = 38;\\nconst int KEY_RIGHT = 39;\\nconst int KEY_DOWN  = 40;\\nconst int KEY_A     = 65;\\nconst int KEY_D     = 68;\\nconst int KEY_S     = 83;\\nconst int KEY_W     = 87;\\n\\nbool KP(int key) {\\n\\treturn texelFetch( iChannel0, ivec2(key, 0), 0 ).x > 0.0;\\n}\\n\\nbool KT(int key) {\\n\\treturn texelFetch( iChannel0, ivec2(key, 2), 0 ).x > 0.0;\\n}\\n\\nfloat sBox( in vec2 ro, in vec2 rd, in vec2 rad ) {\\n    if(rd.x == 0.) rd.x = 0.001;\\n    vec2 m = 1./rd;\\n    vec2 n = m*ro;\\n    vec2 k = abs(m)*rad;\\n\\t\\n    vec2 t1 = -n - k;\\n    vec2 t2 = -n + k;\\n\\n\\tfloat tN = max( t1.x, t1.y );\\n\\tfloat tF = min( t2.x, t2.y );\\n    if( tN > tF || tF < 0.0) {\\n        return -1.0;\\n    } else {\\n\\t\\treturn tN;\\n    }\\n}\\n\\nbool shoot(float time) {\\n    if (gLastShot + SHOT_COOLDOWN < time) {\\n        gLastShot = time;\\n        return true;\\n    }\\n    return false;\\n}\\n\\nvoid paratrooperLand(float x, inout vec4 data) {\\n    if(data.x <= 0.) data.x = x;\\n    else if(data.y <= 0.) data.y = x;\\n    else if(data.z <= 0.) data.z = x;\\n    else if(data.w <= 0.) data.w = x;\\n}\\n\\nvoid killParatrooperAtPos(float x, inout vec4 data) {\\n    if(data.x == x) data.x = 0.;\\n    if(data.y == x) data.y = 0.;\\n    if(data.z == x) data.z = 0.;\\n    if(data.w == x) data.w = 0.;\\n}\\n\\nvoid deadParatrooper(float x, float time) {\\n    float visibleUntil = time + DEAD_PARATROOPER_DT;\\n    if (gDeadParatroopers.y < visibleUntil) {\\n        gDeadParatroopers.x = x;\\n        gDeadParatroopers.y = visibleUntil;\\n    } else {\\n        gDeadParatroopers.z = x;\\n        gDeadParatroopers.w = visibleUntil;\\n    }\\n    if (x < 160.) {\\n        killParatrooperAtPos(x, gParatroopersLeft);\\n    } else {\\n        killParatrooperAtPos(x, gParatroopersRight);\\n    }\\n}\\n\\nvoid initExplosion(vec2 pos, float time, float type) {\\n    if (gExplosion1.z < time - EXPLOSION_DURATION) {\\n        gExplosion1 = vec4(pos, time, type);\\n    } else {\\n        gExplosion2 = vec4(pos, time, type);\\n    }\\n}\\n\\nvoid initNewBullet(int index) {\\n    float a = gCanonAngle;\\n    gBulletData[index].z = a;\\n    gBulletData[index].xy = vec2(CANON_CENTER) + vec2(sin(a),-cos(a)) * 20.;\\n}\\n\\nvoid initAircraft(int index, float time, bool direct) {\\n    float h = direct ? 0. : hash11(float(index)+time);\\n    gLastAircraft += mix(MIN_AIRCRAFT_DT, MAX_AIRCRAFT_DT, h*h*h*h);\\n    if (gLastAircraft < gEndRoundTime) {\\n        float d = hash11(float(index)+time+.5)-.4 > 0. ? 1. : -1.;\\n        float ph = hash11(float(index)+time+.75);\\n        float p = gMode > GAME_HELICOPTER + .5 ?  \\n           (ph > .25 ? gLastAircraft + BOMB_DT : INF) : MAX_PARATROOP_DT * ph + gLastAircraft;\\n        gAircraftData[index] = vec2(gLastAircraft * d, p);\\n    } else {\\n        gAircraftData[index] = vec2(-20);\\n    }\\n}\\n\\nvoid initAircrafts(float time) {\\n    gLastAircraft = time;\\n    for (int i=0; i<MAX_AIRCRAFTS; i++) {\\n        initAircraft(i, time, i == 0);\\n    }\\n}\\n\\nbool fourParatroopersLanded(vec4 d) {\\n    return d.x > 0. && d.y > 0. && d.z > 0. && d.w > 0.;\\n}\\n\\nvoid initNewRound(float mode, float time) {\\n    gMode = mode;\\n    gEndRoundTime = time + \\n        ((gMode < GAME_HELICOPTER + .5) ? ROUND_HELICOPTER_TIME : ROUND_JET_TIME);\\n    \\n    initAircrafts(time);\\n}\\n\\nvoid initNewGame(float time) {\\n    gParatroopersLeft = vec4(0);\\n    gParatroopersRight = vec4(0);\\n    gScore = 0.;\\n    gLastShot = time;\\n    gGameOverTime = 0.;\\n    \\n    for (int i=0; i<MAX_BULLETS; i++) {\\n    \\tgBulletData[i].z = -20.;\\n    }\\n    for (int i=0; i<MAX_PARATROOPERS; i++) {\\n    \\tgParatrooperData[i].x = -20.;\\n    }\\n    \\n    initNewRound(GAME_HELICOPTER, time);\\n}\\n\\nvoid recycleBullet(inout vec3 bullet, float score) {\\n    bullet.z = -20.;\\n    gScore += score;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    ivec2 uv = ivec2(fragCoord);\\n    \\n    // gameloop\\n    if( uv.y == 0 && uv.x < 100) {\\n        loadGameStateFull(iTime, iChannel1);\\n\\t\\tbool gameOver = false;\\n     \\t\\n        if (gMode < GAME_OVER + .5) {      \\n            if( KP(KEY_SPACE) ) {\\n                initNewGame(iTime);       \\n            }\\n        } else {\\n            // user input\\n            bool wantShot = false;\\n            if (gGameOverTime < .5) {\\n                if( KP(KEY_LEFT) || KP(KEY_A) ) {\\n                    gCanonMovement = -1.;\\n                }\\n                if( KP(KEY_RIGHT) || KP(KEY_D) ) {\\n                    gCanonMovement = 1.;\\n                }\\n                if( KP(KEY_UP) || KP(KEY_W) || KP(KEY_SPACE) ) {\\n                    gCanonMovement = 0.;\\n                    wantShot = shoot(iTime);\\n                    if (wantShot) {\\n                        gScore = max(0., gScore - 1.);\\n                    }\\n                }\\n                gCanonAngle += gCanonMovement * gDT * CANON_ROT_SPEED;\\n                gCanonAngle = sign(gCanonAngle) * min(abs(gCanonAngle), CANON_MAX_ANGLE);\\n            }\\n            \\n            // save old y-coordinate for collision detection with bullets\\n            for (int i=0; i<MAX_PARATROOPERS; i++) {\\n            \\tgParatrooperData[i].w = gParatrooperData[i].y;\\n            }\\n            \\n            if (gMode < GAME_HELICOPTER + .5) {\\n                // helicopter mode\\n                \\n                // aircrafts\\n                float wantParatrooper = -20.;\\n                for (int i=0; i<MAX_AIRCRAFTS FORCE_NO_UNROLL; i++) {\\n                    ivec2 p = getAircraftPos(gAircraftData[i], iTime);\\n                    if (p.x < -20 || p.x > int(RES.x) + 20) {\\n                        initAircraft(i, iTime, false);\\n                    }\\n                    if (gAircraftData[i].y < iTime && iTime > gLastParatrooper + MIN_PARATROOP_DT) {\\n                        // drop paratrooper\\n                        wantParatrooper = floor(float(p.x)/6.)*6.;\\n                        gAircraftData[i].y = iTime + MAX_PARATROOP_DT * hash11(float(i)+iTime+.75);\\n                    }\\n                }\\n\\n                // paratroopers\\n                float paratrooperFrameDist_0 = (gDT * PARATROOPER_SPEED_0);\\n                float paratrooperFrameDist_1 = (gDT * PARATROOPER_SPEED_1);\\n\\n                for (int i=0; i<MAX_PARATROOPERS FORCE_NO_UNROLL; i++) {\\n                    vec4 p = gParatrooperData[i];\\n                    if (p.x > 0.) {\\n                        gParatrooperData[i].y += p.z > 0. && p.z < iTime \\n                            ? paratrooperFrameDist_1 : paratrooperFrameDist_0;\\n                        if (p.y > 190.) {\\n                            float x = p.x;\\n                            if (p.z < 0.) {\\n                                deadParatrooper(x, iTime);\\n                            } else {\\n                                if (x<160.) {\\n                                    paratrooperLand(x, gParatroopersLeft );\\n                                } else {\\n                                    paratrooperLand(x, gParatroopersRight );\\n                                }\\n                            }\\n                            gParatrooperData[i].x = -20.;\\n                        }\\n                    } else if(wantParatrooper > 0.) {\\n                        float x = abs(wantParatrooper-RES.x*.5);\\n                        if (x > 30. && x < RES.x*.5 - 5.) {\\n                            gParatrooperData[i].xyw = vec3(wantParatrooper, 30.,30.);\\n                            gParatrooperData[i].z = iTime +mix(MIN_PARATROOP_OPEN_DT, MAX_PARATROOP_OPEN_DT, hash11(float(i)+iTime+.25));;\\n                        }\\n                        wantParatrooper = -20.;\\n                        gLastParatrooper = iTime;\\n                    }\\n                }\\n            } else {\\n                // jet mode\\n                \\n                // aircrafts\\n                float wantBomb = -20.;\\n                for (int i=0; i<MAX_AIRCRAFTS FORCE_NO_UNROLL; i++) {\\n                    ivec2 p = getAircraftPos(gAircraftData[i], iTime);\\n                    if (gAircraftData[i].y < iTime) {\\n                        // drop bomb\\n                        if(iTime > gLastParatrooper + BOMBS_DT) {\\n                        \\twantBomb = float(p.x);\\n                        }\\n                        gAircraftData[i].y = INF;\\n                    }\\n                }\\n                \\n                // use paratrooperdata for bombs\\n                for (int i=0; i<MAX_PARATROOPERS FORCE_NO_UNROLL; i++) {\\n                    vec4 p = gParatrooperData[i];\\n                    if (p.x > 0.) {\\n                        gParatrooperData[i].xy -= normalize(p.xy - vec2(160,175)) * (gDT * BOMB_SPEED);\\n                        if (p.y > 170.) {\\n                            gParatrooperData[i].x = -20.;\\n                            gameOver = true;\\n                        }\\n                    } else if(wantBomb > 0.) {\\n                        gParatrooperData[i].xyw = vec3(wantBomb, 20., 20.);\\n                        wantBomb = -20.;\\n                        gLastParatrooper = iTime;\\n                    }\\n                }\\n            }\\n\\n            // bullets\\n            float bulletFrameDist = (gDT * BULLET_SPEED);\\n\\n            for (int i=0; i<MAX_BULLETS FORCE_NO_UNROLL; i++) {\\n                if (gBulletData[i].z > -10.) {\\n                    float a = gBulletData[i].z;\\n                    vec2 ro = gBulletData[i].xy;\\n\\n                    vec2 newPos = ro + vec2(sin(a),-cos(a)) * bulletFrameDist;\\n                    if (newPos.x < 0. || newPos.x > RES.x || newPos.y < 0.) {\\n                        gBulletData[i].z = -20.;\\n                    }\\n                    vec2 rd = normalize(newPos - ro);\\n\\n          \\t\\t\\tif (gGameOverTime < .5) {\\n                        if (gBulletData[i].z > -10.) {\\n                            for (int j=0; j<MAX_AIRCRAFTS FORCE_NO_UNROLL; j++) {\\n                                ivec2 p = getAircraftPos(gAircraftData[j], iTime);\\n                                float d = sBox(ro - vec2(p), rd, vec2(12,5));\\n                                if (d > 0. && d < bulletFrameDist) {\\n                                    initAircraft(j, iTime, false);\\n                                    initExplosion(vec2(p), iTime, 4.);\\n                                    recycleBullet(gBulletData[i], 10.);\\n                                    break;\\n                                }\\n                            }\\n                        }\\n\\n                        if (gBulletData[i].z > -10.) {            \\n                            if (gMode < GAME_HELICOPTER + .5) {\\n                                for (int j=0; j<MAX_PARATROOPERS FORCE_NO_UNROLL; j++) {\\n                                    vec2 p = gParatrooperData[j].xy;\\n                                    float dy = (gParatrooperData[j].y - gParatrooperData[j].w)*.5;\\n                                    float d = sBox(ro - p + vec2(0,4.-dy), rd, vec2(2,4.+dy));\\n                                    if (d > 0. && d < bulletFrameDist) {\\n                                        gParatrooperData[j].x = -20.;\\n                                        initExplosion(p, iTime, 1.);\\n                                        recycleBullet(gBulletData[i], 5.);\\n                                        break;\\n                                    } else if(gParatrooperData[j].z > 0. && iTime > gParatrooperData[j].z) {\\n                                        float d = sBox(ro - p + vec2(0,15.-dy), rd, vec2(6,7.+dy));\\n                                        if (d > 0. && d < bulletFrameDist) {\\n                                            gParatrooperData[j].z = -20.;\\n                                            initExplosion(p, iTime, 1.);\\n                                            recycleBullet(gBulletData[i], 5.);\\n                                            break;\\n                                        }\\n                                    }\\n                                }\\n                            } else {\\n                                // bombs\\n                                for (int j=0; j<MAX_PARATROOPERS FORCE_NO_UNROLL; j++) {\\n                                    vec2 p = gParatrooperData[j].xy;\\n                                    float dy = (gParatrooperData[j].y - gParatrooperData[j].w)*.5;\\n                                    float d = sBox(ro - p + vec2(0,-dy), rd, vec2(4,2.+dy));\\n                                    if (d > 0. && d < bulletFrameDist) {\\n                                        gParatrooperData[j].x = -20.;\\n                                        initExplosion(p, iTime, 2.);\\n                                        recycleBullet(gBulletData[i], 30.);\\n                                        break;\\n                                    }\\n                                }\\n                            }\\n                        }       \\n                    }\\n\\n                    gBulletData[i].xy = newPos;\\n                } else if(wantShot) {\\n                    initNewBullet(i);\\n                    wantShot = false;\\n                }\\n               \\n                for (int i=0; i<MAX_PARATROOPERS FORCE_NO_UNROLL; i++) {\\n                    if (gParatrooperData[i].x > 0.) {\\n                        gEndRoundTimeCoolDown = iTime + ROUND_COOL_DOWN_TIME; \\n                    }\\n                }\\n                float endTime = max(gEndRoundTimeCoolDown, gEndRoundTime + (RES.x/AIRCRAFT_SPEED) + ROUND_COOL_DOWN_TIME);\\n\\n                if (iTime > endTime) {\\n                    if (gMode < GAME_HELICOPTER + .5) {\\n\\t\\t\\t\\t\\t\\tinitNewRound(GAME_JET, iTime);\\n               \\t\\t} else {\\n                    \\tinitNewRound(GAME_HELICOPTER, iTime);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (gameOver || \\n            fourParatroopersLanded(gParatroopersLeft) || \\n            fourParatroopersLanded(gParatroopersRight)) {\\n            \\n            if (gGameOverTime < .5) {\\n                gGameOverTime = iTime + GAME_OVER_DURATION;\\n                gHighScore = max(gHighScore, gScore);\\n                initExplosion(vec2(CANON_CENTER), iTime, 3.);\\n            }\\n        }\\n\\n        if (gGameOverTime > .5 && iTime > gGameOverTime) {\\n            initNewGame(iTime);\\n            gMode = GAME_OVER;\\n        }\\n        \\n        // save state\\n        saveGameState(uv, iTime, fragColor);\\n    }\\n    \\n    if (iFrame == 0) {\\n        fragColor = vec4(0);\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Paratrooper. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XsyfD3\\n//\\n// I made this shader because I wanted to try  to create a simple \\n// but complete game in Shadertoy.\\n//\\n// Buffer B: Rendering of the screen (320x200).\\n//\\n\\nmat2 rotMatrix(float a) {\\n    float c = cos(a);\\n    float s = sin(a);\\n    return mat2(c, -s, s, c);\\n}\\n\\nvoid drawHLine(ivec2 uv, const int y, const int height, vec3 color, inout vec3 f) {\\n\\tif (uv.y >= y && uv.y < y + height) f = color;\\n}\\n\\nvoid drawTitle(ivec2 uv, const in sampler2D d, inout vec3 f) {\\n    if (inBox(uv, ivec2(51,40), ivec2(51+218,64))) {\\n\\t    int i = (uv.x-51)/20;\\n        if (i * 16 < iFrame) {\\n            int o = int[](0,1,2,1,3,2,4,4,0,5,2)[i] * 20;                    \\n            drawSprite(uv, ivec2(51+i*20,40), ivec2(51+i*20+20,64), ivec2(o,0), iChannel1, false, f);\\n        }\\n    }\\n}\\n\\nvec3 spriteCanon(ivec2 uv) {\\n    vec3 col = COL_BLACK;\\n    \\n    ivec2 uvRot = ivec2(rotMatrix(gCanonAngle) * vec2(uv));\\n    \\n    drawBox(uvRot, ivec2(-1,-12), ivec2(1,0), COL_CYAN, col);\\n    drawBox(uvRot, ivec2(-2,-11), ivec2(2,0), COL_CYAN, col);\\n    \\n    drawBox(uv, ivec2(-2,-4), ivec2(2,-3), COL_MAGENTA, col);\\n    drawBox(uv, ivec2(-4,-3), ivec2(4,-1), COL_MAGENTA, col);\\n    drawBox(uv, ivec2(-5,-1), ivec2(5,9), COL_MAGENTA, col);\\n    drawBox(uv, ivec2(-1,-1), ivec2(1,1), COL_CYAN, col);\\n    return col;\\n}\\n\\nvoid drawCanon(ivec2 uv, inout vec3 f) {\\n    vec3 col = spriteCanon(uv - CANON_CENTER);\\n    if (col.x > 0.) f = col;\\n}\\n\\nvoid drawHelicopter(ivec2 uv, ivec2 heliPos, int si, const in sampler2D d, inout vec3 f) {\\n    if (heliPos.y > 0) {\\n        drawSprite(uv, heliPos - ivec2(12,5), heliPos + ivec2(12,5), ivec2(24 * si, 24), d, heliPos.y < 8, f);\\n    }\\n}\\n\\nvoid drawJet(ivec2 uv, ivec2 jetPos, int si, const in sampler2D d, inout vec3 f) {\\n    if (jetPos.y > 0) {\\n        drawSprite(uv, jetPos - ivec2(12,5), jetPos + ivec2(12,5), ivec2(24 * si, 63), d, jetPos.y < 8, f);\\n    }\\n}\\n\\nvoid drawBomb(ivec2 uv, vec3 paratrooperData, float time, const in sampler2D d, inout vec3 f) {\\n    if (paratrooperData.x > 0. ) {\\n        ivec2 pos = ivec2(paratrooperData.xy);\\n    \\tdrawBox(uv - pos, ivec2(-1,-2), ivec2(1,2), COL_WHITE, f);\\n    \\tdrawBox(uv - pos, ivec2(-2,-1), ivec2(2,1), COL_WHITE, f);\\n    }\\n}\\n\\nvoid drawParatrooper(ivec2 uv, vec3 paratrooperData, float time, const in sampler2D d, inout vec3 f) {\\n    if (paratrooperData.x > 0. ) {\\n        ivec2 pos = ivec2(paratrooperData.xy);\\n        drawSprite(uv, pos - ivec2(2,8), pos + ivec2(2,0), ivec2(12,39), d, false, f);\\n        if (paratrooperData.z > 0. && paratrooperData.z < time) {\\n        \\tdrawSprite(uv, pos - ivec2(6,22), pos + ivec2(6,-8), ivec2(0,34), d, false, f);            \\n        }\\n    }\\n}\\n\\nvoid drawExplosion(ivec2 uv, vec4 d, float time, const sampler2D tex, inout vec3 f) {\\n    if (time < d.z + EXPLOSION_DURATION && uv.y < 190) {\\n    \\tfloat t = (d.z - time) * (1. / EXPLOSION_DURATION);\\n        vec2 p = vec2(uv)-d.xy;\\n        float h = hash12(p*.3);\\n        if (h*h*h > t) {\\n            vec2 r = normalize(2. * hash22(p) - 1.) * hash12(p);\\n            vec2 delta = r * vec2(-t, 1.-t) + vec2(0., t*6.);\\n\\n            float speed = .5 * (d.x-160.);\\n            if (d.w > 3.5) {\\n                speed = d.y > 8. ? AIRCRAFT_SPEED : -AIRCRAFT_SPEED;\\n                speed *= (1. / EXPLOSION_DURATION);\\n            } else if (d.w > 2.5) {\\n                speed = 0.;\\n                delta *= 10.;\\n                p.y -= t * 500.;\\n            }\\n            p.x += speed * t;\\n            p -= 20.*delta*t;\\n            \\n            uv = ivec2(d.xy + p);\\n\\n            if (d.w < 1.5) {\\n                drawSprite(uv, ivec2(d.xy) - ivec2(6,22), ivec2(d.xy) + ivec2(6,-8), ivec2(0,34), tex, false, f); \\n            } else if (d.w < 2.5) {\\n                drawBomb(uv, vec3(d.xyz), time, tex, f);\\n            } else if (d.w < 3.5) {\\n            \\tdrawCanon(uv, f);\\n            } else if (d.w < 4.5) { \\n                if (gMode > GAME_HELICOPTER + .5) {\\n                    drawJet(uv, ivec2(d.xy), 0, tex, f);\\n                } else {\\n                    drawHelicopter(uv, ivec2(d.xy), 0, tex, f);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nvoid drawScore( ivec2 uv, ivec2 rt, float score, inout vec3 col ) {\\n    for (int i=0; i<6; i++) {\\n        if (score > 0. || i == 0) {\\n            float s = mod(score, 10.);\\n            drawSprite(uv, rt, rt+ivec2(8,7), ivec2(72,73) + ivec2(s*8.,0), iChannel1, false, col);\\n            rt.x -= 8;\\n            score = floor(score * .1);\\n        }\\n    }\\n}\\n\\nvoid drawDeadParatrooper( ivec2 uv, vec2 d, float time, inout vec3 col ) {\\n    if (d.y > time) {\\n        drawSprite(uv, ivec2(d.x-6.,170), ivec2(d.x+6.,185), ivec2(0,48), iChannel1, false, col);\\n    }\\n}\\n\\nvoid drawLandedParatrooper( ivec2 uv, float x, float y, inout vec3 col ) {\\n    if (x > 0.) {\\n        drawSprite(uv, ivec2(x-2.,182.-y), ivec2(x+2.,190.-y), ivec2(12,39), iChannel1, false, col);\\n    }\\n}\\n\\nvoid drawLandedParatroopers( ivec2 uv, vec4 d, inout vec3 col ) {\\n\\tdrawLandedParatrooper(uv, d.x, 0., col);\\n\\tdrawLandedParatrooper(uv, d.y, d.y==d.x?8.:0., col);\\n\\tdrawLandedParatrooper(uv, d.z, (d.z==d.x?8.:0.) + (d.z==d.y?8.:0.), col);\\n\\tdrawLandedParatrooper(uv, d.w, (d.w==d.x?8.:0.) + (d.w==d.y?8.:0.) + (d.w==d.z?8.:0.), col);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    ivec2 uv = ivec2(fragCoord);\\n    \\n    if (iResolution.x < 320.) uv *= 2;\\n    \\n    if (fragCoord.x < RES.x && fragCoord.y < RES.y ) {\\n\\t\\tuv.y = int(RES.y) - uv.y;\\n        \\n        loadGameStateMinimal(iTime, iChannel0);\\n\\n        vec3 col = COL_BLACK;\\n\\n        // canon\\n        if (gGameOverTime < .5) {\\n\\t        drawCanon(uv, col);\\n        }\\n        \\n        if (gMode > GAME_OVER + .5) {\\n            // bullets\\n            for (int i=0; i<MAX_BULLETS FORCE_NO_UNROLL; i++) {\\n                vec3 b = texelFetch(iChannel0, ivec2(i+BULLET_DATA_OFFSET,0), 0).xyz;\\n                if (b.z > -10.) {\\n                    if(uv.x == int(b.x) && uv.y == int(b.y)) {\\n                        col = COL_WHITE;\\n                    }\\n                }\\n            }\\n\\n            // aircrafts\\n            for (int i=0; i<MAX_AIRCRAFTS/2 FORCE_NO_UNROLL; i++) {\\n                vec4 b = texelFetch(iChannel0, ivec2(i+AIRCRAFT_DATA_OFFSET,0), 0);\\n                ivec2 p1 = getAircraftPos(b.xy, iTime);\\n                ivec2 p2 = getAircraftPos(b.zw, iTime);\\n                if (gMode > GAME_HELICOPTER + .5) {\\n\\t                drawJet(uv, p1, (i + int(iTime * 8.)) & 1, iChannel1, col);\\n    \\t            drawJet(uv, p2, (i + int(iTime * 8.)) & 1, iChannel1, col);\\n                } else {\\n\\t                drawHelicopter(uv, p1, (i + int(iTime * 16.)) & 3, iChannel1, col);\\n    \\t            drawHelicopter(uv, p2, (i + int(iTime * 16.)) & 3, iChannel1, col);\\n                }\\n            }\\n\\n            // paratroopers\\n            for (int i=0; i<MAX_PARATROOPERS FORCE_NO_UNROLL; i++) {\\n                vec3 b = texelFetch(iChannel0, ivec2(i+PARATROOPER_DATA_OFFSET,0), 0).xyz;\\n                if (gMode < GAME_HELICOPTER + .5) {\\n                \\tdrawParatrooper(uv, b, iTime, iChannel1, col);\\n                } else {\\n\\t                drawBomb(uv, b, iTime, iChannel1, col);\\n                }\\n            }\\n            \\n            // landed paratroopers\\n            drawLandedParatroopers(uv, gParatroopersLeft, col);\\n            drawLandedParatroopers(uv, gParatroopersRight, col);\\n            \\n            // deadParatroopers\\n            drawDeadParatrooper(uv, gDeadParatroopers.xy, iTime, col);\\n            drawDeadParatrooper(uv, gDeadParatroopers.zw, iTime, col);\\n        } else {\\n            drawTitle(uv, iChannel1, col);\\n            if (iResolution.x > 320.) {\\n            \\tdrawSprite(uv, ivec2(28,80), ivec2(291,87), ivec2(0,80), iChannel1, false, col);\\n            }\\n        }\\n        \\n        drawExplosion(uv, gExplosion1, iTime, iChannel1, col);\\n        drawExplosion(uv, gExplosion2, iTime, iChannel1, col);\\n        \\n        drawHLine(uv, 190, 1, COL_CYAN, col);\\n        drawBox(uv, ivec2(145,166), ivec2(176,190), COL_WHITE, col);\\n\\n        // score\\n        if (uv.y > 190) {\\n            drawSprite(uv, ivec2(0,192), ivec2(46,199), ivec2(24,73), iChannel1, false, col); \\n            drawScore(uv, ivec2(100,192), gScore, col);\\n            drawSprite(uv, ivec2(200,192), ivec2(269,199), ivec2(0,73), iChannel1, false, col); \\n            drawScore(uv, ivec2(308,192), gHighScore, col);\\n        }\\n            \\n        fragColor = vec4(col, 1.0);\\n    } else {\\n        fragColor = vec4(0,0,0,1);\\n    }\\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Paratrooper. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XsyfD3\\n//\\n// I made this shader because I wanted to try  to create a simple \\n// but complete game in Shadertoy.\\n//\\n// Buffer C: Encoding and decoding of bitmaps used.\\n//\\n//\\n// Knarkowicz created a lot of nice shaders that uses encoded bitmaps. \\n// See for example: \\n//\\n// https://www.shadertoy.com/view/Xs2fWD [SH17B] Pixel Shader Dungeon\\t\\n// https://www.shadertoy.com/view/XtlSD7 [SIG15] Mario World 1-1\\n// https://www.shadertoy.com/view/ll2BWz Sprite Rendering \\n//\\n\\n//unpack sprites\\nvec3 unpackCol(uint x, uint d) {\\n\\tuint v = (d >> ((x & 0xfU) << 1)) & 0x3U;\\n    \\n    return v == 0x0U ? vec3(0) : \\n    \\t   v == 0x2U ? COL_CYAN : \\n    \\t   v == 0x3U ? COL_MAGENTA : COL_WHITE;\\n}\\n\\nvec3 unpackBW(uint x, uint d) {\\n    return vec3((d >> (x & 0x1fU)) & 0x1U);\\n}\\n\\nbool resolutionChanged() {\\n    return floor(texelFetch(iChannel0, ivec2(iResolution.xy-1.), 0).r) != floor(iResolution.x);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n\\tvec3 col = vec3(iResolution.xy,0);\\n    \\n    if (resolutionChanged()) {\\n        ivec2 c = ivec2(fragCoord);   \\t    \\n        uint d = 0x0U;\\n        const int ycol = 73;\\n\\n        if(c.y < ycol) {\\n            d = (c.y==0) ? c.x < 16 ? 0x1555555U : c.x < 32 ? 0x5540000U : c.x < 48 ? 0x55550000U : c.x < 64 ? 0x55000155U : c.x < 80 ? 0x155555U : c.x < 96 ? 0x55400U : c.x < 112 ? 0x55555500U : c.x < 128 ? 0x15U : d : d;\\n\\t\\t\\td = (c.y==1) ? c.x < 16 ? 0x6aaaaa5U : c.x < 32 ? 0x1a990000U : c.x < 48 ? 0xaaa50000U : c.x < 64 ? 0xa50006aaU : c.x < 80 ? 0x6aaaaaU : c.x < 96 ? 0x1a9900U : c.x < 112 ? 0xaaaaa500U : c.x < 128 ? 0x6aU : d : d;\\n            d = (c.y==2) ? c.x < 16 ? 0x1aaaaa99U : c.x < 32 ? 0x6a6a4000U : c.x < 48 ? 0xaa990000U : c.x < 64 ? 0x99001aaaU : c.x < 80 ? 0x1aaaaaaU : c.x < 96 ? 0x6a6a40U : c.x < 112 ? 0xaaaa9900U : c.x < 128 ? 0x1aaU : d : d;\\n            d = (c.y==3) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffaa9000U : c.x < 48 ? 0xffe90003U : c.x < 64 ? 0xe400ffffU : c.x < 80 ? 0xfffffffU : c.x < 96 ? 0x3ffaa90U : c.x < 112 ? 0xffffe900U : c.x < 128 ? 0xfffU : d : d;\\n            d = (c.y==4) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffeaa403U : c.x < 48 ? 0xffe9000fU : c.x < 64 ? 0xd003ffffU : c.x < 80 ? 0xfffffffU : c.x < 96 ? 0xfffeaa4U : c.x < 112 ? 0xffffe900U : c.x < 128 ? 0xfffU : d : d;\\n            d = (c.y==5) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xfffaa90fU : c.x < 48 ? 0xffe9003fU : c.x < 64 ? 0xc00fffffU : c.x < 80 ? 0xfffffffU : c.x < 96 ? 0x3ffffaa9U : c.x < 112 ? 0xffffe900U : c.x < 128 ? 0xfffU : d : d;\\n            d = (c.y==6) ? c.x < 16 ? 0xe9000fe9U : c.x < 32 ? 0x3fea50fU : c.x < 48 ? 0xfe900ffU : c.x < 64 ? 0xfe900U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xff03fea5U : c.x < 112 ? 0xfe900U : c.x < 128 ? 0x0U : d : d;\\n            d = (c.y==7) ? c.x < 16 ? 0xe9000fe9U : c.x < 32 ? 0xff990fU : c.x < 48 ? 0xfe903fdU : c.x < 64 ? 0xfe900U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xfd00ff99U : c.x < 112 ? 0xfe903U : c.x < 128 ? 0x0U : d : d;\\n            d = (c.y==8) ? c.x < 16 ? 0xe9000fe9U : c.x < 32 ? 0x3fe90fU : c.x < 48 ? 0xfe90ff9U : c.x < 64 ? 0xfe900U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xf9003fe9U : c.x < 112 ? 0xfe90fU : c.x < 128 ? 0x0U : d : d;\\n            d = (c.y==9) ? c.x < 16 ? 0xe9555fe9U : c.x < 32 ? 0x555fe90fU : c.x < 48 ? 0x5fe90fe9U : c.x < 64 ? 0xfe955U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0x555fe90fU : c.x < 128 ? 0x0U : d : d;\\n            d = (c.y==10) ? c.x < 16 ? 0xe6aaafe9U : c.x < 32 ? 0xaaafe90fU : c.x < 48 ? 0xafe90fe6U : c.x < 64 ? 0xfe6aaU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xaaafe90fU : c.x < 128 ? 0x1U : d : d;\\n            d = (c.y==11) ? c.x < 16 ? 0xdaaaafe9U : c.x < 32 ? 0xaaafe90fU : c.x < 48 ? 0xafe90fdaU : c.x < 64 ? 0xfdaaaU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xaaafe90fU : c.x < 128 ? 0x6U : d : d;\\n            d = (c.y==12) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffffe90fU : c.x < 48 ? 0xffe90fffU : c.x < 64 ? 0xfffffU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xffffe90fU : c.x < 128 ? 0x3fU : d : d;\\n            d = (c.y==13) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffffe903U : c.x < 48 ? 0xffe90fffU : c.x < 64 ? 0x3ffffU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xffffe90fU : c.x < 128 ? 0x3fU : d : d;\\n            d = (c.y==14) ? c.x < 16 ? 0xffffffe9U : c.x < 32 ? 0xffffe900U : c.x < 48 ? 0xffe90fffU : c.x < 64 ? 0xffffU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xffffe90fU : c.x < 128 ? 0x3fU : d : d;\\n            d = (c.y==15) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0x3fcU : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe9000fe9U : c.x < 112 ? 0xfe90fU : c.x < 128 ? 0x0U : d : d;\\n            d = (c.y==16) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0xff0U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xe6400fe4U : c.x < 112 ? 0xfe90fU : c.x < 128 ? 0x0U : d : d;\\n            d = (c.y==17) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0x3fc0U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xda900fd0U : c.x < 112 ? 0xfe90fU : c.x < 128 ? 0x0U : d : d;\\n            d = (c.y==18) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0xff00U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xfaa57fc0U : c.x < 112 ? 0x555fe90fU : c.x < 128 ? 0x15U : d : d;\\n            d = (c.y==19) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0x3fd00U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xfe9aff00U : c.x < 112 ? 0xaaafe903U : c.x < 128 ? 0x6aU : d : d;\\n            d = (c.y==20) ? c.x < 16 ? 0xfe9U : c.x < 32 ? 0xfe900U : c.x < 48 ? 0xfe90fe9U : c.x < 64 ? 0xff900U : c.x < 80 ? 0xfe90U : c.x < 96 ? 0xff6bfc00U : c.x < 112 ? 0xaaafe900U : c.x < 128 ? 0x1aaU : d : d;\\n            d = (c.y==21) ? c.x < 16 ? 0xfe4U : c.x < 32 ? 0xfe400U : c.x < 48 ? 0xfe40fe4U : c.x < 64 ? 0xfe400U : c.x < 80 ? 0xfe40U : c.x < 96 ? 0x3ffff000U : c.x < 112 ? 0xffffe400U : c.x < 128 ? 0xfffU : d : d;\\n            d = (c.y==22) ? c.x < 16 ? 0xfd0U : c.x < 32 ? 0xfd000U : c.x < 48 ? 0xfd00fd0U : c.x < 64 ? 0xfd000U : c.x < 80 ? 0xfd00U : c.x < 96 ? 0xfffc000U : c.x < 112 ? 0xffffd000U : c.x < 128 ? 0xfffU : d : d;\\n            d = (c.y==23) ? c.x < 16 ? 0xfc0U : c.x < 32 ? 0xfc000U : c.x < 48 ? 0xfc00fc0U : c.x < 64 ? 0xfc000U : c.x < 80 ? 0xfc00U : c.x < 96 ? 0x3ff0000U : c.x < 112 ? 0xffffc000U : c.x < 128 ? 0xfffU : d : d;\\n            c.y -= 24;\\t\\n\\n            d = (c.y==0) ? c.x < 16 ? 0xfff00000U : c.x < 32 ? 0xfffU : c.x < 48 ? 0xffffffffU : c.x < 64 ? 0xfff00000U : c.x < 80 ? 0xfffU : c.x < 96 ? 0x3c000U : d : d;\\n            d = (c.y==1) ? c.x < 16 ? 0x40000000U : c.x < 32 ? 0x1U : c.x < 48 ? 0x14000U : c.x < 64 ? 0x40000000U : c.x < 80 ? 0x1U : c.x < 96 ? 0x14000U : d : d;\\n            d = (c.y==2) ? c.x < 16 ? 0x55000000U : c.x < 32 ? 0x30055U : c.x < 48 ? 0x555500U : c.x < 64 ? 0x5500000cU : c.x < 80 ? 0x300055U : c.x < 96 ? 0x555500U : d : d;\\n            d = (c.y==3) ? c.x < 16 ? 0x55557fU : c.x < 32 ? 0x555c0155U : c.x < 48 ? 0x1550055U : c.x < 64 ? 0x55555cU : c.x < 80 ? 0x555c0155U : c.x < 96 ? 0x1550055U : d : d;\\n            d = (c.y==4) ? c.x < 16 ? 0x55400U : c.x < 32 ? 0x54300554U : c.x < 48 ? 0x5540005U : c.x < 64 ? 0x5540cU : c.x < 80 ? 0x54030554U : c.x < 96 ? 0x5540005U : d : d;\\n            d = (c.y==5) ? c.x < 16 ? 0x100000U : c.x < 32 ? 0x400U : c.x < 48 ? 0x4000010U : c.x < 64 ? 0x100000U : c.x < 80 ? 0x400U : c.x < 96 ? 0x4000010U : d : d;\\n            d = (c.y==6) ? c.x < 16 ? 0x400000U : c.x < 32 ? 0x100U : c.x < 48 ? 0x1000040U : c.x < 64 ? 0x400000U : c.x < 80 ? 0x100U : c.x < 96 ? 0x1000040U : d : d;\\n            d = (c.y==7) ? c.x < 16 ? 0x55000000U : c.x < 32 ? 0x55U : c.x < 48 ? 0x555500U : c.x < 64 ? 0x55000000U : c.x < 80 ? 0x55U : c.x < 96 ? 0x555500U : d : d;\\n            d = (c.y==8) ? c.x < 16 ? 0x8000000U : c.x < 32 ? 0x8020U : c.x < 48 ? 0x80200800U : c.x < 64 ? 0x8000000U : c.x < 80 ? 0x8020U : c.x < 96 ? 0x80200800U : d : d;\\n            d = (c.y==9) ? c.x < 16 ? 0xaaaa0000U : c.x < 32 ? 0x2aaaU : c.x < 48 ? 0x2aaaaaaaU : c.x < 64 ? 0xaaaa0000U : c.x < 80 ? 0x2aaaU : c.x < 96 ? 0x2aaaaaaaU : d : d;\\n            c.y -= 10;\\n\\n            d = (c.y==0) ? c.x < 16 ? 0xaa00U : d : d;\\n            d = (c.y==1) ? c.x < 16 ? 0xaaaa0U : d : d;\\n            d = (c.y==2) ? c.x < 16 ? 0x2aaaa8U : d : d;\\n            d = (c.y==3) ? c.x < 16 ? 0xaaaaaaU : d : d;\\n            d = (c.y==4) ? c.x < 16 ? 0xaaaaaaU : d : d;\\n            d = (c.y==5) ? c.x < 16 ? 0x14aaaaaaU : d : d;\\n            d = (c.y==6) ? c.x < 16 ? 0x14c00003U : d : d;\\n            d = (c.y==7) ? c.x < 16 ? 0xaa30000cU : d : d;\\n            d = (c.y==8) ? c.x < 16 ? 0x2830000cU : d : d;\\n            d = (c.y==9) ? c.x < 16 ? 0x280c0030U : d : d;\\n            d = (c.y==10) ? c.x < 16 ? 0x820c0030U : d : d;\\n            d = (c.y==11) ? c.x < 16 ? 0x820300c0U : d : d;\\n            d = (c.y==12) ? c.x < 16 ? 0x820300c0U : d : d;\\n            d = (c.y==13) ? c.x < 16 ? 0x8200c300U : d : d;\\n            c.y -= 14;\\n\\n            d = (c.y==0) ? c.x < 16 ? 0x5500U : d : d;\\n            d = (c.y==1) ? c.x < 16 ? 0x15540U : d : d;\\n            d = (c.y==2) ? c.x < 16 ? 0x55550U : d : d;\\n            d = (c.y==3) ? c.x < 16 ? 0x7d7d0U : d : d;\\n            d = (c.y==4) ? c.x < 16 ? 0x55550U : d : d;\\n            d = (c.y==5) ? c.x < 16 ? 0x115544U : d : d;\\n            d = (c.y==6) ? c.x < 16 ? 0x505505U : d : d;\\n            d = (c.y==7) ? c.x < 16 ? 0x46910U : d : d;\\n            d = (c.y==8) ? c.x < 16 ? 0x11440U : d : d;\\n            d = (c.y==9) ? c.x < 16 ? 0x4100U : d : d;\\n            d = (c.y==10) ? c.x < 16 ? 0x1400U : d : d;\\n            d = (c.y==11) ? c.x < 16 ? 0x1400U : d : d;\\n            d = (c.y==12) ? c.x < 16 ? 0x4100U : d : d;\\n            d = (c.y==13) ? c.x < 16 ? 0x50050U : d : d;\\n            d = (c.y==14) ? c.x < 16 ? 0x10040U : d : d;\\n            c.y -= 15;\\n\\n            d = (c.y==0) ? c.x < 16 ? 0x2aU : c.x < 32 ? 0x2a0000U : c.x < 48 ? 0x0U : d : d;\\n            d = (c.y==1) ? c.x < 16 ? 0x82U : c.x < 32 ? 0x820000U : c.x < 48 ? 0x0U : d : d;\\n            d = (c.y==2) ? c.x < 16 ? 0x202U : c.x < 32 ? 0x2020000U : c.x < 48 ? 0x0U : d : d;\\n            d = (c.y==3) ? c.x < 16 ? 0x808U : c.x < 32 ? 0x8080000U : c.x < 48 ? 0x0U : d : d;\\n            d = (c.y==4) ? c.x < 16 ? 0xaaaaa008U : c.x < 32 ? 0xa0080156U : c.x < 48 ? 0x156aaaaU : d : d;\\n            d = (c.y==5) ? c.x < 16 ? 0x20U : c.x < 32 ? 0x200558U : c.x < 48 ? 0x5580000U : d : d;\\n            d = (c.y==6) ? c.x < 16 ? 0x20U : c.x < 32 ? 0x201560U : c.x < 48 ? 0x15600000U : d : d;\\n            d = (c.y==7) ? c.x < 16 ? 0xffff008cU : c.x < 32 ? 0xb0aa80U : c.x < 48 ? 0xaa80ffffU : d : d;\\n            d = (c.y==8) ? c.x < 16 ? 0x80U : c.x < 32 ? 0x832000U : c.x < 48 ? 0x20000000U : d : d;\\n            d = (c.y==9) ? c.x < 16 ? 0xaaaaaa33U : c.x < 32 ? 0xaa300aaaU : c.x < 48 ? 0xaaaaaaaU : d : d;\\n            col = unpackCol(uint(c.x), d);\\n        } else {\\n            c.y -= ycol;\\n            if(c.y==0) d =c.x < 32 ? 0x1e001e33U : c.x < 64 ? 0x7f3f1c3cU : c.x < 96 ? 0x3c183e00U : c.x < 128 ? 0x387e383cU : c.x < 160 ? 0x3c3e3fU : d;\\n            if(c.y==1) d =c.x < 32 ? 0x33000c33U : c.x < 64 ? 0x46663666U : c.x < 96 ? 0x661c631cU : c.x < 128 ? 0xc063c66U : c.x < 160 ? 0x666333U : d;\\n            if(c.y==2) d =c.x < 32 ? 0x7000c33U : c.x < 64 ? 0x16666303U : c.x < 96 ? 0x6018731cU : c.x < 128 ? 0x63e3660U : c.x < 160 ? 0x666330U : d;\\n            if(c.y==3) d =c.x < 32 ? 0xe3f0c3fU : c.x < 64 ? 0x1e3e6303U : c.x < 96 ? 0x38187b00U : c.x < 128 ? 0x3e603338U : c.x < 160 ? 0x7c3e18U : d;\\n            if(c.y==4) d =c.x < 32 ? 0x38000c33U : c.x < 64 ? 0x16366303U : c.x < 96 ? 0xc186f00U : c.x < 128 ? 0x66607f60U : c.x < 160 ? 0x60630cU : d;\\n            if(c.y==5) d =c.x < 32 ? 0x33000c33U : c.x < 64 ? 0x46663666U : c.x < 96 ? 0x6618671cU : c.x < 128 ? 0x66663066U : c.x < 160 ? 0x30630cU : d;\\n            if(c.y==6) d =c.x < 32 ? 0x1e001e33U : c.x < 64 ? 0x7f671c3cU : c.x < 96 ? 0x7e7e3e1cU : c.x < 128 ? 0x3c3c783cU : c.x < 160 ? 0x1c3e0cU : d;\\n            c.y -= 7;\\n\\n            if(c.y==0) d =c.x < 32 ? 0x3c7f3f3fU : c.x < 64 ? 0x3cU : c.x < 96 ? 0x0U : c.x < 128 ? 0x7U : c.x < 160 ? 0x3f3e7fU : c.x < 192 ? 0x3f667f67U : c.x < 224 ? 0x1f3f1c3eU : c.x < 256 ? 0x1c0f3f00U : c.x < 288 ? 0x66U : d;\\n            if(c.y==1) d =c.x < 32 ? 0x66466666U : c.x < 64 ? 0x66U : c.x < 96 ? 0x0U : c.x < 128 ? 0x6U : c.x < 160 ? 0x666346U : c.x < 192 ? 0x66664666U : c.x < 224 ? 0x36663663U : c.x < 256 ? 0x36066600U : c.x < 288 ? 0x66U : d;\\n            if(c.y==2) d =c.x < 32 ? 0xc166666U : c.x < 64 ? 0x3b7e000cU : c.x < 96 ? 0x3e3e1eU : c.x < 128 ? 0x3b1e3eU : c.x < 160 ? 0x666316U : c.x < 192 ? 0x66661636U : c.x < 224 ? 0x66666363U : c.x < 256 ? 0x63066600U : c.x < 288 ? 0x66U : d;\\n            if(c.y==3) d =c.x < 32 ? 0x181e3e3eU : c.x < 64 ? 0x66030018U : c.x < 96 ? 0x636330U : c.x < 128 ? 0x6e3066U : c.x < 160 ? 0x3e631eU : c.x < 192 ? 0x3e3c1e1eU : c.x < 224 ? 0x663e7f63U : c.x < 256 ? 0x7f063e00U : c.x < 288 ? 0x3cU : d;\\n            if(c.y==4) d =c.x < 32 ? 0x30163606U : c.x < 64 ? 0x3e3e0030U : c.x < 96 ? 0x7f033eU : c.x < 128 ? 0x63e66U : c.x < 160 ? 0x366316U : c.x < 192 ? 0x66181636U : c.x < 224 ? 0x66366363U : c.x < 256 ? 0x63460600U : c.x < 288 ? 0x18U : d;\\n            if(c.y==5) d =c.x < 32 ? 0x66466606U : c.x < 64 ? 0x6600066U : c.x < 96 ? 0x36333U : c.x < 128 ? 0x63366U : c.x < 160 ? 0x666306U : c.x < 192 ? 0x66184666U : c.x < 224 ? 0x36666363U : c.x < 256 ? 0x63660600U : c.x < 288 ? 0x18U : d;\\n            if(c.y==6) d =c.x < 32 ? 0x3c7f670fU : c.x < 64 ? 0xf3f003cU : c.x < 96 ? 0x3e3e6eU : c.x < 128 ? 0xf6e3bU : c.x < 160 ? 0x673e0fU : c.x < 192 ? 0x3f3c7f67U : c.x < 224 ? 0x1f67633eU : c.x < 256 ? 0x637f0f00U : c.x < 288 ? 0x3cU : d;\\n            col = unpackBW(uint(c.x), d);\\n        }\\n    }\\n    \\n    fragColor = vec4(col,1.0);\\n}","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"lldcR8","date":"1538844872","viewed":10628,"name":"Portal - iOS AR","description":"This is an experiment to create an \\"AR shader\\" by implementing the mainVR-function and using the WebCam texture as background. Use the [url=https://itunes.apple.com/us/app/shadertoy/id717961814]Shadertoy iOS app[/url] to view this shader.","likes":57,"published":"Public API","usePreview":0,"tags":["ar","portal","ios"]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Portal - iOS AR. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lldcR8\\n//\\n// This is an experiment to create an \\"AR shader\\" by implementing the mainVR-function and \\n// using the WebCam texture as background. If you view this shader with the Shadertoy iOS \\n// app[1], you can walk around and enter the portal.\\n//\\n// If you don't have an iOS device (or if you don't have the app installed) you can find a\\n// screen capture of the shader in action here: https://youtu.be/IzeeoD0e6Ow.\\n//\\n//\\n// Common tab: The VR-scene is shaded using analytical area lighting. I have used code of\\n//             dys129 shader \\"Analytic Area Light\\" to implement this technique:\\n//             https://www.shadertoy.com/view/4tXSR4\\n//\\n// Buffer A:   Buffer A keeps track of the camera-position and calculates if the user has\\n//             entered the portal.\\n//\\n// Image tab:  A raymarcher is used to render the VR scene.\\n//\\n// [1] https://itunes.apple.com/us/app/shadertoy/id717961814\\n//\\n\\nfloat hash12( vec2 p ) {\\n    p  = 50.0*fract( p*0.3183099 );\\n    return fract( p.x*p.y*(p.x+p.y) );\\n}\\n\\nfloat noise( in vec2 x ) {\\n    vec2 f = fract(x);\\n    vec2 u = f*f*(3.0-2.0*f);\\n    \\n    vec2 p = vec2(floor(x));\\n    float a = hash12( (p+vec2(0,0)) );\\n\\tfloat b = hash12( (p+vec2(1,0)) );\\n\\tfloat c = hash12( (p+vec2(0,1)) );\\n\\tfloat d = hash12( (p+vec2(1,1)) );\\n    \\n\\treturn a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\\n}\\n\\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\\n\\nfloat fbm( in vec2 p, const int OCTAVES ) {\\n    float a = 0.;\\n    float b = .5;\\n    for( int i=0; i<OCTAVES; i++ ) {\\n        a += noise(p) * b;\\n\\t\\tb *= 0.5;\\n        p = m2*p;\\n    }\\n\\treturn a;\\n}\\n\\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\\n}\\n\\nfloat map( in vec3 p ) {\\n    p.xz += PILLAR_SPACING *.5;\\n    float d = p.y;\\n    \\n    vec2 pm = mod( p.xz + vec2(PILLAR_SPACING*.5), \\n                  \\t\\t  vec2(PILLAR_SPACING) ) - vec2(PILLAR_SPACING*.5);\\n    d = min(d, max(abs(pm.x) - PILLAR_WIDTH_HALF, abs(pm.y) - PILLAR_WIDTH_HALF));\\n    \\n    vec2 cm = mod( p.xz,  vec2(PILLAR_SPACING) ) - vec2(PILLAR_SPACING*.5);\\n    \\n    d = min( d, CEILING_HEIGHT - p.y );\\n    d = max( d, -PILLAR_WIDTH_HALF+PILLAR_SPACING*.5-\\n            length( vec2(p.y-CEILING_HEIGHT, min(abs(cm.x),abs(cm.y)))));\\n    return d;\\n}\\n\\nvec4 tex3D( sampler2D sam, in vec3 p, in vec3 n ) {\\n    p.xz = mat2(0.8,-0.6,0.6,0.8) * p.xz + .5;\\n    \\n\\tvec4 x = texture( sam, p.yz );\\n\\tvec4 y = texture( sam, p.zx );\\n\\tvec4 z = texture( sam, p.xy );\\n\\n\\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\\n}\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    vec2 e = vec2(1.0,-1.0)*0.0001;\\n    return normalize( e.xyy*map( pos + e.xyy ) + \\n\\t\\t\\t\\t\\t  e.yyx*map( pos + e.yyx ) + \\n\\t\\t\\t\\t\\t  e.yxy*map( pos + e.yxy ) + \\n\\t\\t\\t\\t\\t  e.xxx*map( pos + e.xxx ) );\\n}\\n\\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\\n\\tfloat res = 1.0;\\n    float t = mint;\\n    float ph = 1e10; \\n    for( int i=0; i<24; i++ ) {\\n\\t\\tfloat h = map( ro + rd*t );\\n       \\tfloat y = h*h/(2.0*ph);\\n        float d = sqrt(max(0.,h*h-y*y));\\n        res = min( res, 8.0*d/max(0.01,t-y) );\\n        ph = h;\\n        t += min(h, .2);// clamp( h, 0.02, 0.10 );\\n        if( res<0.001 || t>tmax ) break;\\n    }\\n    return clamp( res, 0.0, 1.0 );\\n}\\n\\nfloat calcAO( in vec3 pos, in vec3 nor ) {\\n\\tfloat occ = 0.0;\\n    float sca = 1.0;\\n    for( int i=0; i<5; i++ )\\n    {\\n        float hr = 0.01 + 0.3*float(i)/4.0;\\n        vec3 aopos =  nor * hr + pos;\\n        float dd = map( aopos );\\n        occ += -(dd-hr)*sca;\\n        sca *= 0.75;\\n    }\\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \\n}\\n\\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in sampler2D sam, bool inside ) {\\n    float portalAlpha = 0.;\\n    vec3 fogColor = vec3(0.1,0.3,.5) + rd * .1;\\n    float tmin = 0.01;\\n    const float tmax = 21.;\\n    \\n    vec3 portalColor = texture(sam, uv).rgb * 1.25;\\n    // Use mipmap level 9 to get an average environment color from the webcam texture\\n    // used for lighting.\\n    vec3 lightColor = pow(.25 + .75 * texelFetch(sam, ivec2(0), 9).rgb, vec3(2.2)) * 3.;\\n      \\n    // portal intersection\\n    float portalDist = iPlane( ro, rd, vec4(0,0,1,-dot(PORTAL_POS,vec3(0,0,1))));\\n    if (portalDist < 0.) {\\n        portalDist = 5e5;\\n    } else {\\n        vec3 p = ro + rd * portalDist;\\n        float time = iTime * .15;\\n        float scale = 6.;\\n        vec2 offset = vec2(fbm(p.xy * scale + time, 4), fbm(p.yx * scale - time, 4)) -.5;\\n        p.xy += (fbm(offset * scale + time, 4) - .5) * .2;\\n        if(all(lessThan(abs(p.xy-PORTAL_POS.xy),PORTAL_SIZE.xy))) {\\n            vec2 bd = abs(p.xy-PORTAL_POS.xy) - (PORTAL_SIZE.xy -PORTAL_BORDER.xy);\\n            bd = max(bd, vec2(0))/PORTAL_BORDER.xy;\\n                \\n\\t        portalAlpha = 1.-smoothstep(0.5, 1., length(bd));\\n         }\\n        if(inside) {\\n        \\ttmin = portalDist;\\n        }\\n    }\\n    \\n    float t = tmin;\\n    for( int i=0; i<48; i++ ) {\\n\\t    float precis = 0.001*t;\\n\\t    float res = map( ro+rd*t );\\n        if( res<precis || t>tmax ) break;\\n        t += res;\\n    }\\n    \\n    portalAlpha = inside ? 1. - portalAlpha : portalAlpha;\\n\\n    vec3 col = vec3(0);\\n    \\n    // background scene\\n    if (t < tmax && portalAlpha < 1.) {\\n        vec3 p = ro + t * rd;\\n        vec3 N = calcNormal(p);\\n        vec3 R = reflect(rd, N);\\n        vec3 tex = tex3D(iChannel2, p, N).rgb;\\n\\n        col = vec3( tex ) * clamp(p.y+.6, 0., 1.);\\n\\n        float diff = shd_polygonal(p, N, false);\\n        float spc = clamp(shd_polygonal(p, R, true), 0., 1.);\\n        float l = (diff * 6. + spc * dot(tex,tex));\\n\\n        vec3 ld = p-PORTAL_POS;\\n        \\n        l *= calcSoftshadow(p, -normalize(ld), .02, length(ld)-.5);\\n\\t\\tl *= (.5+.5*calcAO(p, N));\\n        col *= l * lightColor;\\n    }\\n    \\n    if (!inside && t < portalDist) {\\n        portalAlpha = 0.;\\n    }\\n    \\n    // height based fog, see https://iquilezles.org/articles/fog\\n    const float C = .075;\\n    const float B = 1.1;\\n    float fogAmount = clamp(C * exp(-ro.y*B) * (1.-exp( -t*rd.y*B))/rd.y, 0., 4.);\\n    col = mix( col, fogColor, fogAmount);\\n\\n    // gamma\\n    col = mix(col, sqrt(clamp(col,vec3(0),vec3(1))), .95);\\n    \\n\\tcol = mix( col, portalColor, portalAlpha);\\n    \\n    return clamp(col,vec3(0),vec3(1));\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\\n   \\n    float a = .3 * iTime;\\n    vec3 ro = vec3( 3.9*sin(a), 0.7, 3.2*cos(a) + .5 );\\n    vec3 ta = vec3( 0.25, 0.6, 0.5 );\\n    \\n    mat3 ca = setCamera( ro, ta, 0.0 );\\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\\n\\n    vec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, iChannel3, false);\\n    fragColor = vec4(col,1.0);\\n}\\n\\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\\n    ro += PORTAL_POS + START_OFFSET;\\n    \\n    vec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, iChannel0, \\n                      texelFetch(iChannel1, ivec2(0), 0).w > .5);\\n    fragColor = vec4(col,1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Portal - iOS AR. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lldcR8\\n//\\n// This is an experiment to create an \\"AR shader\\" by implementing the mainVR-function and \\n// using the WebCam texture as background. If you view this shader with the Shadertoy iOS \\n// app[1], you can walk around and enter the portal.\\n//\\n// If you don't have an iOS device (or if you don't have the app installed) you can have a \\n// look at this screen capture to see the shader in action: https://youtu.be/IzeeoD0e6Ow.\\n//\\n\\n#define PI 3.14159265359\\n#define PORTAL_POS vec3(0.05,0.9, 0.02)\\n#define PORTAL_SIZE vec3(0.45,0.75, 0.)\\n#define START_OFFSET vec3(0.,0.4,1.2)\\n#define PORTAL_BORDER vec3(0.15,0.15, 0.)\\n#define PILLAR_WIDTH_HALF .15\\n#define PILLAR_SPACING 2.1\\n#define CEILING_HEIGHT 2.5\\n\\nconst int N = 30;\\n\\n#define NUM_VERTS 4\\nconst vec3[] verts = vec3[] (\\n        vec3(PORTAL_SIZE.x, -PORTAL_SIZE.y, 0) + PORTAL_POS,\\n        vec3(-PORTAL_SIZE.x, -PORTAL_SIZE.y, 0) + PORTAL_POS,\\n        vec3(-PORTAL_SIZE.x, PORTAL_SIZE.y, 0) + PORTAL_POS,\\n        vec3(PORTAL_SIZE.x, PORTAL_SIZE.y, 0) + PORTAL_POS);\\n\\nfloat cosine_sine_power_integral_sum(float theta, float cos_theta, float sin_theta,\\n\\tint n, float a, float b) {\\n\\tfloat f = a*a + b*b;\\n\\tfloat g = a*cos_theta + b*sin_theta;\\n\\tfloat gsq = g*g;\\n\\tfloat asq = a*a;\\n\\tfloat h = a*sin_theta - b*cos_theta;\\n\\tfloat T = theta, Tsum;\\n\\tfloat l = g*h, l2 = b*a;\\n\\tint start = 0;\\n\\n\\tTsum = T;\\n\\tfor (int i = 2; i <= N - 1; i += 2) {\\n\\t\\tT = (l + l2 + f*(float(i) - 1.)*T) * (1. / float(i));\\n\\t\\tl *= gsq;\\n\\t\\tl2 *= asq;\\n\\t\\tTsum += T;\\n\\t}\\n\\treturn Tsum;\\n}\\n\\nfloat P(float theta, float a) {\\n\\treturn 1.0 / (1.0 + a * theta * theta);\\n}\\n\\nfloat I_org(float theta, float c, float n) {\\n\\tfloat cCos = c * cos(theta);\\n\\treturn (pow(cCos, n + 2.) - 1.0) / (cCos * cCos - 1.);\\n}\\n\\nfloat evaluateXW(float c, float n) {\\n\\treturn PI / 4. * pow(1. - pow(c - c / (n - 1.), 2.5), 0.45);\\n}\\n\\nfloat shd_edge_contribution(vec3 v0, vec3 v1, vec3 n, int e) {\\n\\tfloat f;\\n\\tfloat cos_theta, sin_theta;\\n\\tvec3 q = cross(v0, v1); //ni\\n\\tsin_theta = length(q);\\n\\tq = normalize(q);\\n\\tcos_theta = dot(v0, v1);\\n\\n\\tif (e == 1) {\\n\\t\\tf = acos(cos_theta);\\n\\t} else {\\n\\t\\tvec3 w;\\n\\t\\tfloat theta;\\n\\t\\ttheta = acos(cos_theta);\\n\\t\\tw = cross(q, v0);\\n\\t\\tf = cosine_sine_power_integral_sum(theta, cos_theta, sin_theta, e - 1, dot(v0, n), dot(w, n));\\n\\t}\\n\\treturn f * dot(q, n);\\n}\\n\\n\\nvoid seg_plane_intersection(vec3 v0, vec3 v1, vec3 n, out vec3 q) {\\n\\tvec3 vd;\\n\\tfloat t;\\n\\tvd = v1 - v0;\\n\\tt = -dot(v0, n) / (dot(vd, n));\\n\\tq = v0 + t * vd;\\n}\\n\\nfloat shd_polygonal(vec3 p, vec3 n, bool spc) {\\n\\tint i, i1;\\n\\tint J = 0;\\n\\tfloat sum = 0.;\\n\\tvec3 ui0, ui1;\\n\\tvec3 vi0, vi1;\\n\\tint belowi0 = 1, belowi1 = 1;\\n    \\n\\tfor (int j = 0; j < NUM_VERTS; j++) {\\n\\t\\tvec3 u;\\n\\t\\tu = verts[j] - p;\\n\\t\\tif (dot(u, n) >= 0.0) {\\n\\t\\t\\tui0 = u;\\n\\t\\t\\tvi0 = u;\\n\\t\\t\\tvi0 = normalize(vi0);\\n\\t\\t\\tbelowi0 = 0;\\n\\t\\t\\tJ = j;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n    if (J >= NUM_VERTS) {\\n        return 0.;\\n    } else {\\n        i1 = J;\\n        for (int i = 0; i < NUM_VERTS; i++) {\\n            i1++;\\n            if (i1 >= NUM_VERTS) i1 = 0;\\n\\n            ui1 = verts[i1] - p;\\n            belowi1 = int(dot(ui1, n) < 0.);\\n\\n            if (belowi1 == 0) {\\n                vi1 = ui1;\\n                vi1 = normalize(vi1);\\n            }\\n\\n            if (belowi0 != 0 && belowi1 == 0) {\\n                vec3 vinter;\\n                seg_plane_intersection(ui0, ui1, n, vinter);\\n                vinter = normalize(vinter + 0.01);\\n                sum += shd_edge_contribution(vi0, vinter, n, 1);\\n                vi0 = vinter;\\n            }\\n            else if (belowi0 == 0 && belowi1 != 0) {\\n                seg_plane_intersection(ui0, ui1, n, vi1);\\n                vi1 = normalize(vi1);\\n            }\\n            int K = spc ? N : 1;\\n\\n            if (belowi0 == 0 || belowi1 == 0) sum += shd_edge_contribution(vi0, vi1, n, K);\\n\\n\\n            ui0 = ui1;\\n            vi0 = vi1;\\n            belowi0 = belowi1;\\n        }\\n\\t}\\n\\treturn abs(sum) / (2. * PI);\\n}\\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Portal - iOS AR. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/lldcR8\\n//\\n// This is an experiment to create an \\"AR shader\\" by implementing the mainVR-function and \\n// using the WebCam texture as background. If you view this shader with the Shadertoy iOS \\n// app[1], you can walk around and enter the portal.\\n//\\n// If you don't have an iOS device (or if you don't have the app installed) you can have a \\n// look at this screen capture to see the shader in action: https://youtu.be/IzeeoD0e6Ow.\\n//\\n\\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    fragColor = vec4(1);\\n}\\n\\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\\n    ro += PORTAL_POS + START_OFFSET;\\n    \\n    bool inside = false;\\n    vec3 oldRo = ro;\\n    \\n    if (iFrame > 0) {\\n    \\tvec4 t = texelFetch(iChannel0, ivec2(0), 0);\\n        oldRo = t.xyz;\\n        inside = t.w > .5;\\n        \\n        vec3 rd = normalize( ro - oldRo );\\n        float portalDist = iPlane( oldRo, rd, vec4(0,0,1,-dot(PORTAL_POS,vec3(0,0,1))));\\n\\t    if (portalDist > 0. && portalDist <= length( ro - oldRo) ) {\\n    \\t    vec3 p = oldRo + rd * portalDist;\\n        \\tif(all(lessThan(abs(p.xy-PORTAL_POS.xy),PORTAL_SIZE.xy))) {\\n                inside = !inside;\\n            }\\n        }\\n    }\\n    \\n    fragColor = vec4(ro, inside ? 1. : 0.);\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XtcyW4","date":"1532538696","viewed":40432,"name":"[SH18] Human Document","description":"This shader uses motion capture data to animate a humanoid. Image Based Lighting (IBL) is used to render the scene. Have a look at my shader [url=https://www.shadertoy.com/view/lscBW4]Old watch (IBL)[/url] for a clean implementation of IBL.\\n(mouseable)","likes":267,"published":"Public API","usePreview":1,"tags":["ibl","mocap","sh18"]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [SH18] Human Document. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XtcyW4\\n//\\n//   *Created for the Shadertoy Competition 2018*\\n//\\n// 07/29/2018 I have made some optimizations and bugfixes, so I could enable AA. \\n// \\n//            !! Please change AA (line 47) to 1 if your framerate is below 60 \\n//               (or if you're running the shader fullscreen).\\n//\\n// This shader uses motion capture data to animate a humanoid. The animation data is\\n// compressed by storing only a fraction of the coeffecients of the Fourier transform\\n// of the positions of the bones (Buffer A). An inverse Fourier transform is used to \\n// reconstruct the data needed.\\n// \\n// Image Based Lighting (IBL) is used to render the scene. Have a look at my shader \\n// \\"Old watch (IBL)\\" (https://www.shadertoy.com/view/lscBW4) for a clean implementation\\n// of IBL.\\n// \\n// Buffer A: I have preprocessed a (motion captured) animation by taking the Fourier \\n//           transform of the position of all bones (14 bones, 760 frames). Only a fraction \\n//           of all calculated coefficients are stored in this shader: the first \\n//           coefficients with 16 bit precision, later coefficients with 8 bit. The positions\\n//           of the bones are reconstructed each frame by taking the inverse Fourier\\n//           transform of this data.\\n//\\n//           I have used (part of) an animation from the Carnegie Mellon University Motion \\n//           Capture Database. The animations of this database are free to use:\\n//\\n//           - http://mocap.cs.cmu.edu/\\n// \\n//           igo Qulez has created some excellent shaders that show the properties of \\n//           Fourier transforms, for example: \\n//\\n//           - https://www.shadertoy.com/view/4lGSDw\\n//           - https://www.shadertoy.com/view/ltKSWD\\n//\\n// Buffer B: The BRDF integration map used for the IBL and the drawing of the humanoid \\n//           are precalculated.\\n//\\n// Buffer C: Additional custom animation of the bones is calculated for the start\\n//           and end of the loop.\\n//\\n\\n#define MAX_LOD 8.\\n#define DIFFUSE_LOD 6.75\\n#define AA 2              // Please change to 1 if your framerate is below 60\\n#define MARCH_STEPS 40\\n\\nvec3 getSpherePosition(int i) {\\n    return texelFetch(iChannel2, ivec2(0,i), 0 ).xyz;\\n}\\n\\nfloat mapBody( in vec3 pos ) {\\n    float r = .1;\\n    float s = 80.;\\n\\n    vec3 p1 = getSpherePosition(LEFT_LEG_1);\\n    vec3 p2 = getSpherePosition(LEFT_LEG_2);\\n    float d = sdCapsule(pos, p1, p2, r, r*.5);\\n    vec2 res = vec2(d, MAT_PAPER);\\n\\n    p1 = getSpherePosition(LEFT_LEG_3);\\n    d = sdCapsule(pos, p1, p2, r, r*.5);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_LEG_1);\\n    p2 = getSpherePosition(RIGHT_LEG_2);\\n    d = sdCapsule(pos, p1, p2, r, r*.5);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_LEG_3);\\n    d = sdCapsule(pos, p1, p2, r, r*.5);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_LEG_3);\\n    p2 = getSpherePosition(SPINE);\\n    d = sdCapsule(pos, p1, p2, r, r);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(LEFT_LEG_3);\\n    d = sdCapsule(pos, p1, p2, r, r);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_ARM_1);\\n    p2 = getSpherePosition(RIGHT_ARM_2);\\n    d = sdCapsule(pos, p1, p2, r*.5, r*.25);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_ARM_3);\\n    d = sdCapsule(pos, p1, p2, r*.5, r*.25);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(LEFT_ARM_1);\\n    p2 = getSpherePosition(LEFT_ARM_2);\\n    d = sdCapsule(pos, p1, p2, r*.5, r*.25);\\n    res.x = smin(res.x, d, s); \\n\\n    p1 = getSpherePosition(LEFT_ARM_3);\\n    d = sdCapsule(pos, p1, p2, r*.5, r*.25);\\n    res.x = smin(res.x, d, s);    \\n\\n    return res.x;\\n}\\n\\nvec2 map( in vec3 pos, bool spInt, bool pencilIntersect ) {\\n\\t// table\\n    vec2 res = vec2(pos.y + 0.01, MAT_TABLE);\\n    \\n    //--- paper\\n    float dP = pos.y;    \\n    if( spInt ) {   \\t \\n        // smin with paper\\n        dP = smin(dP, mapBody(pos), 12.);\\n    }\\n    dP = opS(-sdBox(pos, vec3(PAPER_SIZE.x,10.,PAPER_SIZE.y)),dP);\\n    if (dP<res.x) { res = vec2(dP, MAT_PAPER); }\\n    \\n    // head\\n    float d = sdSphere(pos, vec4(getSpherePosition(HEAD),.1));\\n    if (d<res.x) { res = vec2(d, MAT_METAL_0); }\\n    \\n    //--- pencil\\n    if (pencilIntersect) {\\n        vec3 pen = pos;\\n        pen.xz = mat2(0.581683089463883,-0.813415504789374,\\n                      0.813415504789374, 0.581683089463883)*pen.xz;\\n        pen += PENCIL_POS;\\n        float dPencil0 = sdHexPrism(pen, vec2(.2, 2.));\\n        dPencil0 = opS(-sdCone(pen + (vec3(-2.05,0,0)), vec2(.95,0.3122)),dPencil0);\\n        dPencil0 = opS(sdSphere(pen + (vec3(-2.5,-0.82,2.86)), 3.), dPencil0);\\n        if (dPencil0 < res.x) res = vec2(dPencil0, MAT_PENCIL_0);\\n\\n        float dPencil1 = sdCapsule(pen, - vec3(2.2,0.,0.), -vec3(2.55, 0., 0.), .21);\\n        if (dPencil1 < res.x) res = vec2(dPencil1, MAT_PENCIL_1);\\n        float ax = abs(-2.25 - pen.x );\\n        float r = .02*abs(2.*fract(30.*pen.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\\n\\n        float dPencil2 = sdCylinderZY(pen + vec3(2.25,-0.0125,0), vec2(.22 - r,.25));\\n        if (dPencil2 < res.x) res = vec2(dPencil2, MAT_PENCIL_2);\\n    }\\n \\treturn res;   \\n}\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    bool sphInt = distance(pos,getSpherePosition(LEFT_LEG_3)) <  1.25 ? true : false;\\n    vec3 ropen = pos;\\n    ropen.xz = rotate(ropen.xz, PENCIL_ROT);\\n    ropen += PENCIL_POS;\\n    bool pencilIntersect = sdBox(ropen, vec3(3.,.4,.4)) < 0.;\\n    \\n    const vec2 e = vec2(1.0,-1.0)*0.01;\\n    return normalize( e.xyy*map( pos + e.xyy, sphInt, pencilIntersect ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map( pos + e.yyx, sphInt, pencilIntersect ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map( pos + e.yxy, sphInt, pencilIntersect ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map( pos + e.xxx, sphInt, pencilIntersect ).x );\\n}\\n\\nvec2 castRay( in vec3 ro, in vec3 rd ) {\\n    float tmax = 20.;\\n    \\n    vec3 rdpen = rd, ropen = ro;\\n    rdpen.xz = rotate(rdpen.xz, PENCIL_ROT);\\n    ropen.xz = rotate(ropen.xz, PENCIL_ROT);\\n    ropen += PENCIL_POS;\\n    \\n    vec2 sphDist = sphIntersect(ro-getSpherePosition(LEFT_LEG_3), rd, 1.25);\\n    vec2 pencilDist = boxIntersect(ropen, rdpen, vec3(3.,.24,.24));\\n    vec2 headDist = sphIntersect(ro-getSpherePosition(HEAD), rd, .11);\\n    \\n    bool pencilIntersect = pencilDist.x > 0.;\\n    bool sphInt = sphDist.y > 0.;\\n        \\n    float tmin = planeIntersect(ro,rd,.01);\\n    if (sphInt) {\\n        tmin = min(tmin, max(sphDist.x, 0.1));\\n    }\\n    if (pencilIntersect) {\\n        tmin = min(tmin, max(pencilDist.x, 0.11));\\n    }\\n    if (headDist.x > 0.) {\\n        tmin = min(tmin, headDist.x);\\n    }\\n    \\n    float t = tmin;\\n    float mat = -1.;\\n    \\n    for( int i=0; i<MARCH_STEPS; i++ ) {\\n\\t    float precis = 0.00025*t;\\n\\t    vec2 res = map( ro+rd*t, sphInt, pencilIntersect );\\n        if( res.x<precis || t>tmax ) break;\\n        t += res.x;\\n        mat = res.y;\\n    }\\n\\n    if( t>tmax ) t=-1.0;\\n    return vec2(t, mat);\\n}\\n\\nfloat calcAO( in vec3 ro, in vec3 rd ) {\\n\\tfloat occ = 0.0;\\n    float sca = 1.0;\\n    \\n    bool sphInt = sphIntersect(ro-getSpherePosition(LEFT_LEG_3), rd, 1.25).y > 0. ? true : false;\\n    vec3 ropen = ro;\\n    ropen.xz = rotate(ropen.xz, PENCIL_ROT);\\n    ropen += PENCIL_POS;\\n    bool pencilIntersect = sdBox(ropen, vec3(3.,.45,.45)) < 0.;\\n    \\n    for( int i=0; i<5; i++ ) {\\n        float h = 0.001 + 0.25*float(i)/4.0;\\n        float d = map( ro+rd*h, sphInt, pencilIntersect ).x;\\n        occ += (h-d)*sca;\\n        sca *= 0.95;\\n    }\\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \\n}\\n\\nvoid getMaterialProperties(\\n    in vec3 pos, in float mat,\\n    inout vec3 normal, inout vec3 albedo, inout float ao, inout float roughness, inout float metallic) {\\n    \\n    normal = calcNormal( pos );\\n    ao = calcAO(pos, normal);\\n    metallic = 0.;\\n    \\n    vec4 noise = texNoise(iChannel1, pos * .5, normal);\\n    float metalnoise = 1.- noise.r;\\n    metalnoise*=metalnoise;\\n\\n    mat -= .5;\\n    \\n    vec3 penpos = pos;\\n    penpos.xz = rotate(penpos.xz, PENCIL_ROT);\\n    penpos += PENCIL_POS;\\n    \\n    if (mat < MAT_TABLE) {\\n        albedo = 0.8*pow(texture(iChannel1, rotate(pos.xz * .4 + .25, -.3)).rgb, 2.2*vec3(0.45,0.5,0.5));\\n        roughness = 0.95 - albedo.r * .6;\\n    }\\n    else if( mat < MAT_PENCIL_0 ) {\\n        if (length(penpos.yz) < 0.055) {\\n        \\talbedo = vec3(0.02);\\n        \\troughness = .9;\\n        } else if(sdHexPrism(penpos, vec2(.195, 3.)) < 0.) {\\n        \\talbedo = .8* texture(iChannel1, penpos.xz).rgb;\\n        \\troughness = 0.99;\\n        } else {\\n        \\talbedo = .5*pow(vec3(1.,.8,.15), vec3(2.2));\\n        \\troughness = .75 - noise.b * .4;\\n        }\\n        albedo *= noise.g * .75 + .7;\\n    }\\n    else if( mat < MAT_PENCIL_1 ) {\\n       \\talbedo = .4*pow(vec3(.85,.75,.55), vec3(2.2));\\n       \\troughness = 1.;\\n    }\\n    else if( mat < MAT_PENCIL_2 ) {\\n        float ax = abs(-2.25 - penpos.x);\\n        float r = 1. - abs(2.*fract(30.*penpos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\\n\\n        r -= 4. * metalnoise;  \\n        ao *= .5 + .5 * r;\\n\\t    albedo = mix(vec3(0.5, 0.3, 0.2),vec3(0.560, 0.570, 0.580), ao * ao); // Iron\\n   \\t\\troughness = 1.-.25*r;\\n   \\t\\tmetallic = 1.; \\n    }\\n    else if( mat < MAT_PAPER ) {\\n        vec2 paperUV = (pos.xz-PAPER_SIZE)/(PAPER_SIZE*2.)+1.;\\n        vec2 tex = texture(iChannel3, paperUV.yx).zw;\\n    \\tfloat line = abs(paperUV.x-.5) > .45 ? 0. : smoothstep(0.1, 0.025, abs(sin(paperUV.y*75.)));\\n\\n        albedo = mix(vec3(.955 - .05*tex.x), vec3(.55,.65,.9), line);    \\t\\n        float figure = 1.-tex.y;\\n        float time = mod(offsetTime(iTime), DURATION_TOTAL);\\n        float start = 1.-smoothstep(DURATION_START-DURATION_MORPH_STILL, DURATION_START+DURATION_MORPH_ANIM, time);\\n        float end = smoothstep(DURATION_TOTAL-DURATION_MORPH, DURATION_TOTAL, time);\\n        figure *= max(start, end);\\n        \\n        albedo *= 1.-figure*.8;\\n        \\n       \\troughness = .65 + .3 *tex.x;\\n        metallic = 0.;\\n    }\\n    else if( mat < MAT_METAL_0 ) {\\n\\t    albedo = vec3(1.000, 0.766, 0.336); // Gold\\n   \\t\\troughness = .6;\\n   \\t\\tmetallic = 1.; \\n    }   \\n    if (metallic > .5) {   \\n        albedo *= 1.-metalnoise;\\n        roughness += metalnoise*4.;\\n    }\\n    \\n    ao = clamp(.2+.8*ao, 0., 1.);\\n    roughness = clamp(roughness, 0., 1.);\\n}\\n\\n//\\n// Image based lighting\\n// See: Old watch (IBL)\\n// https://www.shadertoy.com/view/lscBW4\\n//\\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\\n    return pow(textureLod(iChannel0, N, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\\n}\\nvec3 getDiffuseLightColor( vec3 N ) {\\n    return .25 +pow(textureLod(iChannel0, N, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\\n}\\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\\n}\\nvec3 lighting(in vec3 ro, in vec3 pos, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\\n    vec3 V = normalize(ro - pos); \\n    vec3 R = reflect(-V, N);\\n    float NdotV = max(0.0, dot(N, V));\\n\\n    vec3 F0 = vec3(0.04); \\n    F0 = mix(F0, albedo, metallic);\\n\\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\\n\\n    vec3 kS = F;\\n\\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\\n    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\\n\\n    vec3 kD = vec3(1.0) - kS;\\n\\n    kD *= 1.0 - metallic;\\n\\n    vec3 irradiance = getDiffuseLightColor(N);\\n\\n    vec3 diffuse  = albedo * irradiance;\\n    vec3 color = (kD * diffuse + specular) * ao;\\n\\n    return color;\\n}\\n\\n//\\n// main \\n//\\nvec3 render( const in vec3 ro, const in vec3 rd ) {\\n    vec3 col = vec3(0); \\n    vec2 res = castRay( ro, rd );\\n    \\n    if (res.x > 0.) {\\n        vec3 pos = ro + rd * res.x;\\n        vec3 N, albedo;\\n        float roughness, metallic, ao;\\n\\n        getMaterialProperties(pos, res.y, N, albedo, ao, roughness, metallic);\\n\\n        col = lighting(ro, pos, N, albedo, ao, roughness, metallic);\\n        col *= max(0.0, min(1.1, 20./dot(pos,pos)) - .1);\\n    }\\n    col = max( vec3(0), col - 0.004);\\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\\n    \\n    return col;\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta ) {\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(0.0, 1.0,0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec2 uv = fragCoord/iResolution.xy;\\n    vec2 mo = iMouse.xy/iResolution.xy - .5;\\n    if(iMouse.z <= 0.) {\\n        mo = vec2( 0.06+.1*sin(iTime*.035), 0. );\\n    }\\n    vec3 ro = vec3( 4.*sin(6.0*mo.x), 3. * mo.y + 3.5, -5.5*cos(6.0*mo.x) );\\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\\n    mat3 ca = setCamera( ro, ta );\\n\\n    vec3 colT = vec3(0);\\n    for (int x=0; x<AA; x++) {\\n        for(int y=0; y<AA; y++) {\\n\\t\\t    vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(x,y)/float(AA) - .5))/iResolution.y;\\n   \\t\\t\\tvec3 rd = ca * normalize(vec3(p.xy,2.3));  \\n            colT += render( ro, rd);           \\n        }\\n    }\\n    colT /= float(AA*AA);\\n    \\n    colT *= smoothstep(.5, 1.5, iTime);\\n    fragColor = vec4(colT, 1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// [SH18] Human Document. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XtcyW4\\n//\\n//   * Created for the Shadertoy Competition 2018 *\\n//\\n\\n// animation\\n\\n#define FRAMES (760.)\\n#define DURATION_ANIM (FRAMES/60.)\\n#define DURATION_START (4.)\\n#define DURATION_END (4.)\\n#define DURATION_MORPH_ANIM (.5)\\n#define DURATION_MORPH_STILL (.5)\\n#define DURATION_MORPH (DURATION_MORPH_ANIM+DURATION_MORPH_STILL)\\n#define DURATION_TOTAL (DURATION_START+DURATION_ANIM+DURATION_END)\\n\\nfloat frame;\\n\\nfloat offsetTime(float time) {\\n    return max(0., time-2.);\\n}\\n\\nvoid initAnimation(float time) {\\n    float t = mod(offsetTime(time), DURATION_TOTAL);\\n    frame = floor(clamp((t-DURATION_START)*60., 10., FRAMES-10.));\\n}\\n\\n// bone functions\\n\\nconst float planeY = -9.5;\\n\\n#define NUM_BONES 14\\n\\n#define LEFT_LEG_1 3\\n#define LEFT_LEG_2 4\\n#define LEFT_LEG_3 5\\n#define RIGHT_LEG_1 0\\n#define RIGHT_LEG_2 1\\n#define RIGHT_LEG_3 2\\n#define LEFT_ARM_1 10\\n#define LEFT_ARM_2 11\\n#define LEFT_ARM_3 12\\n#define RIGHT_ARM_1 7\\n#define RIGHT_ARM_2 6\\n#define RIGHT_ARM_3 8\\n#define SPINE 13\\n#define HEAD 9\\n\\n// render functions\\n\\n#define MAT_TABLE    1.\\n#define MAT_PENCIL_0 2.\\n#define MAT_PENCIL_1 3.\\n#define MAT_PENCIL_2 4.\\n#define MAT_PAPER    5.\\n#define MAT_METAL_0  6.\\n\\n#define PENCIL_POS vec3(-0.8,-0.2, -2.3)\\n#define PENCIL_ROT .95\\n#define PAPER_SIZE (vec2(1.95, 2.75)*1.1)\\n\\n// http://www.johndcook.com/blog/2010/01/20/how-to-compute-the-soft-maximum/\\nfloat smin(in float a, in float b, const in float k) { return a - log(1.0+exp(k*(a-b))) * (1. / k); }\\n\\nfloat opS( const float d1, const float d2 ) {\\n    return max(-d1,d2);\\n}\\n\\nvec2 rotate( in vec2 p, const float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    return mat2(co,-si,si,co) * p;\\n}\\n\\nfloat sdSphere( const vec3 p, const vec4 s ) {\\n    return distance(p,s.xyz)-s.w;\\n}\\n\\nfloat sdBox( vec3 p, vec3 b ) {\\n    vec3 d = abs(p) - b;\\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdCapsule(vec3 p,vec3 o,vec3 e,const float r0,const float r1) {\\n    vec3 d = e-o;\\n    float h = length(d);\\n    d *= (1./h);\\n    float t=clamp(dot(p-o,d),0.,h);\\n\\tvec3 np=o+t*d;\\n\\treturn distance(np,p)-mix(r0,r1,t);\\n}\\n\\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdHexPrism( const vec3 p, const vec2 h ) {\\n    vec3 q = abs(p);\\n#if 0\\n    return max(q.x-h.y,max((q.z*0.866025+q.y*0.5),q.y)-h.x);\\n#else\\n    float d1 = q.x-h.y;\\n    float d2 = max((q.z*0.866025+q.y*0.5),q.y)-h.x;\\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\\n#endif\\n}\\n\\nfloat sdCapsule( const vec3 p, const vec3 a, const vec3 b, const float r ) {\\n\\tvec3 pa = p-a, ba = b-a;\\n\\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\\n\\treturn length( pa - ba*h ) - r;\\n}\\n\\nfloat sdSphere( const vec3 p, const float r ) {\\n    return length(p) - r;\\n}\\n\\nfloat sdCone( const vec3 p, const vec2 c ) {\\n    float q = length(p.yz);\\n    return dot(c,vec2(q,p.x));\\n}\\n\\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float r ) {\\n\\tvec3 oc = ro;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - r * r;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return vec2(-1.0);\\n    h = sqrt( h );\\n\\treturn vec2(-b - h, -b + h);\\n}\\n\\nvec2 boxIntersect( in vec3 ro, in vec3 rd, in vec3 rad ) {\\n    vec3 m = 1.0/rd;\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*rad;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n\\tif( tN > tF || tF < 0.0) return vec2(-1);\\n\\n\\treturn vec2(tN, tF);\\n}\\n\\nfloat planeIntersect( const vec3 ro, const vec3 rd, const float height) {\\t\\n\\tif (rd.y==0.0) return 500.;\\t\\n\\tfloat d = -(ro.y - height)/rd.y;\\n\\tif( d > 0. ) {\\n\\t\\treturn d;\\n\\t}\\n\\treturn 500.;\\n}\\n\\n//\\n// Material properties.\\n//\\n\\nvec4 texNoise( sampler2D sam, in vec3 p, in vec3 n ) {\\n\\tvec4 x = texture( sam, p.yz );\\n\\tvec4 y = texture( sam, p.zx );\\n\\tvec4 z = texture( sam, p.xy );\\n\\n\\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\\n}\\n\\n\\n\\n\\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// [SH18] Human Document. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XtcyW4\\n//\\n//   * Created for the Shadertoy Competition 2018 *\\n// \\n// Buffer A: I have preprocessed a (motion captured) animation by taking the Fourier \\n//           transform of the position of all bones (14 bones, 760 frames). Only a fraction \\n//           of all calculated coefficients are stored in this shader: the first \\n//           coefficients with 16 bit precision, later coefficients with 8 bit. The positions\\n//           of the bones are reconstructed each frame by taking the inverse Fourier\\n//           transform of this data.\\n//\\n//           I have used (part of) an animation from the Carnegie Mellon University Motion \\n//           Capture Database. The animations of this database are free to use:\\n//\\n//           - http://mocap.cs.cmu.edu/\\n// \\n//           igo Qulez has created some excellent shaders that show the properties of \\n//           Fourier transforms, for example: \\n//\\n//           - https://www.shadertoy.com/view/4lGSDw\\n//           - https://www.shadertoy.com/view/ltKSWD\\n//\\n\\n\\n#define HQ 10\\n#define LQ 13\\n\\nvec2 cmul(vec2 a, vec2 b) { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }\\n#define S(q,s,c) (float((q >> s) & 0xFFU)*c.x-c.y)\\n#define SH(q,s,c) (float((q >> s) & 0xFFFFU)*c.x-c.y)\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    if(int(fragCoord.x) > 0 || int(fragCoord.y) > NUM_BONES) {      \\n        return;\\n    }\\n    \\n    initAnimation(iTime);\\n    \\n\\tint y = int(fragCoord.y);  \\n    float s1 = (6.28318530718/FRAMES)*frame;\\n    vec2 pos = vec2(0);\\n    vec2 posy = vec2(0);\\n    \\n    uint[HQ] hqd;\\n    uint[LQ] lqd;\\n\\n    uint[HQ] hqyd;\\n    uint[LQ] lqyd;\\n    \\n    uint[HQ] hqdB;\\n    uint[LQ] lqdB;\\n    \\n    uint[HQ] hqydB;\\n    uint[LQ] lqydB;\\n\\n    // scale \\n    const vec3 scale = vec3(0.012353025376796722, 0.011576368473470211, 0.025544768199324608); \\n\\n    // scale, offset - first coeffs \\n    const vec2 ch = vec2(0.014635691419243813, 636.2047119140625); \\n    const vec2 cl = vec2(0.39385828375816345, 42.45376205444336); \\n\\n    // scale, offset - last coeffs \\n    const vec2 chb = vec2(0.003957926761358976, 118.40463256835938);\\n    const vec2 clb = vec2(0.520740270614624, 58.412567138671875);\\n\\n\\n    if (y==0) { hqd = uint[10] (0x7f2d8b92U,0xc4f2beaeU,0xbbeaad0eU,0xd070a2e9U,0xb266a557U,0xb19fa162U,0xad6ca7edU,0xb0f7ac1fU,0xb104ac21U,0xb2439bbfU); lqd = uint[13] (0x928a893cU,0x537c793cU,0x6792965bU,0x6466c17aU,0x7748a244U,0x9f628b6bU,0x995b7167U,0x825a6c62U,0x727c6767U,0x84687269U,0x7d709262U,0x74638d50U,0x7b697e68U);}\\n    if (y==0 || y==1) { hqyd = uint[10] (0x45960000U,0xb649b0efU,0xb91aa98aU,0xafbaa34dU,0xa830a08fU,0xac65a40cU,0xaa63a1d7U,0xa37ca7edU,0xac25a239U,0xaf63ad31U); lqyd = uint[13] (0x1505b2cU,0xac01194U,0xbaae51f4U,0xbe3a7385U,0x953f9568U,0x58757b42U,0x807b6578U,0x26549d61U,0x4e5b634dU,0x646d4f74U,0x7f86567aU,0x9670756fU,0x6770546dU);}\\n    if (y==1) { hqd = uint[10] (0x6f4585cbU,0xc4a3bce4U,0xb9f2b155U,0xcbc89e17U,0xacdba615U,0xabb69dd9U,0xb168ab59U,0xac9ea649U,0xb314a969U,0xafe2a327U); lqd = uint[13] (0x9e7c8c46U,0x7d645c57U,0x6f636f51U,0x765d9b5cU,0x8e566451U,0x78638e62U,0x705e7169U,0x76697177U,0x7a637c68U,0x7f607767U,0x78607353U,0x736b6f71U,0x7d637f69U);}\\n    if (y==2) { hqd = uint[10] (0x813a9626U,0xc801c2d1U,0xbf42abe8U,0xcd90a65fU,0xb0e1a15eU,0xaeba9cecU,0xab0fa953U,0xb28fa809U,0xafd4a45bU,0xb0b8a7dbU); lqd = uint[13] (0x90588c2bU,0x6b696944U,0x7c6e7a51U,0x675d995dU,0x7e667b54U,0x6c5e8266U,0x78587967U,0x74607b6fU,0x845c7f68U,0x7d5b7964U,0x775e685cU,0x77676d67U,0x7764706aU);}\\n    if (y==2 || y==3) { hqyd = uint[10] (0x4838601U,0xaf02a4f0U,0xaba0a4e7U,0xa16a9a56U,0xa0379c04U,0xa68ba99aU,0xa63aab86U,0xa4aca392U,0xa689ab22U,0xa152ac96U); lqyd = uint[13] (0x2150385cU,0x73ff21e2U,0xdaa1b4a2U,0x9e28de0cU,0x37763c06U,0x4e452891U,0x698a7850U,0x2ca4724dU,0x7f9c507cU,0xa15d8184U,0x73599e63U,0x565b504aU,0x5d68695cU);}\\n    if (y==3) { hqd = uint[10] (0x819db6f2U,0xc5abcc7eU,0xc384a773U,0xc844aa35U,0xb0709d74U,0xa6009fbbU,0xaf9aa9b4U,0xa9f3a8b2U,0xb3a09bf7U,0xafc3ae57U); lqd = uint[13] (0x65464a2bU,0x645c6a55U,0x6e5a8865U,0x5f5db08bU,0x75618131U,0x894c4847U,0x7c577b73U,0x5876615fU,0x6e614d46U,0x92916657U,0x8c6e5a79U,0x785f5d5aU,0x61657e4cU);}\\n    if (y==4) { hqd = uint[10] (0x7057b74bU,0xc6e5c8f3U,0xc22aab06U,0xc861a366U,0xb0759fd9U,0xa4229de0U,0xb5c7aa1cU,0xa44ba815U,0xb622a03cU,0xad9da952U); lqd = uint[13] (0x7d51642dU,0x77575d78U,0x844c8977U,0x71468a6aU,0x73566a49U,0x7c6c6c59U,0x69767452U,0x6967665eU,0x64526d67U,0x6767846aU,0x636d786aU,0x74677e65U,0x74617163U);}\\n    if (y==4 || y==5) { hqyd = uint[10] (0x88cd4a5aU,0xb2b7b0e6U,0xb9dbb24eU,0xad0fa4fbU,0xa6ffa074U,0xaca2a79aU,0xa64ea955U,0xa11aac9cU,0xa83dacd4U,0xb306a50dU); lqyd = uint[13] (0xa5a374cU,0x45dc1c98U,0xafb77cb9U,0x8c57db72U,0x81576b48U,0x616a7758U,0x75666467U,0x584e7b6fU,0x69526b59U,0x5a7b4e75U,0x74806075U,0x6f676d7eU,0x66677b6cU);}\\n    if (y==5) { hqd = uint[10] (0x7fe7b48aU,0xc7f3c61dU,0xc09ba88dU,0xca11a71dU,0xb12fa099U,0xab6da034U,0xad91a571U,0xae72ac1cU,0xb16fa17fU,0xad92a90bU); lqd = uint[13] (0x8454932aU,0x625d7559U,0x7b5b8d64U,0x644e9769U,0x735e765fU,0x6e5a7f6eU,0x775b7465U,0x7263776cU,0x7f637f69U,0x78607e63U,0x70616e57U,0x726a6f66U,0x7566706aU);}\\n    if (y==6) { hqd = uint[10] (0x797e765dU,0xc9f7c05aU,0xbe9db1b6U,0xd26fa3bcU,0xaad3a0dcU,0xb02297ceU,0xaaa6b166U,0xae69a0b9U,0xaec4a95fU,0xb373a6efU); lqd = uint[13] (0x9a3f535fU,0x82676760U,0x6d7d6f40U,0x6b846236U,0x726b9d59U,0x6252786aU,0x716d7f75U,0x7c797d63U,0x7a667b66U,0x6f647c51U,0x76677467U,0x6f687461U,0x746a735fU);}\\n    if (y==6 || y==7) { hqyd = uint[10] (0x9ddebb01U,0x9494a957U,0xa223bdd6U,0x9412bad1U,0xa162aebcU,0xc209b52bU,0xb339a79dU,0x9acfa754U,0xa47aaeceU,0xbccab927U); lqyd = uint[13] (0xd876bb65U,0x670ec504U,0x2b333400U,0x2a756964U,0x849f2a9aU,0x6241be66U,0x5583345cU,0x63326785U,0x5d78555eU,0x7aa84298U,0x886ba57dU,0x635b7a4eU,0x6871646eU);}\\n    if (y==7) { hqd = uint[10] (0x707c816cU,0xc8a2bd56U,0xb894b447U,0xd02e9e32U,0xabe4a20bU,0xad239781U,0xb11aaef1U,0xa637a0c8U,0xb385a979U,0xb4a8a648U); lqd = uint[13] (0x812a6680U,0x9888687aU,0x7263a24fU,0x63886354U,0x7971aa4aU,0x76387a75U,0x76688f7aU,0x6b8d7264U,0x7c638455U,0x8c74784dU,0x88746f6cU,0x7a69785bU,0x7a706b54U);}\\n    if (y==8) { hqd = uint[10] (0x786185abU,0xccd4c4f2U,0xc299b1a7U,0xd1bda151U,0xacdf9d39U,0xaf0b9a6eU,0xad3caec2U,0xadf1a0ccU,0xb039a7c0U,0xb536a45cU); lqd = uint[13] (0x8f47594aU,0x80576b5cU,0x76696550U,0x85636754U,0x795f8161U,0x71687458U,0x6a72745fU,0x75617e59U,0x76647e67U,0x64627f5bU,0x6c647a61U,0x6e65735fU,0x6b627863U);}\\n    if (y==8 || y==9) { hqyd = uint[10] (0xffffe30eU,0x8aa3afebU,0x9ac1c8c4U,0x99f2c288U,0xab85b26dU,0xba8eb5d5U,0xadcbae25U,0x9a80a928U,0xa56ab508U,0xbc84b8dcU); lqyd = uint[13] (0xae54b088U,0x752dc82aU,0x27564815U,0x4c7c5e81U,0x85895a8dU,0x5d588573U,0x70755469U,0x595b6a79U,0x7f6a7481U,0x6f6d7173U,0x67687862U,0x666c5f6bU,0x62697471U);}\\n    if (y==9) { hqd = uint[10] (0x6de79f16U,0xcf64c883U,0xc5c3b1fcU,0xcd459d56U,0xab069cd0U,0xaa239e3eU,0xb50cac41U,0xa4f5a0bcU,0xb25ea61fU,0xb427a28eU); lqd = uint[13] (0x7651566aU,0x8c557a75U,0x855a685fU,0x8f555769U,0x7d587361U,0x84686b50U,0x6c7d6c61U,0x7367745aU,0x70688060U,0x6d6e7d55U,0x706a785fU,0x6b64735eU,0x6d677b61U);}\\n    if (y==10) { hqd = uint[10] (0x6d23bfd6U,0xd03ec43eU,0xcdc8ad1eU,0xc2ef9dffU,0xaac8a3f1U,0xa63fa2a7U,0xb9e0a3daU,0x9dd2a9d2U,0xb0f1a249U,0xab98a746U); lqd = uint[13] (0x2c5aa46bU,0x768b8969U,0xcd66826fU,0x73586b52U,0x80a36844U,0x775b7f52U,0x6f618e72U,0x9f5e8172U,0x86545463U,0x7f5e6858U,0x846d5d78U,0x85637471U,0x805e6c5cU);}\\n    if (y==10 || y==11) { hqyd = uint[10] (0xc58eb64bU,0x8e4ca00aU,0x9b52b3b3U,0x9b6fb009U,0xac4bb06bU,0xb4f1b9abU,0xae25aa6dU,0x9eb5a6e5U,0xa7f2b1a6U,0xa99cbbe2U); lqyd = uint[13] (0xc75fc2d3U,0xa51bdd72U,0x6a209613U,0x21596f19U,0x55ac2689U,0xa34aa596U,0x66522a5eU,0xa52b4393U,0x5b499654U,0x299c2b50U,0x788a6991U,0x775b8582U,0x64716960U);}\\n    if (y==11) { hqd = uint[10] (0x77dcd005U,0xcc81c841U,0xcb2da829U,0xc4b6a5b9U,0xaf569dcaU,0xaa0aa4ceU,0xb38fa1edU,0xa494af97U,0xb1a5a091U,0xadb6a755U); lqd = uint[13] (0x3c74a346U,0x8a729868U,0xab5f956bU,0x7f498158U,0x747f745fU,0x8058715eU,0x72568062U,0x936a836bU,0x82616961U,0x7b546d58U,0x7c606b6aU,0x8263716cU,0x79606958U);}\\n    if (y==12) { hqd = uint[10] (0x786cc344U,0xcd32cb3fU,0xc7edab4cU,0xca48a2fcU,0xaec49c6cU,0xaad2a2daU,0xb1d2a555U,0xa6fdab44U,0xb231a20fU,0xb0aca64aU); lqd = uint[13] (0x635c7d45U,0x805a8a68U,0x89508165U,0x804e786aU,0x6f5c6f6dU,0x805e6964U,0x776c6d5fU,0x7e687860U,0x7b6d7f67U,0x78627558U,0x73636f60U,0x71656f64U,0x7165755fU);}\\n    if (y==12 || y==13) { hqyd = uint[10] (0xda14e8ccU,0x92d8a694U,0x9c9cbe57U,0x9be6b744U,0xa953af96U,0xb301b328U,0xabf7ab5fU,0x9bb4a744U,0xa507b50aU,0xb300b446U); lqyd = uint[13] (0x934d939aU,0x85578f73U,0x695a6241U,0x4c647e64U,0x7f8f3e7bU,0x6b627d7aU,0x6e71515fU,0x6d5e6c7bU,0x885c7d7aU,0x58656a61U,0x5d766363U,0x70715e7bU,0x60657d6fU);}\\n    if (y==13) { hqd = uint[10] (0x7a6fa42aU,0xcbc2c779U,0xc430ad87U,0xcd35a2ebU,0xae879dadU,0xad4b9f22U,0xaee0a953U,0xabdca6b5U,0xb0f2a473U,0xb243a62aU); lqd = uint[13] (0x7f527640U,0x7b577b5bU,0x7e5b7358U,0x7d58745fU,0x735f7767U,0x75617362U,0x736b7060U,0x7a607c61U,0x79668068U,0x715f7b5cU,0x7061725fU,0x70667062U,0x70627664U);}\\n\\n\\n    if (y==0) { hqdB = uint[10] (0xe21c2f6cU, 0xcb15b85bU, 0x82ac80dbU, 0x84cdc8ffU, 0x4e019d8dU, 0x5248950eU, 0x5fe371bcU, 0x54dd8336U, 0x76639b92U, 0x73ec992eU); lqdB = uint[13] (0x4e9360b6U, 0x428c5087U, 0x64494d75U, 0x4f7d6c6dU, 0x62907478U, 0x7d855a7fU, 0x76845c70U, 0x72847583U, 0x5d8d6986U, 0x5180527dU, 0x5c6c6074U, 0x61767378U, 0x697a647cU);}\\n    if (y==0 || y==1) { hqydB = uint[10] (0x6546a12eU, 0x54dd93fcU, 0x466e7ab9U, 0x55946828U, 0x67a35c96U, 0x6a6c5743U, 0x6d876a60U, 0x5a9e61f3U, 0x6857718cU, 0x5c81503dU); lqydB = uint[13] (0xb93d7f38U, 0xc1b8dd63U, 0x80b58db8U, 0x407f2a84U, 0x5d534354U, 0x62706571U, 0x4a696289U, 0x6d537247U, 0x87649163U, 0x777f7c6cU, 0x5b696277U, 0x88695c6fU, 0x756e696aU);}\\n    if (y==1) { hqdB = uint[10] (0xdcf8220dU, 0xecc6cbddU, 0x82ac7569U, 0x8dbdd346U, 0x66a98e0bU, 0x4c3f8cc0U, 0x63777618U, 0x5e0e6fd8U, 0x78309a7dU, 0x6c3f8e24U); lqdB = uint[13] (0x647c41acU, 0x57765776U, 0x8f7b7a6cU, 0x5d846c79U, 0x637b6a76U, 0x6a87697cU, 0x707d647dU, 0x6e7b728fU, 0x6e7e6c7cU, 0x627b6577U, 0x6d7a5f78U, 0x63796b78U, 0x6b7c677bU);}\\n    if (y==2) { hqdB = uint[10] (0xd64634daU, 0xbc8ebdacU, 0x77979c0cU, 0x7e3fc25dU, 0x5a7a817fU, 0x5de396eaU, 0x5b2b8102U, 0x609b758eU, 0x6f3e8e74U, 0x6fc68268U); lqdB = uint[13] (0x60865b97U, 0x5a804f85U, 0x607a637dU, 0x5e7a6979U, 0x6b7f647aU, 0x617e6774U, 0x65745f74U, 0x6f716d67U, 0x787f7375U, 0x69816d80U, 0x637a617aU, 0x6e736672U, 0x6d766a75U);}\\n    if (y==2 || y==3) { hqydB = uint[10] (0x98968b51U, 0x980fc32cU, 0x5e4a9a87U, 0x444e89d2U, 0x623f8d16U, 0x721464daU, 0x8076588eU, 0x889173a0U, 0x4daf9a2aU, 0x59886316U); lqydB = uint[13] (0x8613432cU, 0xc260cc23U, 0x94ffc189U, 0x57937a90U, 0x3d72528aU, 0x85745777U, 0x7c98616bU, 0x44773638U, 0x79444851U, 0x9b58a256U, 0x7987967bU, 0x678c6a88U, 0x70616869U);}\\n    if (y==3) { hqdB = uint[10] (0xdcc13d0dU, 0xcacd9445U, 0x71aab82fU, 0x8208ca49U, 0x62037a7cU, 0x51ada2d7U, 0x5e548418U, 0x619f638eU, 0x77919dd4U, 0x79407ee0U); lqdB = uint[13] (0x487236b7U, 0x515d254eU, 0x4c846f3bU, 0x9658a077U, 0x7775678aU, 0x54904955U, 0x77868677U, 0x6f75796bU, 0x606e4f76U, 0x6f70586dU, 0x716a7761U, 0x73687d6fU, 0x6e757178U);}\\n    if (y==4) { hqdB = uint[10] (0xce06441eU, 0xec54ad8fU, 0x63909693U, 0x87a2be3bU, 0x6b877b00U, 0x3f1a984bU, 0x69387c8cU, 0x59756896U, 0x80189390U, 0x70cc7fb0U); lqdB = uint[13] (0x54793798U, 0x5a5f494dU, 0x7c7c864dU, 0x737b8a7dU, 0x6f80787dU, 0x60705b6fU, 0x77777a94U, 0x6d7a707cU, 0x69746c6dU, 0x62776e73U, 0x6d72727bU, 0x74716d74U, 0x6e7c6e73U);}\\n    if (y==4 || y==5) { hqydB = uint[10] (0x5b8386e7U, 0x76897e06U, 0x50de6100U, 0x5ae0634aU, 0x79736ee5U, 0x775566d9U, 0x5e1d6035U, 0x7fdb6206U, 0x7cb3671dU, 0x74826a90U); lqydB = uint[13] (0xb7336153U, 0x9490b86fU, 0x60b983b9U, 0x3e483d7bU, 0x7f5e775dU, 0x64686971U, 0x72687b75U, 0x80787658U, 0x6f817c8fU, 0x56755b78U, 0x6f61655eU, 0x7676765fU, 0x6c696f6aU);}\\n    if (y==5) { hqdB = uint[10] (0xd9254951U, 0xc9bdab08U, 0x71b8a56fU, 0x7edfbc56U, 0x5d2383acU, 0x531c9957U, 0x622d8062U, 0x5b8b7440U, 0x6ec2925bU, 0x6c9c81abU); lqdB = uint[13] (0x51825b97U, 0x577d526eU, 0x68766a6cU, 0x5f7f6f79U, 0x68836776U, 0x637a6d72U, 0x66716476U, 0x6b706f6aU, 0x757a7375U, 0x687e7081U, 0x6578657dU, 0x6c736771U, 0x6c756a74U);}\\n    if (y==6) { hqdB = uint[10] (0xca6b28fdU, 0xb3f3e380U, 0x5e268261U, 0x7d6ac7fbU, 0x5b256665U, 0x647084b1U, 0x5aca7efbU, 0x566b6f80U, 0x79807681U, 0x6bef74a6U); lqdB = uint[13] (0x968c7777U, 0x819a6e97U, 0x3d7b659dU, 0x67685c91U, 0x7182615eU, 0x5287796eU, 0x5d7a7385U, 0x657b6882U, 0x616c627cU, 0x666d6472U, 0x6d756f6cU, 0x6b727079U, 0x6c756475U);}\\n    if (y==6 || y==7) { hqydB = uint[10] (0x78e823f5U, 0xcb574bf4U, 0x9df829c2U, 0x7ea36d07U, 0xb9cabeb4U, 0x8c5ba051U, 0x61ca36beU, 0x95b3623fU, 0xa5ffb714U, 0x8dc78f7aU); lqydB = uint[13] (0x3eba8198U, 0x674fa5U, 0x63824f68U, 0x7f435f34U, 0x86a09b7fU, 0x5c4d567eU, 0x916f5a5aU, 0x5f874278U, 0x704a6559U, 0x907d9a55U, 0x65877f82U, 0x686f6b70U, 0x78747163U);}\\n    if (y==7) { hqdB = uint[10] (0xd0f0389cU, 0xc476ffffU, 0x503a811dU, 0x8635c0a0U, 0x515f5d9dU, 0x4b9d7a68U, 0x65e99171U, 0x41a670f6U, 0x6f0f6693U, 0x6f227946U); lqdB = uint[13] (0x9a937586U, 0x789f6b98U, 0x45a06e8eU, 0x68554e97U, 0x72975158U, 0x46947668U, 0x64797b84U, 0x5f7e7b8eU, 0x5172537bU, 0x636e4a76U, 0x736d7069U, 0x6874747eU, 0x6d715e77U);}\\n    if (y==8) { hqdB = uint[10] (0xcdab3b0fU, 0xb0e9e0cbU, 0x5d967edeU, 0x7b2fbe56U, 0x5af771e0U, 0x5db1872aU, 0x63157226U, 0x59d0764fU, 0x6aae7b15U, 0x70a07044U); lqdB = uint[13] (0x8e848362U, 0x74a27aa0U, 0x458458a0U, 0x646e547aU, 0x6e756a6fU, 0x6078717bU, 0x6076697eU, 0x6a75607aU, 0x696c6f71U, 0x6c787571U, 0x6b756b79U, 0x68726a7aU, 0x71767170U);}\\n    if (y==8 || y==9) { hqydB = uint[10] (0x6f010000U, 0xced82a4cU, 0xbe5a2044U, 0x99176edaU, 0xa2b9a673U, 0x80ef7e7cU, 0x689b382fU, 0x9b015de0U, 0xa7e8ae68U, 0x8462822fU); lqydB = uint[13] (0x58aa6d94U, 0x2e5c5091U, 0x6c6c524fU, 0x8e4f7b4cU, 0x6e818888U, 0x705a6465U, 0x7c797672U, 0x76745e68U, 0x756b697aU, 0x7075746cU, 0x6d686f71U, 0x73766e70U, 0x6f6b6968U);}\\n    if (y==9) { hqdB = uint[10] (0xd13b5941U, 0xc2a8eb07U, 0x54027d5bU, 0x7d97ba2fU, 0x5b9c76b6U, 0x445e82dbU, 0x72af634dU, 0x576f75f2U, 0x5eed7cf5U, 0x722e734eU); lqdB = uint[13] (0x86778f56U, 0x7ea68b95U, 0x5791559eU, 0x61684d74U, 0x716e6a6eU, 0x6d7f6a7dU, 0x6b786c7eU, 0x68756582U, 0x616c6a72U, 0x6f776b72U, 0x6f706b79U, 0x67747077U, 0x70747273U);}\\n    if (y==10) { hqdB = uint[10] (0xc1698c0bU, 0xcee6dcf5U, 0x404796ddU, 0x7729a2e4U, 0x6dcb8a98U, 0x37c18ed1U, 0x722c611fU, 0x5a5a7130U, 0x5f637d59U, 0x74488186U); lqdB = uint[13] (0x73639361U, 0x9d8a9590U, 0x5b9c62abU, 0x61625384U, 0x766d648aU, 0x7893617dU, 0x6b8b6f76U, 0x72895d64U, 0x5b846d88U, 0x676a5186U, 0x72756564U, 0x6b737179U, 0x72766077U);}\\n    if (y==10 || y==11) { hqydB = uint[10] (0x67661516U, 0xbe6c2d80U, 0x912c3a36U, 0x805b74e8U, 0xa63a9d88U, 0x6ffe8b06U, 0x52834533U, 0x9d7666f6U, 0xacfd8459U, 0xa25ca36dU); lqydB = uint[13] (0x689a31ccU, 0x10582c87U, 0x42515167U, 0x893f772cU, 0x7e9ab670U, 0x7547458aU, 0x9775764dU, 0x626c3a81U, 0x7d506d5aU, 0x83809f62U, 0x6782857eU, 0x70716970U, 0x7374766cU);}\\n    if (y==11) { hqdB = uint[10] (0xdc8676d5U, 0xc979b6c9U, 0x59229fb7U, 0x66a2a433U, 0x604083bcU, 0x48138e95U, 0x663c6e72U, 0x5be26d01U, 0x5fb18baaU, 0x67bb72a2U); lqdB = uint[13] (0x666f9861U, 0x828c8680U, 0x67875ba2U, 0x5c6a4e85U, 0x75696d8cU, 0x7f855e83U, 0x65826971U, 0x65765966U, 0x6a7a6985U, 0x6e6f6586U, 0x6a74686aU, 0x74726971U, 0x6e736777U);}\\n    if (y==12) { hqdB = uint[10] (0xdb39683aU, 0xc027c3c0U, 0x572d921aU, 0x7407ae55U, 0x5af47e28U, 0x4c4c8c83U, 0x69c56ebdU, 0x59cb72f2U, 0x60a78b90U, 0x6fc76f04U); lqdB = uint[13] (0x6d768a5fU, 0x75987f81U, 0x61815991U, 0x5e75557cU, 0x6e757078U, 0x79796b81U, 0x66746377U, 0x65735f77U, 0x6d726b77U, 0x72796d7bU, 0x6b726777U, 0x6a746b73U, 0x6f747074U);}\\n    if (y==12 || y==13) { hqydB = uint[10] (0x7be41564U, 0xcdff469dU, 0xaa7d4594U, 0x840175e5U, 0x994c9f4cU, 0x76d57938U, 0x6e8e404eU, 0x98496b63U, 0xa8e69a38U, 0x7c728fceU); lqydB = uint[13] (0x6897478bU, 0x485b536eU, 0x7476635dU, 0x7f53725aU, 0x7b7f8a82U, 0x6d585e6fU, 0x7d6f7a72U, 0x7b7f6164U, 0x6a706c8aU, 0x656f6c6bU, 0x74657367U, 0x7379736dU, 0x6b6b6e6aU);}\\n    if (y==13) { hqdB = uint[10] (0xd6a64e47U, 0xba4cce43U, 0x61188e48U, 0x790fb85bU, 0x5a347c04U, 0x56098e06U, 0x65667411U, 0x5b6d760fU, 0x65e28647U, 0x6f6c72c9U); lqdB = uint[13] (0x747c7c6bU, 0x7297748bU, 0x57825c93U, 0x5f75567bU, 0x6c796c74U, 0x6a786e7dU, 0x61736379U, 0x69726073U, 0x70727172U, 0x6f7d7379U, 0x6974667aU, 0x6a736975U, 0x70757171U);}\\n\\n    // first coeffs\\n    float w1 = 0.;\\n    \\n    for( int i=0; i<HQ; i++) {\\n        uint q = hqd[i];\\n    \\tpos+=cmul(vec2(SH(q,0,ch),SH(q,16,ch)),vec2(cos(w1),sin(w1)));w1+=s1; \\n    }\\n    for( int i=0; i<LQ; i++) {\\n        uint q = lqd[i];\\n    \\tpos+=cmul(vec2(S(q,0,cl),S(q,8,cl)),vec2(cos(w1),sin(w1)));w1+=s1; \\n        pos+=cmul(vec2(S(q,16,cl),S(q,24,cl)),vec2(cos(w1),sin(w1)));w1+=s1; \\n    }  \\n    \\n    // and y\\n    w1 = 0.;\\n    for( int i=0; i<HQ; i++) {\\n        uint q = hqyd[i];\\n        posy+=cmul(vec2(SH(q,0,ch),SH(q,16,ch)),vec2(cos(w1),sin(w1)));w1+=s1; \\n    }\\n    for( int i=0; i<LQ; i++) {\\n        uint q = lqyd[i];\\n        posy+=cmul(vec2(S(q,0,cl),S(q,8,cl)),vec2(cos(w1),sin(w1)));w1+=s1; \\n        posy+=cmul(vec2(S(q,16,cl),S(q,24,cl)),vec2(cos(w1),sin(w1)));w1+=s1; \\n    }  \\n    \\n    // last coeffs\\n    float w2 = (FRAMES-1.)*s1;\\n    \\n    for( int i=0; i<HQ; i++) {\\n        uint q = hqdB[i];\\n        pos+=cmul(vec2(SH(q,0,chb),SH(q,16,chb)),vec2(cos(w2),sin(w2)));w2-=s1; \\n    }\\n    for( int i=0; i<LQ; i++) {\\n        uint q = lqdB[i];\\n        pos+=cmul(vec2(S(q,0,clb),S(q,8,clb)),vec2(cos(w2),sin(w2)));w2-=s1; \\n        pos+=cmul(vec2(S(q,16,clb),S(q,24,clb)),vec2(cos(w2),sin(w2)));w2-=s1; \\n    }  \\n    \\n    // and y\\n    w2 = (FRAMES-1.)*s1;\\n    for( int i=0; i<HQ; i++) {\\n        uint q = hqydB[i];\\n        posy+=cmul(vec2(SH(q,0,chb),SH(q,16,chb)),vec2(cos(w2),sin(w2)));w2-=s1; \\n    }\\n    for( int i=0; i<LQ; i++) {\\n        uint q = lqydB[i];\\n        posy+=cmul(vec2(S(q,0,clb),S(q,8,clb)),vec2(cos(w2),sin(w2)));w2-=s1; \\n        posy+=cmul(vec2(S(q,16,clb),S(q,24,clb)),vec2(cos(w2),sin(w2)));w2-=s1; \\n    }  \\n    \\n    float py = (int(fragCoord.y) & 0x1) == 0 ?  posy.x : posy.y;\\n    vec3 p = vec3(pos.x, py, pos.y);\\n    \\n    if(iFrame == 0) {\\n        fragColor = vec4(p * scale,1.0);\\n    } else {\\t    \\n    \\tfragColor = mix(vec4(p * scale,1.0), texelFetch(iChannel0, ivec2(fragCoord),0),.75);\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// [SH18] Human Document. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XtcyW4\\n//\\n//   * Created for the Shadertoy Competition 2018 *\\n//\\n// Buffer B: The BRDF integration map used for the IBL and the drawing of the humanoid \\n//           are precalculated.\\n//\\n\\nconst float PI = 3.14159265359;\\n\\n// see: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\\nfloat PartialGeometryGGX(float NdotV, float a) {\\n    float k = a / 2.0;\\n\\n    float nominator   = NdotV;\\n    float denominator = NdotV * (1.0 - k) + k;\\n\\n    return nominator / denominator;\\n}\\n\\nfloat GeometryGGX_Smith(float NdotV, float NdotL, float roughness) {\\n    float a = roughness*roughness;\\n    float G1 = PartialGeometryGGX(NdotV, a);\\n    float G2 = PartialGeometryGGX(NdotL, a);\\n    return G1 * G2;\\n}\\n\\nfloat RadicalInverse_VdC(uint bits) {\\n    bits = (bits << 16u) | (bits >> 16u);\\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\\n}\\n\\nvec2 Hammersley(int i, int N) {\\n    return vec2(float(i)/float(N), RadicalInverse_VdC(uint(i)));\\n} \\n\\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness) {\\n    float a = roughness*roughness;\\n    float phi      = 2.0 * PI * Xi.x;\\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\\n\\n    vec3 HTangent;\\n    HTangent.x = sinTheta*cos(phi);\\n    HTangent.y = sinTheta*sin(phi);\\n    HTangent.z = cosTheta;\\n\\n    return HTangent;\\n}\\n\\nvec2 IntegrateBRDF(float roughness, float NdotV) {\\n    vec3 V;\\n    V.x = sqrt(1.0 - NdotV*NdotV);\\n    V.y = 0.0;\\n    V.z = NdotV;\\n\\n    float A = 0.0;\\n    float B = 0.0;\\n\\n    const int SAMPLE_COUNT = 128;\\n\\n    vec3 N = vec3(0.0, 0.0, 1.0);\\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\\n    vec3 TangentX = normalize(cross(UpVector, N));\\n    vec3 TangentY = cross(N, TangentX);\\n\\n    for(int i = 0; i < SAMPLE_COUNT; ++i)  {\\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\\n        vec3 HTangent = ImportanceSampleGGX(Xi, roughness);\\n        \\n        vec3 H = normalize(HTangent.x * TangentX + HTangent.y * TangentY + HTangent.z * N);\\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\\n\\n        float NdotL = max(L.z, 0.0);\\n        float NdotH = max(H.z, 0.0);\\n        float VdotH = max(dot(V, H), 0.0);\\n\\n        if(NdotL > 0.0) {\\n            float G = GeometryGGX_Smith(NdotV, NdotL, roughness);\\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\\n            float Fc = pow(1.0 - VdotH, 5.0);\\n\\n            A += (1.0 - Fc) * G_Vis;\\n            B += Fc * G_Vis;\\n        }\\n    }\\n    A /= float(SAMPLE_COUNT);\\n    B /= float(SAMPLE_COUNT);\\n    return vec2(A, B);\\n}\\n\\n//\\n// draw paper\\n//\\n\\n\\nvec3 getSpherePosition(int i) {\\n    if (i==LEFT_LEG_1) return vec3(-.15, 0, -1.6);\\n    if (i==RIGHT_LEG_1) return vec3(.5, 0, -1.6);\\n    \\n    if (i==LEFT_LEG_2) return vec3(-.3, 0, -.75);\\n    if (i==RIGHT_LEG_2) return vec3(.3, 0, -.75);\\n    \\n    if (i==LEFT_LEG_3) return vec3(-.12, 0, .15);\\n    if (i==RIGHT_LEG_3) return vec3(.1, 0, .15);\\n        \\n    if (i==HEAD) return vec3(0., 0, 1.65);\\n    if (i==SPINE) return vec3(0., 0, 1.1);\\n    \\n    if (i==LEFT_ARM_3) return vec3(-.3, 0, 1.15);\\n    if (i==RIGHT_ARM_3) return vec3(.3, 0, 1.15);\\n    \\n    if (i==LEFT_ARM_2) return vec3(-.55, 0, .7);\\n    if (i==RIGHT_ARM_2) return vec3(.55, 0, .7);\\n    \\n    if (i==LEFT_ARM_1) return vec3(-.75, 0, 0.2);\\n    if (i==RIGHT_ARM_1) return vec3(.95,0,  0.4);\\n    \\n    return vec3(0);\\n}\\n\\nfloat mapBody( in vec3 pos ) {\\n    float r = .15;\\n    float s = 80.1;\\n\\n    vec3 p1 = getSpherePosition(LEFT_LEG_1);\\n    vec3 p2 = getSpherePosition(LEFT_LEG_2);\\n    float d = sdCapsule(pos, p1, p2, r, r*.5);\\n    vec2 res = vec2(d, MAT_PAPER);\\n\\n    p1 = getSpherePosition(LEFT_LEG_3);\\n    d = sdCapsule(pos, p1, p2, r, r*.5);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_LEG_1);\\n    p2 = getSpherePosition(RIGHT_LEG_2);\\n    d = sdCapsule(pos, p1, p2, r, r*.5);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_LEG_3);\\n    d = sdCapsule(pos, p1, p2, r, r*.5);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_LEG_3);\\n    p2 = getSpherePosition(SPINE);\\n    d = sdCapsule(pos, p1, p2, r, r);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(LEFT_LEG_3);\\n    d = sdCapsule(pos, p1, p2, r, r);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_ARM_1);\\n    p2 = getSpherePosition(RIGHT_ARM_2);\\n    d = sdCapsule(pos, p1, p2, r*.5, r*.25);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(RIGHT_ARM_3);\\n    d = sdCapsule(pos, p1, p2, r*.5, r*.25);\\n    res.x = smin(res.x, d, s);\\n\\n    p1 = getSpherePosition(LEFT_ARM_1);\\n    p2 = getSpherePosition(LEFT_ARM_2);\\n    d = sdCapsule(pos, p1, p2, r*.5, r*.25);\\n    res.x = smin(res.x, d, s); \\n\\n    p1 = getSpherePosition(LEFT_ARM_3);\\n    d = sdCapsule(pos, p1, p2, r*.5, r*.25);\\n    res.x = smin(res.x, d, s);    \\n\\n    return res.x;\\n}\\n\\nvec2 drawPaper(vec2 uv) {\\n    float structure = 1.-texture(iChannel1, uv.yx).x;\\n    vec3 muv = vec3(uv.y-.5, 0., uv.x-.5)*4.;\\n    muv.x *= PAPER_SIZE.x / PAPER_SIZE.y;\\n    muv *= 2.75;\\n    muv.xz += vec2(.5,2.6) + .05*(texture(iChannel1, uv.yx*2.).xz-.5);\\n    muv.y = 0.;\\n    float drawing = smoothstep(.04,.03,abs(mapBody(muv))) * (.25+.75*structure);\\n    \\n    return vec2(structure, 1.-drawing);\\n}\\n\\nbool resolutionChanged() {\\n    return iFrame == 0 \\n        || floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    if(resolutionChanged() && iChannelResolution[1].x > 0.) {\\n        vec2 uv = fragCoord / iResolution.xy;\\n        vec2 integratedBRDF = IntegrateBRDF(uv.y, uv.x);\\n        vec2 paper = drawPaper(uv);\\n        fragColor = vec4(integratedBRDF, paper);\\n        \\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\\n            fragColor.xy = floor(iResolution.xy);\\n        }\\n    } else {\\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\\n    }\\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// [SH18] Human Document. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XtcyW4\\n//\\n//   * Created for the Shadertoy Competition 2018 *\\n//\\n// Buffer C: Additional custom animation of the bones is calculated for the start\\n//           and end of the loop.\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    ivec2 f = ivec2(fragCoord);\\n    \\n    if (f.x > 0 || f.y > NUM_BONES) return;\\n    \\n    initAnimation(iTime);\\n    \\n    vec3 animPos = texelFetch(iChannel0, f, 0).xyz;\\n    animPos.y = max(animPos.y - planeY, 1.);\\n    \\n    vec3 startPos = vec3(animPos.x,-9,animPos.z);\\n    \\n    float t = mod(offsetTime(iTime), DURATION_TOTAL);\\n    vec3 pos = animPos;\\n\\t\\n    if (t < DURATION_START + DURATION_MORPH_ANIM) {\\n        float tm = t-(DURATION_START-DURATION_MORPH_STILL);\\n        if ( tm > 0.) {\\n            pos = mix(startPos, animPos, smoothstep(0.,1., tm / DURATION_MORPH));\\n        } else {\\n            pos = startPos;\\n        }\\n        \\n        if (f.y == HEAD) {\\n            pos.y = max(pos.y, 1.); \\n            \\n            float tf = max(0., (t-DURATION_START*.5))*2.;\\n            float atm = clamp(1.-max(0.,tf/(DURATION_START+DURATION_MORPH_ANIM)), 0., 1.);\\n            float maxf = 50.f * atm*atm*atm*atm;\\n            float freq = min(10.,1.75/(.2+atm*atm));\\n            float h = maxf * abs(cos(freq*tf)); \\n            pos.y += h;\\n        }\\n    } else if (t > DURATION_START + DURATION_ANIM - DURATION_MORPH_ANIM) {\\n        float tm = t-(DURATION_START + DURATION_ANIM - DURATION_MORPH_ANIM);\\n        if ( tm > 0.) {\\n            pos = mix(startPos, animPos, smoothstep(1.,0., tm / DURATION_MORPH));\\n        } else {\\n            pos = startPos;\\n        }\\n        \\n        if (f.y == HEAD) {\\n            pos.y = max(pos.y, 1.); \\n            pos.xz += max(0.,tm) * vec2(3.5,30.);\\n        }\\n    } \\n    \\n    \\n    pos = pos*.11;\\n    pos.z -= .5;\\n    \\n    fragColor = vec4(pos, 1.);\\n}","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4tdcWS","date":"1533861026","viewed":12772,"name":"[SH18] Woman","description":"I wanted to create an organic-looking SDF scene in a single, fully procedural, fragment shader.","likes":208,"published":"Public API","usePreview":1,"tags":["sdf","sh18","woman"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [SH18] Woman. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4tdcWS\\n//\\n// I wanted to create an organic-looking SDF scene in a single, fully procedural,\\n// fragment shader. The scene is modelled for this specific camera viewpoint and \\n// lighting setup.\\n//\\n// Please change AA (line 13) to 1 if this shader is running slow.\\n//\\n\\n#define AA 1\\n#define FLOOR 0.\\n#define BODY 1.\\n#define HAIR 2.\\n\\n//\\n// Hash functions by Dave Hoskins:\\n//\\n// https://www.shadertoy.com/view/4djSRW\\n//\\n\\nfloat hash12(vec2 p) {\\n    vec3 p3  = fract(vec3(p.xyx) * 443.8975);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\nvec3 hash33(vec3 p3) {\\n    p3 = fract(p3 * vec3(443.897, 441.423, 437.195));\\n    p3 += dot(p3, p3.yxz + 19.19);\\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\\n}\\n\\nfloat noise(in vec2 p) {\\n    vec2 i = floor(p);\\n    vec2 f = fract(p);\\n    vec2 u = f*f*(3. -2.*f);\\n    \\n    return mix(mix(hash12(i + vec2(0, 0)), \\n                   hash12(i + vec2(1, 0)), u.x), \\n               mix(hash12(i + vec2(0, 1)), \\n                   hash12(i + vec2(1, 1)), u.x), u.y);\\n}\\n\\n//\\n// SDF framework by Inigo Quilez:\\n//\\n// https://www.shadertoy.com/view/Xds3zN\\n//\\n\\nvec2 boxIntersect(in vec3 ro, in vec3 rd, in vec3 rad) {\\n    vec3 m = 1./rd;\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*rad;\\n    \\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n    \\n    float tN = max(max(t1.x, t1.y), t1.z);\\n    float tF = min(min(t2.x, t2.y), t2.z);\\n    \\n    if(tN > tF || tF < .0) return vec2(-1);\\n    \\n    return vec2(tN, tF);\\n}\\n\\nfloat smin(float a, float b, float k) {\\n    float h = clamp(.5 + .5*(b - a)/k, .0, 1.);\\n    return mix(b, a, h) - k * h * (1. - h);\\n}\\n\\nfloat udRoundBox(vec3 p, vec3 b, float r) {\\n    return length(max(abs(p)-b, .0)) -r;\\n}\\n\\nfloat sdCapsuleF(vec3 p, vec3 a, vec3 b, const float r0, const float r1, const float f) {\\n    vec3 d = b -a;\\n    float h = length(d);\\n    d = normalize(d);\\n    float t=dot(p-a, d);\\n    float th = t/h;\\n    return distance(a+clamp(t,0.,h)*d, p)-mix(r0, r1, th) * \\n           max(0., 1.+f-f*4.*abs(th-.5)*abs(th -.5));\\n}\\n\\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, const float r0, const float r1) {\\n    vec3 d = b -a;\\n    float h = length(d);\\n    d = normalize(d);\\n    float t=clamp(dot(p-a, d), 0., h);\\n    return distance(a+t*d, p) -mix(r0, r1, t/h);\\n}\\n\\nfloat mapHand(in vec3 p) {\\n    float sph = length(p) - .1;\\n    if (sph > .1) return sph; //  bounding sphere\\n    \\n    const float s = 1.175;\\n    float d = udRoundBox(p, vec3(.0175/s + p.y * (.25/s), .035/s + p.x * (.2/s), 0.), .01);\\n    d = smin(d, min(sdCapsule(p, vec3(.025, .0475, 0)/s, vec3(.028, .08, .02)/s, .01/s, .0075/s), \\n                    sdCapsule(p, vec3(.028, .08, .02)/s, vec3(.03, 0.1, .06)/s, .0075/s, .007/s)), .0057);\\n    d = smin(d, min(sdCapsule(p, vec3(.01, .0425, 0)/s, vec3(.008, .07, .025)/s, .009/s, .0075/s), \\n                    sdCapsule(p, vec3(.008, .07, .025)/s, vec3(.008, .085, .065)/s, .0075/s, .007/s)), .0057);\\n    d = smin(d, min(sdCapsule(p, vec3(-.01, .04, 0)/s, vec3(-.012, .065, .028)/s, .009/s, .0075/s), \\n                    sdCapsule(p, vec3(-.012, .065, .028)/s, vec3(-.012, .07, .055)/s, .0075/s, .007/s)), .0057);\\n    d = smin(d, min(sdCapsule(p, vec3(-.025, .035, 0)/s, vec3(-.027, .058, .03)/s, .009/s, .0075/s), \\n                    sdCapsule(p, vec3(-.027, .058, .03)/s, vec3(-.028, .06, .05)/s, .0075/s, .007/s)), .0057);\\n    return d;\\n}\\n\\nvec2 map(in vec3 pos) {\\n    const float f0 = .075;\\n    const float f1 = .2;\\n    const float f2 = .275;\\n    \\n    vec3 ph = pos;\\n    \\n    if (pos.x < 0.) {\\n        ph += vec3(.11, -.135, .2);\\n        ph = mat3(-0.8674127459526062, -0.49060970544815063, 0.08304927498102188, 0.22917310893535614, -0.5420454144477844, -0.8084964156150818, 0.4416726529598236, -0.6822674870491028, 0.5826116800308228) * ph;\\n    } else {\\n        ph.x = -ph.x;\\n        ph += vec3(.075, -.09, .125);\\n        ph = mat3(-0.6703562140464783, -0.7417424321174622, 0.020991835743188858, 0.36215442419052124, -0.3517296612262726, -0.8632093667984009, 0.6476624608039856, -0.5710554718971252, 0.5044094920158386) * ph;\\n    }\\n    \\n    float dh = mapHand(ph);\\n    \\n    //  right arm\\n    float d = sdCapsuleF(pos, vec3(0.13, 0.535, -.036), vec3(.09, 0.292, -0.1), .035, .025, f1);\\n    d = smin(d, sdCapsuleF(pos, vec3(.08, 0.29, -0.1), vec3(-.09, 0.15, -0.17), .03, .02, f0), .0051);\\n    if (pos.x < 0.) d = smin(d, dh, .015);\\n    \\n    //  left arm\\n    float d1 = sdCapsuleF(pos, vec3(-0.12, 0.56, .02), vec3(-0.11, 0.325, -.045), .035, .025, f1);\\n    d1 = smin(d1, sdCapsuleF(pos, vec3(-0.11, 0.315, -.05), vec3(.07, .08, -0.11), .024, .022, f2), .005);\\n    if (pos.x > 0.) d1 = smin(d1, dh, .015);\\n    d = min(d1, d);\\n    \\n    //  body\\n    vec3 bp1 = pos;\\n    bp1 += vec3(0, -.44, -.027);\\n    bp1 = mat3(0.9761762022972107, 0.033977385610342026, 0.2143024057149887, -0.07553963363170624, 0.9790945649147034, 0.18885889649391174, -0.20340539515018463, -0.20054790377616882, 0.9583353996276855) * bp1;\\n    float db = udRoundBox(bp1, vec3(.07 + bp1.y*.3, 0.135 -abs(bp1.x)*0.2, 0.), .04);\\n    \\n    vec3 bp2 = pos;\\n    bp2 += vec3(-.032, -.235, -.06);\\n    bp2 = mat3(0.8958174586296082, -0.37155669927597046, 0.24383758008480072, 0.3379548490047455, 0.9258314967155457, 0.16918234527111053, -0.28861331939697266, -0.0691504031419754, 0.9549453258514404) * bp2;\\n    db = smin(db, udRoundBox(bp2, vec3(.065 - bp2.y*.25, 0.1, .02 -bp2.y*.13), .04), .03);\\n    \\n    db = smin(db, sdCapsule(pos, vec3(0.11, 0.5, -.032), vec3(.05, 0.52, -.015), .04, .035), .01);\\n    db = smin(db, sdCapsule(pos, vec3(.01, 0.4, -.01), vec3(.01, 0.7, .0), .045, .04), .02);\\n    \\n    vec3 bp3 = pos;\\n    bp3 += vec3(-.005, -.48, .018);\\n    bp3 = mat3(0.9800665974617004, 0.05107402056455612, 0.19199204444885254, 0, 0.9663899540901184, -0.2570805549621582, -0.19866932928562164, 0.2519560754299164, 0.9471265077590942) * bp3;\\n    db = smin(db, udRoundBox(bp3, vec3(.056 + bp3.y*.23 , .06, 0.), .04), .01);\\n    \\n    d = smin(d, db, .01);\\n    \\n    //  right leg\\n    float d2 = sdCapsuleF(pos, vec3(0.152, 0.15, .05), vec3(-.03, 0.43, -.08), .071, .055, f2);\\n    d2 = smin(d2, sdCapsuleF(pos, vec3(0.14, .08, .05), vec3(-.01, 0.23, -.02), .05, .02, f1), .075);\\n    d = min(d, d2);\\n    float d3 = sdCapsuleF(pos, vec3(-.03, 0.43, -.084), vec3(.055, .04, -.04), .053, .02, f0);\\n    d3 = smin(d3, sdCapsuleF(pos, vec3(-.0, 0.35, -.05), vec3(.025, 0.2, -.03), .04, .02, f2), .05);\\n    d = min(d, d3);\\n    \\n    //  left leg\\n    d = min(d, sdCapsuleF(pos, vec3(-.02, 0.12, 0.1), vec3(-0.145, .08, -0.17), .07, .055, f2));\\n    float d4 = sdCapsuleF(pos, vec3(-0.145, .08, -0.17), vec3(0.205, .02, -0.09), .05, .0185, f0);\\n    d4 = smin(d4, sdCapsuleF(pos, vec3(-.05, .085, -0.145), vec3(.05, .03, -.09), .035, .03, f2), .0075);\\n    \\n    //  right feet\\n    float d6 = distance(pos, vec3(.0, .0, -0.1)) -.1; //  bounding sphere\\n    if(d6 < 0.1) {\\n        d = min(d, sdCapsule(pos, vec3(.03, .03, -.08), vec3(.031, .01, -0.146), .015, .005));\\n        d = min(d, sdCapsule(pos, vec3(.02, .03, -.08), vec3(.018, .01, -0.1505), .015, .006));\\n        d = min(d, sdCapsule(pos, vec3(.00, .03, -.08), vec3(.005, .01, -0.1525), .015, .007));\\n        d = min(d, sdCapsule(pos, vec3(-.01, .03, -.08), vec3(-.014, .01, -0.1575), .015, .01));\\n    } else {\\n        d = min(d6, d);\\n    }\\n    \\n    //  left feet\\n    float d5 = distance(pos, vec3(0.25, .025, -0.1)) -.12; //  bounding sphere\\n    if(d5 < 0.1) {\\n        d5 = sdCapsule(pos, vec3(0.2, .035, -.075), vec3(0.3, .01, -.09), .035, .02);\\n        d5 = smin(d5, sdCapsule(pos, vec3(0.31, .035, -.0975), vec3(0.1, .01, -0.10), .015, .02), .02);\\n        d5 = smin(d5, sdCapsule(pos, vec3(0.31, .035, -.0975), vec3(0.355, .034, -0.10), .015, .01), .005);\\n        d5 = min(d5, sdCapsule(pos, vec3(0.31, .022, -.0875), vec3(0.335, .022, -.09), .02, .01));\\n    }\\n    d4 = smin(d4, d5, .025);\\n    d = min(d, d4);\\n    \\n    //  hair\\n    vec3 hp = pos;\\n    hp.x += smoothstep(.55, .45, pos.y)*.035;\\n    hp.z *= 1.9 - .8 * pos.y;\\n    hp.yz -= 2.*pos.x*pos.x;\\n    float h = sdCapsule(hp, vec3(.0, 0.725, -.02), vec3(-.02, 0.415, .0), .094, .085);\\n    h = smin(h, sdCapsule(hp, vec3(.0, 0.725, -.02), vec3(.06, 0.705, -.05), .085, .095), .02);\\n    h = max(-(pos.y - abs(fract(pos.x*90.) -.5)*0.1 -.14 - smoothstep(-0.2, 0.1, pos.x)*.5), h);\\n    \\n    return (h < d) ? vec2(h, HAIR) : vec2(d, BODY);\\n}\\n\\n\\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\\n    float res = 1.;\\n    float t = mint;\\n    for(int i=0; i<14; i++) {\\n        float h = map(ro + rd*t).x;\\n        res = min(res, 8.*h/t);\\n        t += max(h, .02);\\n        if(res<.005 || t>tmax) break;\\n    }\\n    return clamp(res,0.,1.);\\n}\\n\\nvec3 calcNormal(in vec3 pos) {\\n    vec2 e = vec2(1,-1)*.00005;\\n    return normalize(e.xyy*map(pos + e.xyy).x +\\n                     e.yyx*map(pos + e.yyx).x +\\n                     e.yxy*map(pos + e.yxy).x +\\n                     e.xxx*map(pos + e.xxx).x);\\n}\\n\\nfloat calcAO(in vec3 pos, in vec3 nor) {\\n    float occ = 0.;\\n    float sca = 1.;\\n    for(int i=0; i<5; i++) {\\n        float hr = .005 + .12*float(i)/4.;\\n        vec3 aopos =  nor * hr + pos;\\n        float dd = min(aopos.y, map(aopos).x);\\n        occ += -(dd -hr)*sca;\\n        sca *= .95;\\n    }\\n    return clamp(1. - 3.*occ, 0., 1.);\\n}\\n\\nfloat render(in vec3 ro, in vec3 rd, in vec2 uv) {\\n    //  cast ray\\n    float planeIntersect = abs(-ro.y/rd.y);\\n    vec2 box = boxIntersect(ro, rd, vec3(.37, 1, .3));\\n    float t = box.x;\\n    float tmax = min(box.y, planeIntersect);\\n    \\n    float m = FLOOR;\\n    if (t > 0.) {\\n        for(int i=0; i<40; i++) {\\n            float precis = .0004*t;\\n            vec2 res = map(ro+rd*t);\\n            m = res.y;\\n            if(abs(res.x) < precis || t > tmax) break;\\n            t += res.x;\\n        }\\n    }\\n    if(t>=tmax || t<0.) {\\n        t = rd.y < 0. ? planeIntersect : 1000.;\\n        m = FLOOR;\\n    }\\n    \\n    //  shade scene\\n    float col = 0.;\\n    if(t < 10.) {\\n        vec3 pos = ro + t*rd;\\n        vec3 nor = vec3(0, 1, 0);\\n        \\n        if (m < FLOOR + .5) {\\n            col = .03;\\n        } else {\\n            col = .5;\\n            nor = calcNormal(pos);\\n        }\\n        if (m > BODY + .5) {\\n            col = 0.;\\n        }\\n        nor = normalize(nor + (hash33(pos) -.5) * .1);\\n        vec3 ligp = vec3(5., 5., -.5);\\n        vec3 lig = -normalize(pos - ligp);\\n        float dif = clamp(dot(nor, lig), 0., 1.);\\n        float bac = clamp(dot(nor, normalize(vec3(-.2, .5, -.02))), .0, 1.0)\\n                    *clamp(1.-pos.y,0.,1.);  \\n        if(m > FLOOR) bac *= clamp(-10.*pos.z+.4,0.,1.);\\n        \\n        float occ, sha;\\n        if (pos.x > .4 || pos.z > 1.) {\\n            occ = sha = 1.;\\n        } else {\\n            occ = calcAO(pos, nor);\\n            sha = calcSoftshadow(pos, lig, .01, 1.5);\\n        }\\n        \\n        col *= 1.30*dif*sha*(.25+.75*occ) + .5*bac*occ;\\n        \\n        if (m > BODY + .5) {\\n            // totally fake hair lighting\\n            vec3 ref = reflect(rd, nor);\\n            vec3 hal = normalize(normalize(vec3(-.1, .5, .35)) -rd);\\n            vec2 hv = mix(vec2(pos.x*60. -pos.z*35., 0.), \\n                          vec2(-pos.x*50. -pos.z*50., 0.), \\n                          smoothstep(.0, .01, -dot(pos, normalize(vec3(-1., .15, .45)))));\\n            float n = noise(hv*20. + vec2(2. + 10.*sin(pos.y*20.+.4), 2.5));\\n            n = smoothstep(.4, 1., n);\\n            float nd = noise(hv*40.+ vec2(2. + 10.*sin(pos.y*20.+.4), .5));\\n            n *= nd * nd;\\n            col += n * pow(max(0., dot(ref, hal)), 8.);\\n            col += .03 * n * max(0., dot(ref, hal)) * smoothstep(.75, .5, pos.y);\\n        }\\n        \\n        col *= smoothstep(.985, 1., dot(normalize(vec3(0.7, 0.58, -.05)), lig));\\n    }\\n    \\n    return clamp(col, 0., 1.);\\n}\\n\\nmat3 setCamera(in vec3 ro, in vec3 ta) {\\n    vec3 cw = normalize(ta -ro);\\n    vec3 cu = normalize(cross(cw, vec3(0,1,0)));\\n    vec3 cv = normalize(cross(cu, cw));\\n    return mat3(cu, cv, cw);\\n}\\n\\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\\n    float angle = -.18+ .18*sin(iTime*0.5);\\n    float tot = 0.;\\n    \\n    for(int m=0; m<AA + min(0,iFrame); m++)\\n        for(int n=0; n<AA + min(0,iFrame); n++) {\\n            vec2 o = vec2(float(m), float(n))/float(AA) - .5;\\n            vec2 p = (-iResolution.xy + 2.*(fragCoord+o))/iResolution.y;\\n            \\n            p.x -= .8;\\n            \\n            vec3 ro = vec3(2.9*sin(angle) , .65, -2.9*cos(angle));\\n            vec3 ta = vec3(0., 0.45, 0.);\\n            mat3 ca = setCamera(ro, ta);\\n            vec3 rd = ca * normalize(vec3(p.xy, 5));\\n            \\n            float col = render(ro, rd, p);\\n            tot += pow(col, .4545);\\n        }\\n    tot /= float(AA*AA);\\n    \\n    tot += .075 * hash12(fragCoord/iResolution.xy);\\n    tot *= 1.35;\\n    \\n    fragColor = vec4(min(tot*vec3(1, .97, .92), 1.), 1.);\\n}\\n\\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\\n    vec2 p = (-iResolution.xy + 2.*fragCoord)/iResolution.y;\\n    float c = pow(render(ro + vec3(0,.65,-1), rd, p), .4545);\\n    fragColor = vec4(c,c,c,1.);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"llcyD2","date":"1534089156","viewed":25034,"name":"A quine","description":"This is [url=https://www.shadertoy.com/view/Ml3SWj]done[/url] [url=https://www.shadertoy.com/view/Mlj3zR]before[/url] and my code is not the most [url=https://www.shadertoy.com/view/MlGcRz]optimised[/url], but it is nice to write your own quine!","likes":162,"published":"Public API","usePreview":0,"tags":["text","font","quine"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int y;ivec2 d;uint[] c = uint[ 151](0x007a995eu,0x0083f840u,0x009a9c40u,0x006e5840u,0x0043f4dcu,    \\n0x006659c0u,0x0066595eu,0x000c5661u,0x006a595au,0x007a9a66u,0x00f14938u,0x0062493fu,0x00924918u,    \\n0x00fe4918u,0x00a2cb18u,0x00145f84u,0x3813813cu,0x0003d100u,0x0087f840u,0x0066bb5au,0x0085e000u,    \\n0x00330604u,0x00010800u,0x00020000u,0x00624918u,0x00f2081cu,0x00024784u,0x0001e840u,0x0085e100u,    \\n0x000047a1u,0x00014800u,0x00894200u,0x00214880u,0x0023e208u,0x00008208u,0x00f2081cu,0x00024784u,    \\n0x0087f000u,0x0003f840u,0x00918624u,0x000ccc00u,0x00916724u,0x00a3b9d8u,0x00514514u,0x00310a24u,    \\n0x00e0423cu,0x001a9080u,0x00024000u,0x00c766e3u,0x00c8d17fu,0x0052ca00u,0x0083f040u,0x0003f000u,    \\n0x0000413cu,0x00000000u,0x00000000u,0x2cd9ab51u,0x0c39545eu,0x1978dd82u,0x2695ab51u,0x36af6336u,    \\n0x256ad459u,0x26045076u,0xfefbefd4u,0x2d45979bu,0x1950ed9au,0x0bd9ab51u,0x1a3b571bu,0x0cdadd59u,    \\n0x208262e5u,0x299d7354u,0x2c5cd846u,0x019c0a9bu,0x1165d799u,0x145766adu,0x0ad9ab51u,0x366ad456u,    \\n0x1ab5158bu,0x1171b3f6u,0x2b4766adu,0x3678a8acu,0x3565a3b5u,0x007d1dadu,0x0b811d34u,0x1902702eu,    \\n0x253143afu,0x0f845a11u,0x30460826u,0x00a86a45u,0x1b64f0e7u,0x2d45975eu,0x1b52dd9au,0x366ad45cu,    \\n0x038acad1u,0x11ad8586u,0x35782070u,0x2dd5968eu,0x3401f476u,0x01811db4u,0x00b80048u,0x18bd9027u,    \\n0x0eb80aebu,0x19027014u,0x2bad8bdbu,0x0050eb81u,0x1b6470a7u,0x01aeb62fu,0x0050eb80u,0x1b6430a7u,    \\n0x01aeb62fu,0x0050eb81u,0x1b646067u,0x253143afu,0x26081a11u,0x14da0836u,0x1b622254u,0x2ad9b129u,    \\n0x1b64f9c0u,0x1161575eu,0x11290d8du,0x132904adu,0x1a65850eu,0x0430e576u,0x0e5562b6u,0x1b2f608cu,    \\n0x2bb172dcu,0x18c8ec51u,0x1845a673u,0x0b8ac5edu,0x2b35eb17u,0x0230e551u,0x2c79b2d4u,0x289d736bu,    \\n0x17354845u,0x296c8a2cu,0x3035e189u,0x0c39546bu,0x08585502u,0x15aca79bu,0x0d50430eu,0x34160b17u,    \\n0x209d72f4u,0x2e5c0204u,0x2f6409c0u,0x03580515u,0x1b185585u,0x216d4b61u,0x04201515u,0x010c4587u,    \\n0x1b6c4196u,0xfefbf75eu);uint e(uint b){return c[b]>>(d.x*6+d.y)&0x1u;}uint v(int a,int b,int f)\\n{int i=y-a; return i<0||i>b?0x0u:e(c[i/5+f]>>i%5*6&0x3fu);}uint n(){int i=y-36,o=i%12;return i<0\\n|| i>1810?0x0u:o==0?e(0x0u):o==1?e(0x27u):o==10?e(0x23u):o==11?e(0x16u):e(c[i/12] >> ((9-o)*4) &\\n0xfu);}void mainImage(out vec4 a,vec2 b){b.y=iResolution.y-b.y;d=ivec2(b);y=d.x/5+(d.y/8)*96;d%=\\nivec2(5,8);a=vec4(d.y>5||b.x>480.?0x0u:v(0,35,56)+n()+v(1847,431,64));}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MlGcRz","date":"1534834871","viewed":4199,"name":"A smaller quine","description":"Same strategy as [url=https://www.shadertoy.com/view/llcyD2]\\"A quine\\"[/url], but I have focused more on code size.","likes":49,"published":"Public API","usePreview":0,"tags":["text","font","quine"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int y, i;ivec2 d;int[]c=int[116](0x007a995e,0x0083f840,0x009a9c40,0x006e5840,\\n0x0043f4dc,0x006659c0,0x0066595e,0x000c5661,0x006a595a,0x007a9a66,0x00f14938,\\n0x0062493f,0x00924918,0x00fe4918,0x00a2cb18,0x00145f84,0x3813813c,0x0003d100,\\n0x0087f840,0x0066bb5a,0x0085e000,0x00330604,0x00010800,0x00020000,0x00624918,\\n0x00f2081c,0x00024784,0x0001e840,0x0085e100,0x000047a1,0x00014800,0x00894200,\\n0x00214880,0x0023e208,0x00008208,0x00f2081c,0x00024784,0x0087f000,0x0003f840,\\n0x00918624,0x000ccc00,0x00916724,0x00a3b9d8,0x00514514,0x00310a24,0x00e0423c,\\n0x001a9080,0x00024000,0x00c766e3,0x00c8d17f,0x0052ca00,0x0083f040,0x0003f000,\\n0x0000413c,0x00000000,0x2cd9ab51,0x11791d96,0x3608c395,0x1ab5178d,0x11acc9a5,\\n0x010656ad,0xfefd4986,0x1161579b,0x11290d8d,0x132904ad,0x1a65850e,0x0430e576,\\n0x0e5562b6,0x1b2f608c,0x1546b35c,0x0b50230e,0x314569d7,0x19cd8c8e,0x17b5845a,\\n0x2c5cb8ac,0x0daec79b,0x211689d7,0x08a2c5cd,0x0d5871e9,0x0e551af0,0x1615408c,\\n0x2b29e6c8,0x1410c395,0x0582c5cd,0x275cbd34,0x171480e0,0x0182cd34,0x00b841c5,\\n0x1fb2532f,0x2532e0c3,0x05845a2c,0x2c820985,0x2a1a9170,0x20b2f0c6,0x2e1c00c1,\\n0x2b45494c,0x000c18ac,0x211686c8,0x20826086,0x06a45c11,0x14bc31aa,0x2b454aec,\\n0x1b0c38ac,0x2b6c1070,0x2f02e02b,0x2e06baec,0x2bb2f243,0x02b8006b,0x1194cbc2,\\n0x20981068,0x2c8860e0,0x0506a129,0x17360826,0x0d846a67,0x1b06ab17,0xfefbf75e)\\n;void mainImage(out vec4 a,vec2 b){d=ivec2(b.x,iResolution.y-b.y);y=d.x/5+d.y\\n/8*77,d%=ivec2(5,8);a=vec4(d.y>5||b.x>385.||y>1574?0:c[y<33?c[y/5+55]>>y%5*6&\\n63:y>1307?c[(i=y-1308)/5+62]>>i%5*6&63:(y=(i=y-33)%11)==0?0:y==1?39:y==10?22:\\nc[i/11]>>36-y*4&15]>>d.x*6+d.y&1);}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MlyyzW","date":"1535275805","viewed":6586,"name":"Old watch (RT)","description":"A simple path tracer is used to render the watch from my image based lighting shader \\"Old watch (IBL)\\". [url=https://www.shadertoy.com/view/lscBW4]Click here to compare[/url].\\n\\n! Use your mouse to change the camera viewpoint.","likes":53,"published":"Public API","usePreview":0,"tags":["ray","tracer","path","pbr"]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Old watch (RT). Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MlyyzW\\n//\\n// A simple path tracer is used to render an old watch. The old watch scene is\\n// (almost) the same scene as rendered using image based lighting in my shader \\"Old\\n// watch (IBL)\\":\\n// \\n// https://www.shadertoy.com/view/lscBW4\\n//\\n// You can find the path tracer in Buffer B. I'm no expert in ray or path tracing so\\n// there are probably a lot of errors in this code.\\n//\\n// Use your mouse to change the camera viewpoint.\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\\n    vec3 col = data.rgb / data.w;\\n    \\n    // gamma correction\\n    col = max( vec3(0), col - 0.004);\\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\\n    \\n    // Output to screen\\n    fragColor = vec4(col,1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Old watch (RT). Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MlyyzW\\n//\\n// I have moved all ray-march code to this tab, in order to keep the RT-code in Buffer B \\n// more readable. The physically-based properties of the materials are also defined here.\\n//\\n// The hash functions are copy-paste from \\"Quality hashes collection WebGL2\\" by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n// All (signed) distance field (SDF) code is copy-paste from the excellent framework by \\n// Inigo Quilez:\\n//\\n// https://www.shadertoy.com/view/Xds3zN\\n//\\n// More info here: https://iquilezles.org/articles/distfunctions\\n//\\n\\n#define MAT_TABLE    1.\\n#define MAT_PENCIL_0 2.\\n#define MAT_PENCIL_1 3.\\n#define MAT_PENCIL_2 4.\\n#define MAT_DIAL     5.\\n#define MAT_HAND     6.\\n#define MAT_METAL_0  7.\\n#define MAT_METAL_1  8.\\n\\n#define CLOCK_ROT_X -0.26\\n#define CLOCK_ROT_Y 0.2\\n#define CLOCK_OFFSET_Y 0.42\\n#define PENCIL_POS vec3(-0.31,-0.2, -.725)\\n\\nfloat TIME = 11344.;\\n#define MAX_T 10.\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint baseHash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat hash1(inout float seed) {\\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    return float(n)/float(0xffffffffU);\\n}\\n\\nvec2 hash2(inout float seed) {\\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// SDF functions (by Inigo Quilez).\\n//\\n\\nfloat sdPlane( const vec3 p ) {\\n\\treturn p.y;\\n}\\n\\nfloat sdTorus( const vec3 p, const vec2 t ) {\\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\\n  return length(q)-t.y;\\n}\\n\\nfloat sdTorusYZ( const vec3 p, const vec2 t ) {\\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\\n  return length(q)-t.y;\\n}\\n\\nfloat sdTorusYX( const vec3 p, const vec2 t ) {\\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\\n  return length(q)-t.y;\\n}\\n\\nfloat sdCylinder( const vec3 p, const vec2 h ) {\\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\\n}\\n\\n\\nfloat sdHexPrism( const vec3 p, const vec2 h ) {\\n    vec3 q = abs(p);\\n#if 0\\n    return max(q.x-h.y,max((q.z*0.866025+q.y*0.5),q.y)-h.x);\\n#else\\n    float d1 = q.x-h.y;\\n    float d2 = max((q.z*0.866025+q.y*0.5),q.y)-h.x;\\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\\n#endif\\n}\\n\\nfloat sdEllipsoid( const vec3 p, const vec3 r ) {\\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\\n}\\n\\nfloat sdCapsule( const vec3 p, const vec3 a, const vec3 b, const float r ) {\\n\\tvec3 pa = p-a, ba = b-a;\\n\\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\\n\\treturn length( pa - ba*h ) - r;\\n}\\n\\nfloat sdSphere( const vec3 p, const float r ) {\\n    return length(p) - r;\\n}\\n\\nfloat sdCone( const vec3 p, const vec2 c ) {\\n    float q = length(p.yz);\\n    return dot(c,vec2(q,p.x));\\n}\\n\\nfloat sdSegment2D( const vec2 p, const vec2 a, const vec2 b, const float w ) {\\n\\tvec2 pa = p-a, ba = b-a;\\n\\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\\n\\treturn length( pa - ba*h ) - w;\\n}\\n\\nfloat opS( const float d1, const float d2 ) {\\n    return max(-d1,d2);\\n}\\n\\nfloat opU( const float d1, const float d2 ) {\\n    return min(d1,d2);\\n}\\n\\nvec3 rotateX( in vec3 p, const float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    p.yz = mat2(co,-si,si,co)*p.yz;\\n    return p;\\n}\\n\\nvec3 rotateY( in vec3 p, const float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    p.xz = mat2(co,-si,si,co)*p.xz;\\n    return p;\\n}\\n\\nvec3 rotateZ( in vec3 p, const float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    p.xy = mat2(co,-si,si,co)*p.xy;\\n    return p;\\n}\\n\\nvec2 rotate( in vec2 p, const float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    p = mat2(co,-si,si,co) * p;\\n    return p;\\n}\\n\\n//\\n// SDF of the scene.\\n//\\n\\nfloat mapHand( const vec3 pos, const float w, const float l, const float r ) {\\n    float d = sdSegment2D(pos.xz, vec2(0,-w*10.), vec2(0,l), w);\\n    d = min(d, length(pos.xz) - (.03+r));\\n    return max(d, abs(pos.y)-.005);\\n}\\n\\nvec2 map( in vec3 pos, in vec3 p1, in vec3 ps, in vec3 pm, in vec3 ph, \\n         const bool watchIntersect, const bool pencilIntersect ) {\\n    //--- table\\n    vec2 res = vec2(sdPlane(pos), MAT_TABLE);\\n    \\n    // chain\\n    if (pos.z > 1.1) {\\n        float h = smoothstep(3., -.4, pos.z)*.74 + .045;\\n        float dChain0 = length(pos.xy+vec2(.3*sin(pos.z), -h))-.1;\\n        if (dChain0 < 0.1) {\\n            dChain0 = 10.;\\n            float pth1z = floor(pos.z*5.);\\n            if (pth1z > 5.) {\\n            \\tfloat pth21 = floor(pos.z*5.);\\n\\t            float pth1 = hash1(pth21);\\n    \\t        vec3 pt1 = vec3(pos.x + .3*sin(pos.z)- pth1 *.02 + 0.02, pos.y-h - pth1 *.03, mod(pos.z, .2) - .1);\\n        \\t    pt1 = rotateZ(pt1, .6 * smoothstep(2.,3., pos.z));\\n            \\tdChain0 = sdTorus(pt1, vec2(.071, .02)); \\n            }\\n            \\n            float pth2z = floor(pos.z*5. + .5);\\n            float pth2 = hash1(pth2z); \\n            vec3 pt2 = vec3(pos.x + .3*sin(pos.z)- pth2 *.02 + 0.02, pos.y-h - pth2 *.03, mod(pos.z + .1, .2) - .1);\\n            pt2 = rotateZ(pt2, 1.1 * smoothstep(2.,3., pos.z));\\n            dChain0 = opU(dChain0, sdTorusYZ(pt2, vec2(.071, .02)));          \\n        }\\n        if (dChain0 < res.x) res = vec2(dChain0, MAT_METAL_1);\\n    }\\n    //--- pencil\\n    if (pencilIntersect) {\\n        float dPencil0 = sdHexPrism(pos + PENCIL_POS, vec2(.2, 2.));\\n        dPencil0 = opS(-sdCone(pos + (PENCIL_POS + vec3(-2.05,0,0)), vec2(.95,0.3122)),dPencil0);\\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.4,-2.82,-1.03)), 3.), dPencil0);\\n        dPencil0 = opS(sdSphere(pos + (PENCIL_POS + vec3(-2.5,-0.82,2.86)), 3.), dPencil0);\\n        if (dPencil0 < res.x) res = vec2(dPencil0, MAT_PENCIL_0);\\n\\n        float dPencil1 = sdCapsule(pos, -PENCIL_POS - vec3(2.2,0.,0.), -PENCIL_POS-vec3(2.55, 0., 0.), .21);\\n        if (dPencil1 < res.x) res = vec2(dPencil1, MAT_PENCIL_1);\\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\\n        float r = .02*abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\\n\\n        float dPencil2 = sdCylinderZY(pos + PENCIL_POS + vec3(2.25,-0.0125,0), vec2(.22 - r,.25));\\n        if (dPencil2 < res.x) res = vec2(dPencil2, MAT_PENCIL_2);\\n    }\\n    \\n    //--- watch\\n    if (watchIntersect) {\\n        float dDial = sdCylinder(p1, vec2(1.05,.13));\\n        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);\\n\\n        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));\\n        if (dC < res.x) res = vec2(dC, MAT_METAL_1);\\n        \\n        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   \\n        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));\\n        if(bb < 0.5) {\\n            float a = atan(p1.y, p1.x);\\n            float c = abs(fract(a*3.1415)-.5);\\n            float d = min(abs(p1.z-1.3), .02);\\n            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15 - 40.*d*d - .1*c*c,0.04));\\n        } \\n        dM = opU(dM, bb);\\n         \\n        dM = opU(dM, sdCylinderZY(p1+vec3(0,0,-1.18), vec2(0.06,0.2)));\\n        float rr = min(abs(p1.z-1.26), .2);\\n        dM = opU(dM, sdCylinderXY(p1+vec3(0,0,-1.2), vec2(0.025 + 0.35*rr,0.1)));\\n       \\n        p1.y = abs(p1.y);\\n        dM = opU(dM, sdTorus(p1 + vec3(0,-.1,0), vec2(1.025,.075)));\\n        dM = opU(dM, sdCylinder(p1, vec2(1.1,.1)));\\n        dM = opS(sdTorus(p1 + vec3(0,-.1,0), vec2(1.11,.015)), dM);\\n        dM = opU(dM, sdCylinder(p1, vec2(0.01,0.175)));\\n        dM = opU(dM, sdCylinder(p1+vec3(0,0,.6), vec2(0.01,0.155)));\\n        if (dM < res.x) res = vec2(dM, MAT_METAL_0);\\n\\n        // minutes hand\\n        float dMin = mapHand(pm + vec3(0,-.16,0), .02, 0.7, 0.015);\\n        if (dMin < res.x) res = vec2(dMin, MAT_HAND);\\n        // hours hand\\n        float dHour = mapHand(ph + vec3(0,-.15,0), .02, 0.4, 0.03);\\n        if (dHour < res.x) res = vec2(dHour, MAT_HAND);\\n        // seconds hand\\n        float dSeconds = mapHand(ps + vec3(0,-.14,0), .01, 0.17, 0.006);\\n        if (dSeconds < res.x) res = vec2(dSeconds, MAT_HAND);\\n    }\\n    \\n    return res;\\n}\\n\\nvec2 map( in vec3 pos ) {\\n    vec3 p1 = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\\n    p1 = rotateY( p1, CLOCK_ROT_Y );\\n    \\n\\tfloat secs = mod( floor(TIME),        60.0 );\\n\\tfloat mins = mod( floor(TIME/60.0),   60.0 );\\n\\tfloat hors = mod( floor(TIME/3600.0), 24.0 ) + mins/60.;\\n    \\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\\n    \\n    return map( pos, p1, ps, pm, ph, true, true );\\n}\\n\\nfloat mapGlass( in vec3 pos ) {\\n    return sdEllipsoid( pos - vec3(0,.10,0), vec3(1.,.2,1.) );\\n}\\n\\n//\\n// Ray march code.\\n//\\n\\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float r ) {\\n\\tvec3 oc = ro;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - r * r;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return vec2(-1.0);\\n    h = sqrt( h );\\n\\treturn vec2(-b - h, -b + h);\\n}\\n\\nbool boxIntserct( in vec3 ro, in vec3 rd, in vec3 rad ) {\\n    vec3 m = 1.0/rd;\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*rad;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n\\tif( tN > tF || tF < 0.0) return false;\\n\\n\\treturn true;\\n}\\n\\nvec3 calcNormal( in vec3 pos ) {\\n    const vec2 e = vec2(1.0,-1.0)*0.0075;\\n    return normalize( e.xyy*map( pos + e.xyy ).x + \\n\\t\\t\\t\\t\\t  e.yyx*map( pos + e.yyx ).x + \\n\\t\\t\\t\\t\\t  e.yxy*map( pos + e.yxy ).x + \\n\\t\\t\\t\\t\\t  e.xxx*map( pos + e.xxx ).x );\\n}\\n\\nvec2 castRay( in vec3 ro, in vec3 rd ) {\\n    float tmin = 0.001;\\n    float tmax = MAX_T;\\n    \\n    // bounding volume\\n    const float top = 0.95;\\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\\n    float tp2 = (top-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>top ) tmin = max( tmin, tp2 );\\n                                                 else           tmax = min( tmax, tp2 ); }\\n    \\n    float t = tmin;\\n    float mat = -1.;\\n    \\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\\n    p1 = rotateY( p1, CLOCK_ROT_Y );\\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\\n    \\n\\tfloat secs = mod( floor(TIME),        60.0 );\\n\\tfloat mins = mod( floor(TIME/60.0),   60.0 );\\n\\tfloat hors = mod( floor(TIME/3600.0), 24.0 ) + mins/60.;\\n    \\n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs/60.0 );\\n    vec3 rds = rotateY( rd1, 6.2831*secs/60.0 );\\n    \\n    vec3 pm = rotateY( p1, 6.2831*mins/60.0 );\\n    vec3 rdm = rotateY( rd1, 6.2831*mins/60.0 );\\n    \\n    vec3 ph = rotateY( p1, 6.2831*hors/12.0 );\\n    vec3 rdh = rotateY( rd1, 6.2831*hors/12.0 );\\n    \\n    bool watchIntersect = boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\\n    bool pencilIntersect = boxIntserct(ro + PENCIL_POS, rd, vec3(3.,.23,.23));\\n    \\n    for( int i=0; i<64; i++ ) {\\n\\t    float precis = 0.00001;\\n\\t    vec2 res = map( ro+rd*t, p1+rd1*t, ps+rds*t, pm+rdm*t, ph+rdh*t, \\n                       watchIntersect, pencilIntersect );\\n        if( abs(res.x)<precis || t>tmax ) break; //return vec2(t, mat);\\n        t += res.x;\\n        mat = res.y;\\n    }\\n\\n    if( t>tmax ) t=-1.0;\\n    return vec2(t, mat);\\n}\\n\\nvec3 calcNormalGlass( in vec3 pos ) {\\n    const vec2 e = vec2(1.0,-1.0)*0.005;\\n    return normalize( e.xyy*mapGlass( pos + e.xyy ) + \\n\\t\\t\\t\\t\\t  e.yyx*mapGlass( pos + e.yyx ) + \\n\\t\\t\\t\\t\\t  e.yxy*mapGlass( pos + e.yxy ) + \\n\\t\\t\\t\\t\\t  e.xxx*mapGlass( pos + e.xxx ) );\\n}\\n\\nfloat castRayGlass( in vec3 ro, in vec3 rd ) {\\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\\n    p1 = rotateY( p1, CLOCK_ROT_Y );\\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\\n\\n    float t = -1.;\\n    vec2 bb = sphIntersect( p1- vec3(0,.10,0), rd1, 1.);\\n    if (bb.y > 0.) {\\n        t = max(bb.x, 0.);\\n        float tmax = bb.y;\\n        for( int i=0; i<32; i++ ) {\\n            float precis = 0.0001;\\n            float res = mapGlass( p1+rd1*t );\\n            if( abs(res)<precis || t>tmax ) break; \\n            t += res;\\n        }\\n\\n        if( t>tmax ) t=-1.0;\\n    }\\n    return t;\\n}\\n\\n\\n//\\n// Material properties.\\n//\\n\\nvec4 texNoise( sampler2D sam, in vec3 p, in vec3 n ) {\\n\\tvec4 x = texture( sam, p.yz );\\n\\tvec4 y = texture( sam, p.zx );\\n\\tvec4 z = texture( sam, p.xy );\\n\\n\\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\\n}\\n\\nvoid getMaterialProperties(\\n    in vec3 pos, in float mat,\\n    inout vec3 normal, inout vec3 albedo, inout float roughness, inout float metallic,\\n\\tsampler2D tex1, sampler2D tex2, sampler2D tex3) {\\n    \\n    vec3 pinv = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\\n    pinv = rotateY( pinv, CLOCK_ROT_Y );\\n    \\n    normal = calcNormal( pos );\\n    metallic = 0.;\\n    \\n    vec4 noise = texNoise(tex1, pinv * .5, normal);\\n    float metalnoise = 1.- noise.r;\\n    metalnoise*=metalnoise;\\n\\n    mat -= .5;\\n    if (mat < MAT_TABLE) {\\n        albedo = .7 * pow(texture(tex1, rotate(pos.xz * .4 + .25, -.3)).rgb, 2.2*vec3(0.45,0.5,0.5));\\n        roughness = 0.9 - albedo.r * .6;\\n        normal = vec3(0,1,0);\\n    }\\n    else if( mat < MAT_PENCIL_0 ) {\\n        vec2 npos = pos.yz + PENCIL_POS.yz;\\n        if (length(npos) < 0.055) {\\n        \\talbedo = vec3(0.02);\\n        \\troughness = .9;\\n        } else if(sdHexPrism(pos + PENCIL_POS, vec2(.195, 3.)) < 0.) {\\n        \\talbedo = .8* texture(tex1, pos.xz).rgb;\\n        \\troughness = 0.99;\\n        } else {\\n        \\talbedo = .5*pow(vec3(1.,.8,.15), vec3(2.2));\\n        \\troughness = .85 - noise.b * .4;\\n        }\\n        albedo *= noise.g * .75 + .7;\\n    }\\n    else if( mat < MAT_PENCIL_1 ) {\\n       \\talbedo = .4*pow(vec3(.85,.75,.55), vec3(2.2));\\n       \\troughness = 1.;\\n    }\\n    else if( mat < MAT_PENCIL_2 ) {\\n        float ax = abs(-2.25 - pos.x - PENCIL_POS.x);\\n        float r = 1. - abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\\n\\n        r -= 4. * metalnoise;  \\n\\t    albedo = mix(.5*vec3(0.5, 0.3, 0.2),vec3(0.560, 0.570, 0.580), (.5 + .5 * r) * (.5 + .5 * r)); // Iron\\n   \\t\\troughness = .8-.5*r;\\n   \\t\\tmetallic = 1.; \\n    }\\n    else if( mat < MAT_DIAL ) {\\n        float dial = texture(tex2, vec2(-.5 * pinv.x + .5, +.5 * pinv.z + .5)).r;\\n        albedo = vec3(dial);\\n        roughness = dial + .95;\\n    }\\n    else if( mat < MAT_HAND ) {\\n        albedo = vec3(0.02);\\n        roughness = .8;\\n    }\\n    else if( mat < MAT_METAL_0 ) {\\n\\t    albedo = vec3(1.000, 0.766, 0.336); // Gold\\n   \\t\\troughness = .5;\\n   \\t\\tmetallic = 1.; \\n    } \\n    else if( mat < MAT_METAL_1 ) {\\n\\t    albedo = vec3(0.972, 0.960, 0.915); // Silver\\n   \\t\\troughness = .5 + max(.15 * length(pos.xz)-.3, 0.); // prevent aliasing\\n   \\t\\tmetallic = 1.; \\n    }\\n    \\n    if (metallic > .5) {   \\n        roughness += metalnoise*4.;\\n        albedo *= max(.2, 1.-roughness * .6);\\n    }\\n    \\n    roughness = clamp(roughness, 0.01, 1.);\\n    albedo = clamp(albedo, vec3(0.01), vec3(1.));\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta ) {\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(0.0, 1.0,0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Old watch (RT). Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MlyyzW\\n//\\n// In this buffer the albedo of the dial (red channel) and the roughness\\n// of the glass (green channel) is pre-calculated.\\n//\\n\\nbool resolutionChanged() {\\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\\n}\\n\\nfloat printChar(vec2 uv, uint char) {\\n    float d = textureLod(iChannel1, (uv + vec2( char & 0xFU, 0xFU - (char >> 4))) / 16.,0.).a;\\n\\treturn smoothstep(1.,0., smoothstep(.5,.51,d));\\n}\\n\\nfloat dialSub( in vec2 uv, float wr ) {\\n    float r = length( uv );\\n    float a = atan( uv.y, uv.x )+3.1415926;\\n\\n    float f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\\n    float g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\\n    float w = fwidth(f);\\n    f = 1.0 - smoothstep( 0.2*g+0.05-w, 0.2*g+0.05+w, f );\\n    float s = abs(fwidth(r));\\n    f *= smoothstep( 0.9 - wr -s, 0.9 - wr, r ) - smoothstep( 0.9, 0.9+s, r );\\n    float hwr = wr * .5;\\n    f -= 1.-smoothstep(hwr+s,hwr,abs(r-0.9+hwr)) - smoothstep(hwr-s,hwr,abs(r-0.9+hwr));\\n\\n    return .1 + .8 * clamp(1.-f,0.,1.);\\n}\\n\\nfloat dial(vec2 uv) {\\n    float d = dialSub(uv, 0.05);\\n\\n    vec2 uvs = uv;\\n    \\n    uvs.y += 0.6;\\n    uvs *= 1./(0.85-0.6);\\n\\n    d = min(d, dialSub(uvs, 0.1));\\n    \\n    vec2 center = vec2(0.5);\\n    vec2 radius = vec2(3.65, 0.);\\n    \\n    for (int i=0; i<9; i++) {\\n        if(i!=5) {\\n\\t        float a = 6.28318530718 * float(i+4)/12.;\\n    \\t    vec2 uvt = clamp(uv * 5. + center + rotate(radius, a), vec2(0), vec2(1));\\n        \\td = mix(d, 0.3, printChar(uvt, uint(49+i)));\\n        }\\n    }\\n    for (int i=0; i<3; i++) {\\n\\t    float a = 6.28318530718 * float(i+13)/12.;\\n    \\tvec2 uvt1 = clamp(uv * 5. + center + rotate(radius, a) + vec2(.25,0.), vec2(0), vec2(1));\\n        d = mix(d, 0.3, printChar(uvt1, uint(49)));\\n    \\tvec2 uvt = clamp(uv * 5. + center + rotate(radius, a)+ vec2(-.15,0.), vec2(0), vec2(1));\\n        d = mix(d, 0.3, printChar(uvt, uint(48+i)));\\n    }\\n    \\n    d *= .9 + .25*texture(iChannel2, uv*.5+.5).r;\\n    \\n    return pow(clamp(d, 0., 1.), 2.2);\\n}\\n\\nfloat roughnessGlass(vec2 uv) {\\n    uv = uv * .5 + .5;\\n    return smoothstep(0.2, 0.8, texture(iChannel2, uv * .3).r) * .4 + .2;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \\n    if(resolutionChanged() && iChannelResolution[1].x > 0.  && iChannelResolution[2].x > 0.) {\\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\\n            fragColor = vec4(floor(iResolution.xyx), mod(iDate.w, 12.*60.*60.));\\n        } else {\\n            vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.xy;\\n\\n            fragColor = vec4( dial(uv), roughnessGlass(uv), 0., 1.0 );      \\n        }\\n    } else {\\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Old watch (RT). Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MlyyzW\\n//\\n// A simple path tracer is used to render an old watch. The old watch scene is\\n// (almost) the same scene as rendered using image based lighting in my shader \\"Old\\n// watch (IBL)\\":\\n// \\n// https://www.shadertoy.com/view/lscBW4\\n//\\n// I'm no expert in ray- or path-tracing so there are probably a lot of errors in this code.\\n//\\n\\n#define PATH_LENGTH 5\\n\\nvec3 getBGColor( vec3 N ) {\\n    if (N.y <= 0.) {\\n        return vec3(0.); \\n    } else {\\n\\t    return (.25 + pow(textureLod(iChannel0, N, 0.).rgb, vec3(6.5)) * 8.5) * (N.y) * .3;\\n    }\\n}\\n\\nfloat FresnelSchlickRoughness(float cosTheta, float F0, float roughness) {\\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\\n}\\n\\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n    \\n\\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\\n\\tvec3  vv = cross(uu, n);\\n\\t\\n\\tfloat ra = sqrt(r.y);\\n\\tfloat rx = ra*cos(6.2831*r.x); \\n\\tfloat ry = ra*sin(6.2831*r.x);\\n\\tfloat rz = sqrt( abs(1.0-r.y) );\\n\\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\\n    \\n    return normalize(rr);\\n}\\n\\nvec3 modifyDirectionWithRoughness( const vec3 n, const float roughness, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n    \\n\\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\\n\\tvec3  vv = cross(uu, n);\\n\\t\\n    float a = roughness*roughness;\\n    a *= a; a *= a; // I want to have a really shiny watch.\\n\\tfloat rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));\\n\\tfloat ra = sqrt(abs(1.-rz*rz));\\n\\tfloat rx = ra*cos(6.2831*r.x); \\n\\tfloat ry = ra*sin(6.2831*r.x);\\n\\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\\n    \\n    return normalize(rr);\\n}\\n\\nvec2 randomInUnitDisk(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r*vec2(sin(phi),cos(phi));\\n}\\n\\n//\\n// main \\n//\\n\\nvec3 render( in vec3 ro, in vec3 rd, inout float seed ) {\\n    vec3 col = vec3(1.); \\n    vec3 firstPos = vec3(100.);\\n    bool firstHit = false;\\n    \\n    for (int i=0; i<PATH_LENGTH; ++i) {    \\n    \\tvec2 res = castRay( ro, rd );\\n\\t\\tfloat gd = castRayGlass( ro, rd );\\n        \\n\\t\\tvec3 gpos = ro + rd * gd;\\n\\t\\tvec3 gN = calcNormalGlass(gpos);\\n        \\n        if (gd > 0. && (res.x < 0. || gd < res.x) && dot(gN, rd) < 0.) {\\n            // Glass material. \\n            // Not correct: I only handle rays that enter the glass and the glass\\n            // is modelled as one solid piece, instead as a thin layer. By using a\\n            // non-physically plausible refraction index of 1.25, it still looks\\n            // good (I think).\\n            float F = FresnelSchlickRoughness(max(0., dot(-gN, rd)), (0.08), 0.);\\n            if (F < hash1(seed)) {\\n                rd = refract(rd, gN, 1./1.25);\\n            } else {\\n                rd = reflect(rd, gN);\\n            }\\n            ro = gpos;\\n        }\\n        else if (res.x > 0.) {\\n\\t\\t\\tvec3 pos = ro + rd * res.x;\\n\\t\\t\\tvec3 N, albedo;\\n            float roughness, metallic;\\n\\n\\t\\t\\tgetMaterialProperties(pos, res.y, N, albedo, roughness, metallic, iChannel1, iChannel2, iChannel3);\\n\\n            float F = FresnelSchlickRoughness(max(0., -dot(N, rd)), 0.04, roughness);\\n            \\n            ro = pos;\\n            if (F > hash1(seed) - metallic) { // Reflections and metals.\\n                if (metallic > .5) {\\n                    col *= albedo; \\n                }\\n\\t\\t\\t\\trd = modifyDirectionWithRoughness(reflect(rd,N), roughness, seed);            \\n                if (dot(rd, N) <= 0.) {\\n                    rd = cosWeightedRandomHemisphereDirection(N, seed);\\n                }\\n            } else { // Diffuse\\n\\t\\t\\t\\tcol *= albedo;\\n\\t\\t\\t\\trd = cosWeightedRandomHemisphereDirection(N, seed);\\n            }\\n        } else {\\n            col *= getBGColor(rd);\\n\\t\\t\\tcol *= max(0.0, min(1.1, 10./dot(firstPos,firstPos)) - .15);\\n\\t\\t\\treturn col;\\n        }            \\n        if (!firstHit) {\\n            firstHit = true;\\n            firstPos = ro;\\n        }\\n    }  \\n    return vec3(0.);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    bool reset = iFrame == 0;\\n    ivec2 f = ivec2(fragCoord);\\n    vec4 data1 = texelFetch(iChannel3, ivec2(0), 0);\\n    vec4 data2 = texelFetch(iChannel2, ivec2(0), 0);\\n    \\n    vec2 uv = fragCoord/iResolution.xy;\\n    vec2 mo = abs(iMouse.xy)/iResolution.xy - .5;\\n    if (iMouse.xy == vec2(0)) mo = vec2(.05,.1);\\n    \\n    if (floor(mo*iResolution.xy*10.) != data1.yz) {\\n        reset = true;\\n    }\\n    if (data2.xy != iResolution.xy) {\\n        reset = true;\\n    }\\n    \\n    TIME = data2.w;\\n    \\n    float a = 5.05;\\n    vec3 ro = vec3( .25+ 2.*cos(6.0*mo.x+a), 2. + 2. * mo.y, 2.0*sin(6.0*mo.x+a) );\\n    vec3 ta = vec3( .25, .5, 0.0 );\\n    mat3 ca = setCamera( ro, ta );\\n\\n    float fpd = data1.x;\\n    if(all(equal(f, ivec2(0)))) {\\n        // Calculate focus plane and store distance.\\n        float nfpd = castRay(ro, normalize(vec3(0.,.2,0.)-ro)).x;\\n\\t\\tfragColor = vec4(nfpd, floor(mo*iResolution.xy*10.), iResolution.x);\\n        return;\\n    }\\n    \\n    vec2 p = (-iResolution.xy + 2.0*fragCoord - 1.)/iResolution.y;\\n    float seed = float(baseHash(floatBitsToUint(p)))/float(0xffffffffU) + iTime;\\n\\n    // AA\\n\\tp += 2.*hash2(seed)/iResolution.y;\\n    vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \\n    \\n    // DOF\\n    vec3 fp = ro + rd * fpd;\\n    ro = ro + ca * vec3(randomInUnitDisk(seed), 0.)*.02;\\n    rd = normalize(fp - ro);\\n    \\n    vec3 col = render(ro, rd, seed);           \\n  \\n    if (reset) {\\n       fragColor = vec4(col, 1.0);\\n    } else {\\n       fragColor = vec4(col, 1.0) + texelFetch(iChannel3, ivec2(fragCoord), 0);\\n    }\\n}\\n","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"llVcDz","date":"1536012316","viewed":5646,"name":"RIOW 1.07: Diffuse","description":"These shaders are my implementation of the ray/path tracer described in the book \\"Raytracing in one weekend\\" by Peter Shirley. I have tried to follow the code from his book as much as possible.","likes":19,"published":"Public API","usePreview":0,"tags":["raytracing","ray","tracer","one","in","path","7","weekend","chapter"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raytracing in one weekend, chapter 7: Diffuse. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/llVcDz\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Raytracing in one weekend\\" [1] by Peter Shirley (@Peter_shirley). I have tried \\n// to follow the code from his book as much as possible, but I had to make some changes \\n// to get it running in a fragment shader:\\n//\\n// - There are no classes (and methods) in glsl so I use structs and functions instead. \\n//   Inheritance is implemented by adding a type variable to the struct and adding ugly \\n//   if/else statements to the (not so overloaded) functions.\\n// - The scene description is procedurally implemented in the world_hit function to save\\n//   memory.\\n// - The color function is implemented using a loop because it is not possible to have a \\n//   recursive function call in glsl.\\n// - Only one sample per pixel per frame is calculated. Samples of all frames are added \\n//   in Buffer A and averaged in the Image tab.\\n//\\n// You can find the raytracer / pathtracer in Buffer A.\\n//\\n// = Ray tracing in one week =\\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\\n//\\n// = Ray tracing: the next week =\\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Raytracing in one weekend, chapter 7: Diffuse. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/llVcDz\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Raytracing in one weekend\\" [1] by Peter Shirley (@Peter_shirley). I have tried \\n// to follow the code from his book as much as possible.\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\n#define MAX_FLOAT 1e5\\n#define MAX_RECURSION 5\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint base_hash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat g_seed = 0.;\\n\\nvec2 hash2(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Ray trace helper functions\\n//\\n\\nfloat schlick(float cosine, float ior) {\\n    float r0 = (1.-ior)/(1.+ior);\\n    r0 = r0*r0;\\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\\n}\\n\\nvec3 random_in_unit_sphere(inout float seed) {\\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\\n    float phi = h.y;\\n    float r = pow(h.z, 1./3.);\\n\\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\n//\\n// Ray\\n//\\n\\nstruct ray {\\n    vec3 origin, direction;\\n};\\n    \\n//\\n// Hit record\\n//\\n\\nstruct hit_record {\\n    float t;\\n    vec3 p, normal;\\n};\\n\\n//\\n// Hitable, for now this is always a sphere\\n//\\n\\nstruct hitable {\\n    vec3 center;\\n    float radius;\\n};\\n\\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \\n                 const in float t_max, inout hit_record rec) {\\n    // always a sphere\\n    vec3 oc = r.origin - hb.center;\\n    float b = dot(oc, r.direction);\\n    float c = dot(oc, oc) - hb.radius * hb.radius;\\n    float discriminant = b * b - c;\\n    if (discriminant < 0.0) return false;\\n\\n\\tfloat s = sqrt(discriminant);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\tfloat t = t1 < t_min ? t2 : t1;\\n    if (t < t_max && t > t_min) {\\n        rec.t = t;\\n        rec.p = r.origin + t*r.direction;\\n        rec.normal = (rec.p - hb.center) / hb.radius;\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\n//\\n// Camera\\n//\\n\\nstruct camera {\\n    vec3 origin, lower_left_corner, horizontal, vertical;\\n};\\n\\nray camera_get_ray(camera c, vec2 uv) {\\n    return ray(c.origin, \\n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin));\\n}\\n\\n//\\n// Color & Scene\\n//\\n\\nbool world_hit(const in ray r, const in float t_min, const in float t_max, out hit_record rec) {\\n    rec.t = t_max;\\n    bool hit = false;\\n    \\n\\thit = hitable_hit(hitable(vec3(0,0,-1), .5), r, t_min, rec.t, rec) || hit;\\n\\thit = hitable_hit(hitable(vec3(0,-100.5,-1),100.), r, t_min, rec.t, rec) || hit;\\n    \\n    return hit;\\n}\\n\\nvec3 color(in ray r) {\\n    vec3 col = vec3(1);  \\n\\thit_record rec;\\n    \\n    for (int i=0; i<MAX_RECURSION; i++) {\\n    \\tif (world_hit(r, 0.001, MAX_FLOAT, rec)) {\\n        \\tvec3 rd = normalize(rec.normal + random_in_unit_sphere(g_seed));\\n            col *= .5;\\n\\n            r.origin = rec.p;\\n            r.direction = rd;\\n\\t    } else {\\n            float t = .5*r.direction.y + .5;\\n            col *= mix(vec3(1),vec3(.5,.7,1), t);\\n            return col;\\n    \\t}\\n    }\\n    return col;\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\\n    if (ivec2(frag_coord) == ivec2(0)) {\\n        frag_color = iResolution.xyxy;\\n    } else {\\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\\n\\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\\n        float aspect = iResolution.x/iResolution.y;\\n\\n        ray r = camera_get_ray(camera(vec3(0), vec3(-2,-1,-1), vec3(4,0,0), vec3(0,4./aspect,0)), uv);\\n        vec3 col = color(r);\\n        \\n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \\n\\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\\n        } else {        \\n\\t        frag_color = vec4(col,1);\\n        }\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MlVcDz","date":"1536012325","viewed":4591,"name":"RIOW 1.09: Dielectrics","description":"These shaders are my implementation of the ray/path tracer described in the book \\"Raytracing in one weekend\\" by Peter Shirley. I have tried to follow the code from his book as much as possible.","likes":6,"published":"Public API","usePreview":0,"tags":["raytracing","ray","tracer","one","in","path","weekend"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raytracing in one weekend, chapter 9: Dielectrics. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MlVcDz\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Raytracing in one weekend\\" [1] by Peter Shirley (@Peter_shirley). I have tried \\n// to follow the code from his book as much as possible, but I had to make some changes \\n// to get it running in a fragment shader:\\n//\\n// - There are no classes (and methods) in glsl so I use structs and functions instead. \\n//   Inheritance is implemented by adding a type variable to the struct and adding ugly \\n//   if/else statements to the (not so overloaded) functions.\\n// - The scene description is procedurally implemented in the world_hit function to save\\n//   memory.\\n// - The color function is implemented using a loop because it is not possible to have a \\n//   recursive function call in glsl.\\n// - Only one sample per pixel per frame is calculated. Samples of all frames are added \\n//   in Buffer A and averaged in the Image tab.\\n//\\n// You can find the raytracer / pathtracer in Buffer A.\\n//\\n// = Ray tracing in one week =\\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\\n//\\n// = Ray tracing: the next week =\\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Raytracing in one weekend, chapter 9: Dielectrics. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MlVcDz\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Raytracing in one weekend\\" [1] by Peter Shirley (@Peter_shirley). I have tried \\n// to follow the code from his book as much as possible.\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\n#define MAX_FLOAT 1e5\\n#define MAX_RECURSION (16+min(0,iFrame))\\n\\n#define LAMBERTIAN 0\\n#define METAL 1\\n#define DIELECTRIC 2\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint base_hash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat g_seed = 0.;\\n\\nfloat hash1(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    return float(n)*(1.0/float(0xffffffffU));\\n}\\n\\nvec2 hash2(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Ray trace helper functions\\n//\\n\\nfloat schlick(float cosine, float ior) {\\n    float r0 = (1.-ior)/(1.+ior);\\n    r0 = r0*r0;\\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\\n}\\n\\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \\n                      out vec3 refracted) {\\n    float dt = dot(v, n);\\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\\n    if (discriminant > 0.) {\\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\\n        return true;\\n    } else { \\n        return false;\\n    }\\n}\\n\\nvec3 random_in_unit_sphere(inout float seed) {\\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\\n    float phi = h.y;\\n    float r = pow(h.z, 1./3.);\\n\\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\n//\\n// Ray\\n//\\n\\nstruct ray {\\n    vec3 origin, direction;\\n};\\n\\n//\\n// Material\\n//\\n\\nstruct material {\\n    int type;\\n    vec3 albedo;\\n    float v;\\n};\\n\\n//\\n// Hit record\\n//\\n\\nstruct hit_record {\\n    float t;\\n    vec3 p, normal;\\n    material mat;\\n};\\n\\nbool material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \\n                      out ray scattered) {\\n    if(rec.mat.type == LAMBERTIAN) {\\n        vec3 rd = normalize(rec.normal + random_in_unit_sphere(g_seed));\\n        scattered = ray(rec.p, rd);\\n        attenuation = rec.mat.albedo;\\n        return true;\\n    } else if(rec.mat.type == METAL) {\\n        vec3 rd = reflect(r_in.direction, rec.normal);\\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)));\\n        attenuation = rec.mat.albedo;\\n        return true;\\n    } else if(rec.mat.type == DIELECTRIC) {\\n        vec3 outward_normal, refracted, \\n             reflected = reflect(r_in.direction, rec.normal);\\n        float ni_over_nt, reflect_prob, cosine;\\n        \\n        attenuation = vec3(1);\\n        if (dot(r_in.direction, rec.normal) > 0.) {\\n            outward_normal = -rec.normal;\\n            ni_over_nt = rec.mat.v;\\n            cosine = dot(r_in.direction, rec.normal);\\n            cosine = sqrt(1. - rec.mat.v*rec.mat.v*(1.-cosine*cosine));\\n        } else {\\n            outward_normal = rec.normal;\\n            ni_over_nt = 1. / rec.mat.v;\\n            cosine = -dot(r_in.direction, rec.normal);\\n        }\\n        \\n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\\n\\t        reflect_prob = schlick(cosine, rec.mat.v);\\n        } else {\\n            reflect_prob = 1.;\\n        }\\n        \\n        if (hash1(g_seed) < reflect_prob) {\\n            scattered = ray(rec.p, reflected);\\n        } else {\\n            scattered = ray(rec.p, refracted);\\n        }\\n        return true;\\n    }\\n    return false;\\n}\\n\\n//\\n// Hitable, for now this is always a sphere\\n//\\n\\nstruct hitable {\\n    vec3 center;\\n    float radius;\\n};\\n\\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \\n                 const in float t_max, inout hit_record rec) {\\n    // always a sphere\\n    vec3 oc = r.origin - hb.center;\\n    float b = dot(oc, r.direction);\\n    float c = dot(oc, oc) - hb.radius * hb.radius;\\n    float discriminant = b * b - c;\\n    if (discriminant < 0.0) return false;\\n\\n\\tfloat s = sqrt(discriminant);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\tfloat t = t1 < t_min ? t2 : t1;\\n    if (t < t_max && t > t_min) {\\n        rec.t = t;\\n        rec.p = r.origin + t*r.direction;\\n        rec.normal = (rec.p - hb.center) / hb.radius;\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\n//\\n// Camera\\n//\\n\\nstruct camera {\\n    vec3 origin, lower_left_corner, horizontal, vertical;\\n};\\n\\nray camera_get_ray(camera c, vec2 uv) {\\n    return ray(c.origin, \\n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin));\\n}\\n\\n//\\n// Color & Scene\\n//\\n\\nbool world_hit(const in ray r, const in float t_min, \\n               const in float t_max, out hit_record rec) {\\n    rec.t = t_max;\\n    bool hit = false;\\n    \\n\\tif (hitable_hit(hitable(vec3(0,0,-1),.5),r,t_min,rec.t,rec))        hit=true,rec.mat=material(LAMBERTIAN,vec3(.1,.2,.5),0.);\\n\\tif (hitable_hit(hitable(vec3(0,-100.5,-1),100.),r,t_min,rec.t,rec)) hit=true,rec.mat=material(LAMBERTIAN,vec3(.8,.8,0),0.);\\n\\tif (hitable_hit(hitable(vec3(1,0,-1),.5),r,t_min,rec.t,rec))        hit=true,rec.mat=material(METAL     ,vec3(.8,.6,.2),.2);\\n\\tif (hitable_hit(hitable(vec3(-1,0,-1),.5),r,t_min,rec.t,rec))       hit=true,rec.mat=material(DIELECTRIC,vec3(0),1.5);\\n\\tif (hitable_hit(hitable(vec3(-1,0,-1),-.45),r,t_min,rec.t,rec))     hit=true,rec.mat=material(DIELECTRIC,vec3(0),1.5);\\n    \\n    return hit;\\n}\\n\\nvec3 color(in ray r) {\\n    vec3 col = vec3(1);  \\n\\thit_record rec;\\n    \\n    for (int i=0; i<MAX_RECURSION; i++) {\\n    \\tif (world_hit(r, 0.001, MAX_FLOAT, rec)) {\\n            ray scattered;\\n            vec3 attenuation;\\n            if (material_scatter(r, rec, attenuation, scattered)) {\\n                col *= attenuation;\\n                r = scattered;\\n            } else {\\n                return vec3(0);\\n            }\\n\\t    } else {\\n            float t = .5*r.direction.y + .5;\\n            col *= mix(vec3(1),vec3(.5,.7,1), t);\\n            return col;\\n    \\t}\\n    }\\n    return vec3(0);\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\\n    if (ivec2(frag_coord) == ivec2(0)) {\\n        frag_color = iResolution.xyxy;\\n    } else {\\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\\n\\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\\n        float aspect = iResolution.x/iResolution.y;\\n\\n        ray r = camera_get_ray(camera(vec3(0), vec3(-2,-1,-1), vec3(4,0,0), vec3(0,4./aspect,0)), uv);\\n        vec3 col = color(r);\\n        \\n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \\n\\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\\n        } else {        \\n\\t        frag_color = vec4(col,1);\\n        }\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XlGcWh","date":"1536012335","viewed":4948,"name":"RIOW 1.11: Defocus Blur","description":"These shaders are my implementation of the ray/path tracer described in the book \\"Raytracing in one weekend\\" by Peter Shirley. I have tried to follow the code from his book as much as possible.","likes":13,"published":"Public API","usePreview":0,"tags":["raytracing","ray","tracer","one","in","path","weekend"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raytracing in one weekend, chapter 11: Defocus Blur. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XlGcWh\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Raytracing in one weekend\\" [1] by Peter Shirley (@Peter_shirley). I have tried \\n// to follow the code from his book as much as possible, but I had to make some changes \\n// to get it running in a fragment shader:\\n//\\n// - There are no classes (and methods) in glsl so I use structs and functions instead. \\n//   Inheritance is implemented by adding a type variable to the struct and adding ugly \\n//   if/else statements to the (not so overloaded) functions.\\n// - The scene description is procedurally implemented in the world_hit function to save\\n//   memory.\\n// - The color function is implemented using a loop because it is not possible to have a \\n//   recursive function call in glsl.\\n// - Only one sample per pixel per frame is calculated. Samples of all frames are added \\n//   in Buffer A and averaged in the Image tab.\\n//\\n// You can find the raytracer / pathtracer in Buffer A.\\n//\\n// = Ray tracing in one week =\\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\\n//\\n// = Ray tracing: the next week =\\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Raytracing in one weekend, chapter 11: Defocus Blur. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XlGcWh\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Raytracing in one weekend\\" [1] by Peter Shirley (@Peter_shirley). I have tried \\n// to follow the code from his book as much as possible.\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\n#define MAX_FLOAT 1e5\\n#define MAX_RECURSION (16+min(0,iFrame))\\n\\n#define LAMBERTIAN 0\\n#define METAL 1\\n#define DIELECTRIC 2\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint base_hash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat g_seed = 0.;\\n\\nfloat hash1(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    return float(n)*(1.0/float(0xffffffffU));\\n}\\n\\nvec2 hash2(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Ray trace helper functions\\n//\\n\\nfloat schlick(float cosine, float ior) {\\n    float r0 = (1.-ior)/(1.+ior);\\n    r0 = r0*r0;\\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\\n}\\n\\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \\n                      out vec3 refracted) {\\n    float dt = dot(v, n);\\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\\n    if (discriminant > 0.) {\\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\\n        return true;\\n    } else { \\n        return false;\\n    }\\n}\\n\\nvec2 random_in_unit_disk(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r * vec2(sin(phi),cos(phi));\\n}\\n\\nvec3 random_in_unit_sphere(inout float seed) {\\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\\n    float phi = h.y;\\n    float r = pow(h.z, 1./3.);\\n\\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\n//\\n// Ray\\n//\\n\\nstruct ray {\\n    vec3 origin, direction;\\n};\\n\\n//\\n// Material\\n//\\n\\nstruct material {\\n    int type;\\n    vec3 albedo;\\n    float v;\\n};\\n\\n//\\n// Hit record\\n//\\n\\nstruct hit_record {\\n    float t;\\n    vec3 p, normal;\\n    material mat;\\n};\\n\\nbool material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \\n                      out ray scattered) {\\n    if(rec.mat.type == LAMBERTIAN) {\\n        vec3 rd = normalize(rec.normal + random_in_unit_sphere(g_seed));\\n        scattered = ray(rec.p, rd);\\n        attenuation = rec.mat.albedo;\\n        return true;\\n    } else if(rec.mat.type == METAL) {\\n        vec3 rd = reflect(r_in.direction, rec.normal);\\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)));\\n        attenuation = rec.mat.albedo;\\n        return true;\\n    } else if(rec.mat.type == DIELECTRIC) {\\n        vec3 outward_normal, refracted, \\n             reflected = reflect(r_in.direction, rec.normal);\\n        float ni_over_nt, reflect_prob, cosine;\\n        \\n        attenuation = vec3(1);\\n        if (dot(r_in.direction, rec.normal) > 0.) {\\n            outward_normal = -rec.normal;\\n            ni_over_nt = rec.mat.v;\\n            cosine = dot(r_in.direction, rec.normal);\\n            cosine = sqrt(1. - rec.mat.v*rec.mat.v*(1.-cosine*cosine));\\n        } else {\\n            outward_normal = rec.normal;\\n            ni_over_nt = 1. / rec.mat.v;\\n            cosine = -dot(r_in.direction, rec.normal);\\n        }\\n        \\n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\\n\\t        reflect_prob = schlick(cosine, rec.mat.v);\\n        } else {\\n            reflect_prob = 1.;\\n        }\\n        \\n        if (hash1(g_seed) < reflect_prob) {\\n            scattered = ray(rec.p, reflected);\\n        } else {\\n            scattered = ray(rec.p, refracted);\\n        }\\n        return true;\\n    }\\n    return false;\\n}\\n\\n//\\n// Hitable, for now this is always a sphere\\n//\\n\\nstruct hitable {\\n    vec3 center;\\n    float radius;\\n};\\n\\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \\n                 const in float t_max, inout hit_record rec) {\\n    // always a sphere\\n    vec3 oc = r.origin - hb.center;\\n    float b = dot(oc, r.direction);\\n    float c = dot(oc, oc) - hb.radius * hb.radius;\\n    float discriminant = b * b - c;\\n    if (discriminant < 0.0) return false;\\n\\n\\tfloat s = sqrt(discriminant);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\tfloat t = t1 < t_min ? t2 : t1;\\n    if (t < t_max && t > t_min) {\\n        rec.t = t;\\n        rec.p = r.origin + t*r.direction;\\n        rec.normal = (rec.p - hb.center) / hb.radius;\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\n//\\n// Camera\\n//\\n\\nstruct camera {\\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\\n    float lens_radius;\\n};\\n\\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \\n                    const in float vfov, const in float aspect, const in float aperture, \\n                    const in float focus_dist) {\\n    camera cam;    \\n    cam.lens_radius = aperture / 2.;\\n    float theta = vfov*3.14159265359/180.;\\n    float half_height = tan(theta/2.);\\n    float half_width = aspect * half_height;\\n    cam.origin = lookfrom;\\n    cam.w = normalize(lookfrom - lookat);\\n    cam.u = normalize(cross(vup, cam.w));\\n    cam.v = cross(cam.w, cam.u);\\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\\n    return cam;\\n}\\n    \\nray camera_get_ray(camera c, vec2 uv) {\\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\\n    vec3 offset = c.u * rd.x + c.v * rd.y;\\n    return ray(c.origin + offset, \\n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset));\\n}\\n\\n//\\n// Color & Scene\\n//\\n\\nbool world_hit(const in ray r, const in float t_min, \\n               const in float t_max, out hit_record rec) {\\n    rec.t = t_max;\\n    bool hit = false;\\n    \\n\\tif (hitable_hit(hitable(vec3(0,0,-1),.5),r,t_min,rec.t,rec))        hit=true,rec.mat=material(LAMBERTIAN,vec3(.1,.2,.5),0.);\\n\\tif (hitable_hit(hitable(vec3(0,-100.5,-1),100.),r,t_min,rec.t,rec)) hit=true,rec.mat=material(LAMBERTIAN,vec3(.8,.8,0),0.);\\n\\tif (hitable_hit(hitable(vec3(1,0,-1),.5),r,t_min,rec.t,rec))        hit=true,rec.mat=material(METAL     ,vec3(.8,.6,.2),0.);\\n\\tif (hitable_hit(hitable(vec3(-1,0,-1),.5),r,t_min,rec.t,rec))       hit=true,rec.mat=material(DIELECTRIC,vec3(0),1.5);\\n\\tif (hitable_hit(hitable(vec3(-1,0,-1),-.45),r,t_min,rec.t,rec))     hit=true,rec.mat=material(DIELECTRIC,vec3(0),1.5);\\n    \\n    return hit;\\n}\\n\\nvec3 color(in ray r) {\\n    vec3 col = vec3(1);  \\n\\thit_record rec;\\n    \\n    for (int i=0; i<MAX_RECURSION; i++) {\\n    \\tif (world_hit(r, 0.001, MAX_FLOAT, rec)) {\\n            ray scattered;\\n            vec3 attenuation;\\n            if (material_scatter(r, rec, attenuation, scattered)) {\\n                col *= attenuation;\\n                r = scattered;\\n            } else {\\n                return vec3(0);\\n            }\\n\\t    } else {\\n            float t = .5*r.direction.y + .5;\\n            col *= mix(vec3(1),vec3(.5,.7,1), t);\\n            return col;\\n    \\t}\\n    }\\n    return vec3(0);\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\\n    if (ivec2(frag_coord) == ivec2(0)) {\\n        frag_color = iResolution.xyxy;\\n    } else {\\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\\n\\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\\n        float aspect = iResolution.x/iResolution.y;\\n        vec3 lookfrom = vec3(3,3,2);\\n        vec3 lookat = vec3(0,0,-1);\\n        \\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 20., aspect, 2., distance(lookfrom,lookat));\\n        ray r = camera_get_ray(cam, uv);\\n        vec3 col = color(r);\\n        \\n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \\n\\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\\n        } else {        \\n\\t        frag_color = vec4(col,1);\\n        }\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XlycWh","date":"1536012353","viewed":6955,"name":"RIOW 1.12: Where next?","description":"These shaders are my implementation of the ray/path tracer described in the book \\"Raytracing in one weekend\\" by Peter Shirley. I have tried to follow the code from his book as much as possible.","likes":33,"published":"Public API","usePreview":0,"tags":["raytracing","ray","tracer","one","in","path","weekend"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raytracing in one weekend, chapter 12: Where next? Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XlycWh\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Raytracing in one weekend\\" [1] by Peter Shirley (@Peter_shirley). I have tried \\n// to follow the code from his book as much as possible, but I had to make some changes \\n// to get it running in a fragment shader:\\n//\\n// - There are no classes (and methods) in glsl so I use structs and functions instead. \\n//   Inheritance is implemented by adding a type variable to the struct and adding ugly \\n//   if/else statements to the (not so overloaded) functions.\\n// - The scene description is procedurally implemented in the world_hit function to save\\n//   memory.\\n// - The color function is implemented using a loop because it is not possible to have a \\n//   recursive function call in glsl.\\n// - Only one sample per pixel per frame is calculated. Samples of all frames are added \\n//   in Buffer A and averaged in the Image tab.\\n//\\n// You can find the raytracer / pathtracer in Buffer A.\\n//\\n// = Ray tracing in one week =\\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\\n//\\n// = Ray tracing: the next week =\\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\\n//\\n// This particular shader can be optimized (a lot) by using an acceleration structure,\\n// as done in my shader \\"More spheres\\": https://www.shadertoy.com/view/lsX3DH\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Raytracing in one weekend, chapter 12: Where next? Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XlycWh\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Raytracing in one weekend\\" [1] by Peter Shirley (@Peter_shirley). I have tried \\n// to follow the code from his book as much as possible.\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\n#define MAX_FLOAT 1e5\\n#define MAX_RECURSION (6+min(0,iFrame))\\n\\n#define LAMBERTIAN 0\\n#define METAL 1\\n#define DIELECTRIC 2\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint base_hash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat g_seed = 0.;\\n\\nfloat hash1(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    return float(n)/float(0xffffffffU);\\n}\\n\\nvec2 hash2(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Ray trace helper functions\\n//\\n\\nfloat schlick(float cosine, float ior) {\\n    float r0 = (1.-ior)/(1.+ior);\\n    r0 = r0*r0;\\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\\n}\\n\\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \\n                      out vec3 refracted) {\\n    float dt = dot(v, n);\\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\\n    if (discriminant > 0.) {\\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\\n        return true;\\n    } else { \\n        return false;\\n    }\\n}\\n\\nvec2 random_in_unit_disk(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r * vec2(sin(phi),cos(phi));\\n}\\n\\nvec3 random_in_unit_sphere(inout float seed) {\\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\\n    float phi = h.y;\\n    float r = pow(h.z, 1./3.);\\n\\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\n//\\n// Ray\\n//\\n\\nstruct ray {\\n    vec3 origin, direction;\\n};\\n\\n//\\n// Material\\n//\\n\\nstruct material {\\n    int type;\\n    vec3 albedo;\\n    float v;\\n};\\n\\n//\\n// Hit record\\n//\\n\\nstruct hit_record {\\n    float t;\\n    vec3 p, normal;\\n    material mat;\\n};\\n\\nbool material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \\n                      out ray scattered) {\\n    if(rec.mat.type == LAMBERTIAN) {\\n        vec3 rd = normalize(rec.normal + random_in_unit_sphere(g_seed));\\n        scattered = ray(rec.p, rd);\\n        attenuation = rec.mat.albedo;\\n        return true;\\n    } else if(rec.mat.type == METAL) {\\n        vec3 rd = reflect(r_in.direction, rec.normal);\\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)));\\n        attenuation = rec.mat.albedo;\\n        return true;\\n    } else if(rec.mat.type == DIELECTRIC) {\\n        vec3 outward_normal, refracted, \\n             reflected = reflect(r_in.direction, rec.normal);\\n        float ni_over_nt, reflect_prob, cosine;\\n        \\n        attenuation = vec3(1);\\n        if (dot(r_in.direction, rec.normal) > 0.) {\\n            outward_normal = -rec.normal;\\n            ni_over_nt = rec.mat.v;\\n            cosine = dot(r_in.direction, rec.normal);\\n            cosine = sqrt(1. - rec.mat.v*rec.mat.v*(1.-cosine*cosine));\\n        } else {\\n            outward_normal = rec.normal;\\n            ni_over_nt = 1. / rec.mat.v;\\n            cosine = -dot(r_in.direction, rec.normal);\\n        }\\n        \\n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\\n\\t        reflect_prob = schlick(cosine, rec.mat.v);\\n        } else {\\n            reflect_prob = 1.;\\n        }\\n        \\n        if (hash1(g_seed) < reflect_prob) {\\n            scattered = ray(rec.p, reflected);\\n        } else {\\n            scattered = ray(rec.p, refracted);\\n        }\\n        return true;\\n    }\\n    return false;\\n}\\n\\n//\\n// Hitable, for now this is always a sphere\\n//\\n\\nstruct hitable {\\n    vec3 center;\\n    float radius;\\n};\\n\\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \\n                 const in float t_max, inout hit_record rec) {\\n    // always a sphere\\n    vec3 oc = r.origin - hb.center;\\n    float b = dot(oc, r.direction);\\n    float c = dot(oc, oc) - hb.radius * hb.radius;\\n    float discriminant = b * b - c;\\n    if (discriminant < 0.0) return false;\\n\\n\\tfloat s = sqrt(discriminant);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\tfloat t = t1 < t_min ? t2 : t1;\\n    if (t < t_max && t > t_min) {\\n        rec.t = t;\\n        rec.p = r.origin + t*r.direction;\\n        rec.normal = (rec.p - hb.center) / hb.radius;\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\n//\\n// Camera\\n//\\n\\nstruct camera {\\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\\n    float lens_radius;\\n};\\n\\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \\n                    const in float vfov, const in float aspect, const in float aperture, \\n                    const in float focus_dist) {\\n    camera cam;    \\n    cam.lens_radius = aperture / 2.;\\n    float theta = vfov*3.14159265359/180.;\\n    float half_height = tan(theta/2.);\\n    float half_width = aspect * half_height;\\n    cam.origin = lookfrom;\\n    cam.w = normalize(lookfrom - lookat);\\n    cam.u = normalize(cross(vup, cam.w));\\n    cam.v = cross(cam.w, cam.u);\\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\\n    return cam;\\n}\\n    \\nray camera_get_ray(camera c, vec2 uv) {\\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\\n    vec3 offset = c.u * rd.x + c.v * rd.y;\\n    return ray(c.origin + offset, \\n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset));\\n}\\n\\n//\\n// Color & Scene\\n//\\n\\nbool world_hit(const in ray r, const in float t_min, \\n               const in float t_max, out hit_record rec) {\\n    rec.t = t_max;\\n    bool hit = false;\\n\\n  \\tif (hitable_hit(hitable(vec3(0,-1000,-1),1000.),r,t_min,rec.t,rec)) hit=true,rec.mat=material(LAMBERTIAN,vec3(.5),0.);\\n\\n  \\tif (hitable_hit(hitable(vec3( 0,1,0),1.),r,t_min,rec.t,rec))        hit=true,rec.mat=material(DIELECTRIC,vec3(0),1.5);\\n    if (hitable_hit(hitable(vec3(-4,1,0),1.),r,t_min,rec.t,rec))        hit=true,rec.mat=material(LAMBERTIAN,vec3(.4,.2,.1),0.);\\n\\tif (hitable_hit(hitable(vec3( 4,1,0),1.),r,t_min,rec.t,rec))        hit=true,rec.mat=material(METAL     ,vec3(.7,.6,.5),0.);\\n    \\n    int NO_UNROLL = min(0,iFrame);\\n    for (int a = -11; a < 11+NO_UNROLL; a++) {\\n        for (int b = -11; b < 11+NO_UNROLL; b++) {\\n            float m_seed = float(a) + float(b)/1000.;\\n            vec3 rand1 = hash3(m_seed);            \\n            vec3 center = vec3(float(a)+.9*rand1.x,.2,float(b)+.9*rand1.y); \\n            float choose_mat = rand1.z;\\n            \\n            if (distance(center,vec3(4,.2,0)) > .9) {\\n                if (choose_mat < .8) { // diffuse\\n                    if (hitable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\\n                        hit=true, rec.mat=material(LAMBERTIAN, hash3(m_seed)* hash3(m_seed),0.);\\n                    }\\n                } else if (choose_mat < 0.95) { // metal\\n                    if (hitable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\\n                        hit=true, rec.mat=material(METAL,.5*(hash3(m_seed)+1.),.5*hash1(m_seed));\\n                    }\\n                } else { // glass\\n                    if (hitable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\\n                        hit=true, rec.mat=material(DIELECTRIC,vec3(0),1.5);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return hit;\\n}\\n\\nvec3 color(in ray r) {\\n    vec3 col = vec3(1);  \\n\\thit_record rec;\\n    \\n    for (int i=0; i<MAX_RECURSION; i++) {\\n    \\tif (world_hit(r, 0.001, MAX_FLOAT, rec)) {\\n            ray scattered;\\n            vec3 attenuation;\\n            if (material_scatter(r, rec, attenuation, scattered)) {\\n                col *= attenuation;\\n                r = scattered;\\n            } else {\\n                return vec3(0);\\n            }\\n\\t    } else {\\n            float t = .5*r.direction.y + .5;\\n            col *= mix(vec3(1),vec3(.5,.7,1), t);\\n            return col;\\n    \\t}\\n    }\\n    return vec3(0);\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\\n    if (ivec2(frag_coord) == ivec2(0)) {\\n        frag_color = iResolution.xyxy;\\n    } else {\\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\\n\\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\\n        float aspect = iResolution.x/iResolution.y;\\n        vec3 lookfrom = vec3(13,2,3);\\n        vec3 lookat = vec3(0);\\n        \\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 20., aspect, .1, 10.);\\n        ray r = camera_get_ray(cam, uv);\\n        vec3 col = color(r);\\n        \\n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \\n\\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\\n        } else {        \\n\\t        frag_color = vec4(col,1);\\n        }\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4tGcWD","date":"1536332983","viewed":3808,"name":"RIOW 2.06: Rectangles and lights","description":"These shaders are my implementation of the ray/path tracer described in the book \\"Raytracing in one weekend\\" by Peter Shirley. Note: I didn't implement Perlin noise but used value noise instead.","likes":17,"published":"Public API","usePreview":0,"tags":["raytracing","ray","tracer","one","in","path","weekend"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray tracing: the next week, chapter 6: Rectangles and lights. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4tGcWD\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Ray tracing in one weekend\\" and \\"Ray tracing: the next week\\"[1] by Peter Shirley \\n// (@Peter_shirley). I have tried to follow the code from his book as much as possible, but \\n// I had to make some changes to get it running in a fragment shader:\\n//\\n// - There are no classes (and methods) in glsl so I use structs and functions instead. \\n//   Inheritance is implemented by adding a type variable to the struct and adding ugly \\n//   if/else statements to the (not so overloaded) functions.\\n// - The scene description is procedurally implemented in the world_hit function to save\\n//   memory.\\n// - The color function is implemented using a loop because it is not possible to have a \\n//   recursive function call in glsl.\\n// - Only one sample per pixel per frame is calculated. Samples of all frames are added \\n//   in Buffer A and averaged in the Image tab.\\n//\\n// Besides that, I also made some other design choices. Most notably:\\n//\\n// - In my code ray.direction is always a unit vector so I could clean up the rest of\\n//   the code by removing some implicit normalizations.\\n// - Cosine weighted hemisphere sampling is used for the Lambertian material.\\n//\\n// You can find the raytracer / pathtracer in Buffer A.\\n//\\n// = Ray tracing in one week =\\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\\n//\\n// = Ray tracing: the next week =\\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Ray tracing: the next week, chapter 6: Rectangles and lights. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/4tGcWD\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Ray tracing in one weekend\\" and \\"Ray tracing: the next week\\"[1] by Peter Shirley \\n// (@Peter_shirley). I have tried to follow the code from his book as much as possible.\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\n#define MAX_FLOAT 1e5\\n#define EPSILON 0.0001\\n#define MAX_RECURSION (6+min(0,iFrame))\\n\\n#define LAMBERTIAN 0\\n#define METAL 1\\n#define DIELECTRIC 2\\n#define DIFFUSE_LIGHT 3\\n\\n#define SPHERE 0\\n#define MOVING_SPHERE 1\\n#define BOX 2\\n\\n#define SOLID 0\\n#define NOISE 1\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint base_hash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat g_seed = 0.;\\n\\nfloat hash1(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    return float(n)/float(0xffffffffU);\\n}\\n\\nvec2 hash2(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Noise functions by Inigo Quilez:\\n// https://www.shadertoy.com/view/4sfGzS\\n//\\n\\nfloat hash(vec3 p) {\\n    p  = fract( p*0.3183099+.1 );\\n\\tp *= 17.0;\\n    return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\\n}\\n\\nfloat noise(const in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n\\t\\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \\n                        hash(p+vec3(1,0,0)),f.x),\\n                   mix( hash(p+vec3(0,1,0)), \\n                        hash(p+vec3(1,1,0)),f.x),f.y),\\n               mix(mix( hash(p+vec3(0,0,1)), \\n                        hash(p+vec3(1,0,1)),f.x),\\n                   mix( hash(p+vec3(0,1,1)), \\n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\\n}\\n\\nfloat fbm(const in vec3 p, const in int octaves) {\\n    float accum = 0.;\\n    vec3 temp_p = p;\\n    float weight = 1.;\\n     \\n    for (int i=0; i<octaves; i++) {\\n        accum += weight * noise(temp_p);\\n        weight *= .5;\\n        temp_p *= 2.;\\n    }\\n    return abs(accum);\\n}\\n\\n//\\n// Ray trace helper functions\\n//\\n\\nfloat schlick(float cosine, float ior) {\\n    float r0 = (1.-ior)/(1.+ior);\\n    r0 = r0*r0;\\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\\n}\\n\\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \\n                      out vec3 refracted) {\\n    float dt = dot(v, n);\\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\\n    if (discriminant > 0.) {\\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\\n        return true;\\n    } else { \\n        return false;\\n    }\\n}\\n\\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n\\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\\n\\tvec3  vv = cross(uu, n);\\n\\tfloat ra = sqrt(r.y);\\n\\tfloat rx = ra*cos(6.28318530718*r.x); \\n\\tfloat ry = ra*sin(6.28318530718*r.x);\\n\\tfloat rz = sqrt(1.-r.y);\\n\\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\\n    return normalize(rr);\\n}\\n\\nvec2 random_in_unit_disk(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r * vec2(sin(phi),cos(phi));\\n}\\n\\nvec3 random_in_unit_sphere(inout float seed) {\\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\\n    float phi = h.y;\\n    float r = pow(h.z, 1./3.);\\n\\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\n//\\n// Ray\\n//\\n\\nstruct ray {\\n    vec3 origin, direction;\\n    float time;\\n};\\n\\n//\\n// Texture\\n//\\n\\nstruct texture_ {\\n    int type;\\n    vec3 v;\\n};\\n\\nvec3 texture_value(const in texture_ t, const in vec3 p) {\\n    if (t.type == SOLID) {\\n\\t    return t.v;\\n    } else if (t.type == NOISE) {\\n        return vec3(.5*(1. + sin(t.v.x*p.z + 5.*fbm((t.v.x*.5)*p, 7))));\\n    }\\n}\\n\\n#define NO_TEX texture_(SOLID,vec3(0))\\n\\n//\\n// Material\\n//\\n\\nstruct material {\\n    int type;\\n    texture_ albedo;\\n    texture_ emit;\\n    float v;\\n};\\n\\n//\\n// Hit record\\n//\\n\\nstruct hit_record {\\n    float t;\\n    vec3 p, normal;\\n    material mat;\\n};\\n\\nbool material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \\n                      out ray scattered) {\\n    if(rec.mat.type == LAMBERTIAN) {\\n        scattered = ray(rec.p, random_cos_weighted_hemisphere_direction(rec.normal, g_seed), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n        return true;\\n    } else if(rec.mat.type == METAL) {\\n        vec3 rd = reflect(r_in.direction, rec.normal);\\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n        return true;\\n    } else if(rec.mat.type == DIELECTRIC) {\\n        vec3 outward_normal, refracted, \\n             reflected = reflect(r_in.direction, rec.normal);\\n        float ni_over_nt, reflect_prob, cosine;\\n        \\n        attenuation = vec3(1);\\n        if (dot(r_in.direction, rec.normal) > 0.) {\\n            outward_normal = -rec.normal;\\n            ni_over_nt = rec.mat.v;\\n            cosine = dot(r_in.direction, rec.normal);\\n            cosine = sqrt(1. - rec.mat.v*rec.mat.v*(1.-cosine*cosine));\\n        } else {\\n            outward_normal = rec.normal;\\n            ni_over_nt = 1. / rec.mat.v;\\n            cosine = -dot(r_in.direction, rec.normal);\\n        }\\n        \\n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\\n\\t        reflect_prob = schlick(cosine, rec.mat.v);\\n        } else {\\n            reflect_prob = 1.;\\n        }\\n        \\n        if (hash1(g_seed) < reflect_prob) {\\n            scattered = ray(rec.p, reflected, r_in.time);\\n        } else {\\n            scattered = ray(rec.p, refracted, r_in.time);\\n        }\\n        return true;\\n    }\\n    return false;\\n}\\n\\nvec3 material_emitted(const in hit_record rec) {\\n    if (rec.mat.type == DIFFUSE_LIGHT) {\\n        return texture_value(rec.mat.emit, rec.p);\\n    } else {\\n        return vec3(0);\\n    }\\n}\\n\\n//\\n// Hitable\\n//\\n\\nstruct hitable {\\n    int type;\\n    vec3 center, v3; // v3 is speed for moving sphere (with center at t=0) \\n                     //    or dimensions for box.\\n    float v;         // Radius for sphere.\\n};\\n    \\n\\nbool sphere_intersect(const in ray r, const in float t_min, const in float t_max,\\n                      const in vec3 center, const in float radius, inout float dist) {\\n\\tvec3 oc = r.origin - center;\\n    float b = dot(oc, r.direction);\\n    float c = dot(oc, oc) - radius * radius;\\n    float discriminant = b * b - c;\\n    if (discriminant < 0.0) return false;\\n\\n\\tfloat s = sqrt(discriminant);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\tfloat t = t1 < t_min ? t2 : t1;\\n    if (t < t_max && t > t_min) {\\n        dist = t;\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nbool box_intersect(const in ray r, const in float t_min, const in float t_max,\\n                   const in vec3 center, const in vec3 rad, out vec3 normal, inout float dist) {\\n    vec3 m = 1./r.direction;\\n    vec3 n = m*(r.origin - center);\\n    vec3 k = abs(m)*rad;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n\\tif( tN > tF || tF < 0.) return false;\\n    \\n    float t = tN < t_min ? tF : tN;\\n    if (t < t_max && t > t_min) {\\n        dist = t;\\n\\t\\tnormal = -sign(r.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \\n                 const in float t_max, inout hit_record rec) {\\n    \\n    if(hb.type == SPHERE || hb.type == MOVING_SPHERE) {\\n        vec3 center = hb.type == SPHERE ? hb.center : hb.center + r.time * hb.v3;\\n        float radius = hb.v;\\n        float dist;\\n        if (sphere_intersect(r, t_min, t_max, center, radius, dist)) {\\n            rec.t = dist;\\n            rec.p = r.origin + dist*r.direction;\\n            rec.normal = (rec.p - center) / hb.v;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    } else { // box\\n        float dist;\\n        vec3 normal;\\n        if (box_intersect(r, t_min, t_max, hb.center, hb.v3, normal, dist)) {\\n            rec.t = dist;\\n            rec.p = r.origin + dist*r.direction;\\n            rec.normal = normal;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\n//\\n// Camera\\n//\\n\\nstruct camera {\\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\\n    float time0, time1, lens_radius;\\n};\\n\\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \\n                    const in float vfov, const in float aspect, const in float aperture, \\n                    const in float focus_dist, const in float time0, const in float time1) {\\n    camera cam;    \\n    cam.lens_radius = aperture / 2.;\\n    float theta = vfov*3.14159265359/180.;\\n    float half_height = tan(theta/2.);\\n    float half_width = aspect * half_height;\\n    cam.origin = lookfrom;\\n    cam.w = normalize(lookfrom - lookat);\\n    cam.u = normalize(cross(vup, cam.w));\\n    cam.v = cross(cam.w, cam.u);\\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\\n    cam.time0 = time0;\\n    cam.time1 = time1;\\n    return cam;\\n}\\n    \\nray camera_get_ray(camera c, vec2 uv) {\\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\\n    vec3 offset = c.u * rd.x + c.v * rd.y;\\n    return ray(c.origin + offset, \\n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset),\\n               mix(c.time0, c.time1, hash1(g_seed)));\\n}\\n\\n//\\n// Color & Scene\\n//\\n\\nbool world_hit(const in ray r, const in float t_min, \\n               const in float t_max, out hit_record rec) {\\n    rec.t = t_max;\\n    bool hit = false;\\n\\n    const material perlin = material(LAMBERTIAN, texture_(NOISE,vec3(4.)), NO_TEX,0.);\\n    const material light  = material(DIFFUSE_LIGHT, NO_TEX, texture_(SOLID,vec3(4.)),0.);\\n    \\n  \\tif (hitable_hit(hitable(SPHERE, vec3(0,-1000,0), vec3(0), 1000.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=perlin;\\n\\n  \\tif (hitable_hit(hitable(SPHERE, vec3(0,2,0), vec3(0), 2.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=perlin;\\n\\n  \\tif (hitable_hit(hitable(SPHERE, vec3(0,7,0), vec3(0), 2.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=light;\\n\\n  \\tif (hitable_hit(hitable(BOX, vec3(4,2,-2), vec3(1,1,0), 2.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=light;\\n    \\n    return hit;\\n}\\n\\nvec3 color(in ray r) {\\n    vec3 col = vec3(0);\\n    vec3 emitted = vec3(0);\\n\\thit_record rec;\\n    \\n    for (int i=0; i<MAX_RECURSION; i++) {\\n    \\tif (world_hit(r, EPSILON, MAX_FLOAT, rec)) {\\n            ray scattered;\\n            vec3 attenuation;\\n            vec3 emit = material_emitted(rec);\\n            emitted += i == 0 ? emit : col * emit;\\n            \\n            if (material_scatter(r, rec, attenuation, scattered)) {\\n                col = i == 0 ? attenuation : col * attenuation;\\n                r = scattered;\\n            } else {\\n                return emitted;\\n            }\\n\\t    } else {\\n            return emitted;\\n    \\t}\\n        if(dot(col,col) < 0.0001) return emitted; // optimisation\\n    }\\n    return emitted;\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\\n    if (ivec2(frag_coord) == ivec2(0)) {\\n        frag_color = iResolution.xyxy;\\n    } else {\\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\\n\\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\\n        float aspect = iResolution.x/iResolution.y;\\n        vec3 lookfrom = vec3(25,3.5,6);\\n        vec3 lookat = vec3(0,2,0);\\n        \\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 20., aspect, .0, 10., 0., 1.);\\n        ray r = camera_get_ray(cam, uv);\\n        vec3 col = color(r);\\n        \\n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \\n\\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\\n        } else {        \\n\\t        frag_color = vec4(col,1);\\n        }\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XlGcWD","date":"1536332988","viewed":4336,"name":"RIOW 2.07: Instances","description":"The Cornell box. These shaders are my implementation of the ray/path tracer described in the book \\"Raytracing in one weekend\\" by Peter Shirley. I didn't implement the rectangle-primitive, so I have used the box-primitive for the thin walls.","likes":14,"published":"Public API","usePreview":0,"tags":["raytracing","ray","cornell","tracer","one","in","path","weekend"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray tracing: the next week, chapter 7: Instances. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XlGcWD\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Ray tracing in one weekend\\" and \\"Ray tracing: the next week\\"[1] by Peter Shirley \\n// (@Peter_shirley). I have tried to follow the code from his book as much as possible, but \\n// I had to make some changes to get it running in a fragment shader:\\n//\\n// - There are no classes (and methods) in glsl so I use structs and functions instead. \\n//   Inheritance is implemented by adding a type variable to the struct and adding ugly \\n//   if/else statements to the (not so overloaded) functions.\\n// - The scene description is procedurally implemented in the world_hit function to save\\n//   memory.\\n// - The color function is implemented using a loop because it is not possible to have a \\n//   recursive function call in glsl.\\n// - Only one sample per pixel per frame is calculated. Samples of all frames are added \\n//   in Buffer A and averaged in the Image tab.\\n//\\n// Besides that, I also made some other design choices. Most notably:\\n//\\n// - In my code ray.direction is always a unit vector so I could clean up the rest of\\n//   the code by removing some implicit normalizations.\\n// - Cosine weighted hemisphere sampling is used for the Lambertian material.\\n//\\n// You can find the raytracer / pathtracer in Buffer A.\\n//\\n// = Ray tracing in one week =\\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\\n//\\n// = Ray tracing: the next week =\\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Ray tracing: the next week, chapter 7: Instances. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XlGcWD\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Ray tracing in one weekend\\" and \\"Ray tracing: the next week\\"[1] by Peter Shirley \\n// (@Peter_shirley). I have tried to follow the code from his book as much as possible.\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\n#define MAX_FLOAT 1e5\\n#define EPSILON 0.01\\n#define MAX_RECURSION (64+min(0,iFrame))\\n\\n#define LAMBERTIAN 0\\n#define METAL 1\\n#define DIELECTRIC 2\\n#define DIFFUSE_LIGHT 3\\n\\n#define SPHERE 0\\n#define MOVING_SPHERE 1\\n#define BOX 2\\n\\n#define SOLID 0\\n#define NOISE 1\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint base_hash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat g_seed = 0.;\\n\\nfloat hash1(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    return float(n)/float(0xffffffffU);\\n}\\n\\nvec2 hash2(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Noise functions by Inigo Quilez:\\n// https://www.shadertoy.com/view/4sfGzS\\n//\\n\\nfloat hash(vec3 p) {\\n    p  = fract( p*0.3183099+.1 );\\n\\tp *= 17.0;\\n    return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\\n}\\n\\nfloat noise(const in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n\\t\\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \\n                        hash(p+vec3(1,0,0)),f.x),\\n                   mix( hash(p+vec3(0,1,0)), \\n                        hash(p+vec3(1,1,0)),f.x),f.y),\\n               mix(mix( hash(p+vec3(0,0,1)), \\n                        hash(p+vec3(1,0,1)),f.x),\\n                   mix( hash(p+vec3(0,1,1)), \\n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\\n}\\n\\nfloat fbm(const in vec3 p, const in int octaves) {\\n    float accum = 0.;\\n    vec3 temp_p = p;\\n    float weight = 1.;\\n     \\n    for (int i=0; i<octaves; i++) {\\n        accum += weight * noise(temp_p);\\n        weight *= .5;\\n        temp_p *= 2.;\\n    }\\n    return abs(accum);\\n}\\n\\n//\\n// Ray trace helper functions\\n//\\n\\nfloat schlick(float cosine, float ior) {\\n    float r0 = (1.-ior)/(1.+ior);\\n    r0 = r0*r0;\\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\\n}\\n\\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \\n                      out vec3 refracted) {\\n    float dt = dot(v, n);\\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\\n    if (discriminant > 0.) {\\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\\n        return true;\\n    } else { \\n        return false;\\n    }\\n}\\n\\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n\\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\\n\\tvec3  vv = cross(uu, n);\\n\\tfloat ra = sqrt(r.y);\\n\\tfloat rx = ra*cos(6.28318530718*r.x); \\n\\tfloat ry = ra*sin(6.28318530718*r.x);\\n\\tfloat rz = sqrt(1.-r.y);\\n\\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\\n    return normalize(rr);\\n}\\n\\nvec2 random_in_unit_disk(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r * vec2(sin(phi),cos(phi));\\n}\\n\\nvec3 random_in_unit_sphere(inout float seed) {\\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\\n    float phi = h.y;\\n    float r = pow(h.z, 1./3.);\\n\\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\nvec3 rotate_y(const in vec3 p, const in float t) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\\n    return vec3(xz.x, p.y, xz.y);\\n}\\n\\n//\\n// Ray\\n//\\n\\nstruct ray {\\n    vec3 origin, direction;\\n    float time;\\n};\\n\\nray ray_translate(const in ray r, const in vec3 t) {\\n    ray rt = r;\\n    rt.origin -= t;\\n    return rt;\\n}\\n\\nray ray_rotate_y(const in ray r, const in float t) {\\n    ray rt = r;\\n    rt.origin = rotate_y(rt.origin, t);\\n    rt.direction = rotate_y(rt.direction, t);\\n    return rt;\\n}\\n\\n//\\n// Texture\\n//\\n\\nstruct texture_ {\\n    int type;\\n    vec3 v;\\n};\\n\\nvec3 texture_value(const in texture_ t, const in vec3 p) {\\n    if (t.type == SOLID) {\\n\\t    return t.v;\\n    } else if (t.type == NOISE) {\\n        return vec3(.5*(1. + sin(t.v.x*p.z + 5.*fbm((t.v.x*.5)*p, 7))));\\n    }\\n}\\n\\n#define NO_TEX texture_(SOLID,vec3(0))\\n\\n//\\n// Material\\n//\\n\\nstruct material {\\n    int type;\\n    texture_ albedo;\\n    texture_ emit;\\n    float v;\\n};\\n\\n//\\n// Hit record\\n//\\n\\nstruct hit_record {\\n    float t;\\n    vec3 p, normal;\\n    material mat;\\n};\\n\\nhit_record hit_record_translate(const in hit_record h, const in vec3 t) {\\n    hit_record ht = h;\\n    ht.p -= t;\\n    return ht;\\n}\\n   \\nhit_record hit_record_rotate_y(const in hit_record h, const in float t) {\\n    hit_record ht = h;\\n    ht.p = rotate_y(ht.p, t);\\n    ht.normal = rotate_y(ht.normal, t);\\n    return ht;\\n}\\n\\nbool material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \\n                      out ray scattered) {\\n    if(rec.mat.type == LAMBERTIAN) {\\n        scattered = ray(rec.p, random_cos_weighted_hemisphere_direction(rec.normal, g_seed), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n        return true;\\n    } else if(rec.mat.type == METAL) {\\n        vec3 rd = reflect(r_in.direction, rec.normal);\\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n        return true;\\n    } else if(rec.mat.type == DIELECTRIC) {\\n        vec3 outward_normal, refracted, \\n             reflected = reflect(r_in.direction, rec.normal);\\n        float ni_over_nt, reflect_prob, cosine;\\n        \\n        attenuation = vec3(1);\\n        if (dot(r_in.direction, rec.normal) > 0.) {\\n            outward_normal = -rec.normal;\\n            ni_over_nt = rec.mat.v;\\n            cosine = dot(r_in.direction, rec.normal);\\n            cosine = sqrt(1. - rec.mat.v*rec.mat.v*(1.-cosine*cosine));\\n        } else {\\n            outward_normal = rec.normal;\\n            ni_over_nt = 1. / rec.mat.v;\\n            cosine = -dot(r_in.direction, rec.normal);\\n        }\\n        \\n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\\n\\t        reflect_prob = schlick(cosine, rec.mat.v);\\n        } else {\\n            reflect_prob = 1.;\\n        }\\n        \\n        if (hash1(g_seed) < reflect_prob) {\\n            scattered = ray(rec.p, reflected, r_in.time);\\n        } else {\\n            scattered = ray(rec.p, refracted, r_in.time);\\n        }\\n        return true;\\n    }\\n    return false;\\n}\\n\\nvec3 material_emitted(const in hit_record rec) {\\n    if (rec.mat.type == DIFFUSE_LIGHT) {\\n        return texture_value(rec.mat.emit, rec.p);\\n    } else {\\n        return vec3(0);\\n    }\\n}\\n\\n//\\n// Hitable\\n//\\n\\nstruct hitable {\\n    int type;\\n    vec3 center, v3; // v3 is speed for moving sphere (with center at t=0) \\n                     //    or dimensions for box.\\n    float v;         // Radius for sphere.\\n};\\n    \\n\\nbool sphere_intersect(const in ray r, const in float t_min, const in float t_max,\\n                      const in vec3 center, const in float radius, inout float dist) {\\n\\tvec3 oc = r.origin - center;\\n    float b = dot(oc, r.direction);\\n    float c = dot(oc, oc) - radius * radius;\\n    float discriminant = b * b - c;\\n    if (discriminant < 0.0) return false;\\n\\n\\tfloat s = sqrt(discriminant);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\tfloat t = t1 < t_min ? t2 : t1;\\n    if (t < t_max && t > t_min) {\\n        dist = t;\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nbool box_intersect(const in ray r, const in float t_min, const in float t_max,\\n                   const in vec3 center, const in vec3 rad, out vec3 normal, inout float dist) {\\n    vec3 m = 1./r.direction;\\n    vec3 n = m*(r.origin - center);\\n    vec3 k = abs(m)*rad;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n\\tif( tN > tF || tF < 0.) return false;\\n    \\n    float t = tN < t_min ? tF : tN;\\n    if (t < t_max && t > t_min) {\\n        dist = t;\\n\\t\\tnormal = -sign(r.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \\n                 const in float t_max, inout hit_record rec) {\\n    \\n    if(hb.type == SPHERE || hb.type == MOVING_SPHERE) {\\n        vec3 center = hb.type == SPHERE ? hb.center : hb.center + r.time * hb.v3;\\n        float radius = hb.v;\\n        float dist;\\n        if (sphere_intersect(r, t_min, t_max, center, radius, dist)) {\\n            rec.t = dist;\\n            rec.p = r.origin + dist*r.direction;\\n            rec.normal = (rec.p - center) / hb.v;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    } else { // box\\n        float dist;\\n        vec3 normal;\\n        if (box_intersect(r, t_min, t_max, hb.center, hb.v3, normal, dist)) {\\n            rec.t = dist;\\n            rec.p = r.origin + dist*r.direction;\\n            rec.normal = normal;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\n//\\n// Camera\\n//\\n\\nstruct camera {\\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\\n    float time0, time1, lens_radius;\\n};\\n\\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \\n                    const in float vfov, const in float aspect, const in float aperture, \\n                    const in float focus_dist, const in float time0, const in float time1) {\\n    camera cam;    \\n    cam.lens_radius = aperture / 2.;\\n    float theta = vfov*3.14159265359/180.;\\n    float half_height = tan(theta/2.);\\n    float half_width = aspect * half_height;\\n    cam.origin = lookfrom;\\n    cam.w = normalize(lookfrom - lookat);\\n    cam.u = normalize(cross(vup, cam.w));\\n    cam.v = cross(cam.w, cam.u);\\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\\n    cam.time0 = time0;\\n    cam.time1 = time1;\\n    return cam;\\n}\\n    \\nray camera_get_ray(camera c, vec2 uv) {\\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\\n    vec3 offset = c.u * rd.x + c.v * rd.y;\\n    return ray(c.origin + offset, \\n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset),\\n               mix(c.time0, c.time1, hash1(g_seed)));\\n}\\n\\n//\\n// Color & Scene\\n//\\n\\nbool world_hit(const in ray r, const in float t_min, \\n               const in float t_max, out hit_record rec) {\\n    rec.t = t_max;\\n    bool hit = false;\\n\\n    const material red = material(LAMBERTIAN, texture_(SOLID,vec3(.65,.05,.05)), NO_TEX,0.);\\n    const material white = material(LAMBERTIAN, texture_(SOLID,vec3(.73)), NO_TEX,0.);\\n    const material green = material(LAMBERTIAN, texture_(SOLID,vec3(.12,.45,.15)), NO_TEX,0.);\\n\\n    const material light = material(DIFFUSE_LIGHT, NO_TEX, texture_(SOLID,vec3(15)),0.);\\n    \\n  \\tif (hitable_hit(hitable(BOX, vec3(556,277.5,277.5), vec3(1,277.5,277.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=green;\\n    if (hitable_hit(hitable(BOX, vec3(-1,277.5,277.5), vec3(1,277.5,277.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=red;\\n   \\n    if (hitable_hit(hitable(BOX, vec3(277.5,556,277.5), vec3(277.5,1,277.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=white;\\n    if (hitable_hit(hitable(BOX, vec3(277.5,-1,277.5), vec3(277.5,1,277.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=white;\\n    if (hitable_hit(hitable(BOX, vec3(277.5,277.5,556), vec3(277.5,277.5,1), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=white;\\n    \\n    if (hitable_hit(hitable(BOX, vec3(278,555,279.5), vec3(65,1,52.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=light;   \\n   \\n    ray r_ = ray_rotate_y(ray_translate(r, vec3(130,0,65)), -18./180.*3.14159265359);\\n    hit_record rec_ = rec;    \\n    if (hitable_hit(hitable(BOX, vec3(82.5), vec3(82.5), 0.),r_,t_min,rec.t,rec_)) \\n        hit=true, \\n        rec=hit_record_translate(hit_record_rotate_y(rec_, 18./180.*3.14159265359),-vec3(130,0,65.)), \\n        rec.mat=white;\\n    \\n\\tr_ = ray_rotate_y(ray_translate(r, vec3(265,0,295)), 15./180.*3.14159265359);\\n    rec_ = rec;    \\n    if (hitable_hit(hitable(BOX, vec3(82.5,165,82.5), vec3(82.5,165,82.5), 0.),r_,t_min,rec.t,rec_)) \\n        hit=true, \\n        rec=hit_record_translate(hit_record_rotate_y(rec_, -15./180.*3.14159265359),-vec3(265,0,295)), \\n        rec.mat=white;\\n  \\n    return hit;\\n}\\n\\nvec3 color(in ray r) {\\n    vec3 col = vec3(0);\\n    vec3 emitted = vec3(0);\\n\\thit_record rec;\\n    \\n    for (int i=0; i<MAX_RECURSION; i++) {\\n    \\tif (world_hit(r, EPSILON, MAX_FLOAT, rec)) {\\n            ray scattered;\\n            vec3 attenuation;\\n            vec3 emit = material_emitted(rec);\\n            emitted += i == 0 ? emit : col * emit;\\n            \\n            if (material_scatter(r, rec, attenuation, scattered)) {\\n                col = i == 0 ? attenuation : col * attenuation;\\n                r = scattered;\\n            } else {\\n                return emitted;\\n            }\\n\\t    } else {\\n            return emitted;\\n    \\t}\\n        if(dot(col,col) < 0.0001) return emitted; // optimisation\\n    }\\n    return emitted;\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\\n    if (ivec2(frag_coord) == ivec2(0)) {\\n        frag_color = iResolution.xyxy;\\n    } else {\\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\\n\\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\\n        float aspect = iResolution.x/iResolution.y;\\n        vec3 lookfrom = vec3(278, 278, -800);\\n        vec3 lookat = vec3(278,278,0);\\n        \\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 40., aspect, .0, 10., 0., 1.);\\n        ray r = camera_get_ray(cam, uv);\\n        vec3 col = color(r);\\n        \\n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \\n\\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\\n        } else {        \\n\\t        frag_color = vec4(col,1);\\n        }\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XtyyDD","date":"1536332991","viewed":3678,"name":"RIOW 2.08: Volumes","description":"These shaders are my implementation of the ray/path tracer described in the book \\"Raytracing in one weekend\\" by Peter Shirley.","likes":22,"published":"Public API","usePreview":0,"tags":["raytracing","ray","tracer","one","in","path","weekend"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray tracing: the next week, chapter 8: Volumes. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtycDD\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Ray tracing in one weekend\\" and \\"Ray tracing: the next week\\"[1] by Peter Shirley \\n// (@Peter_shirley). I have tried to follow the code from his book as much as possible, but \\n// I had to make some changes to get it running in a fragment shader:\\n//\\n// - There are no classes (and methods) in glsl so I use structs and functions instead. \\n//   Inheritance is implemented by adding a type variable to the struct and adding ugly \\n//   if/else statements to the (not so overloaded) functions.\\n// - The scene description is procedurally implemented in the world_hit function to save\\n//   memory.\\n// - The color function is implemented using a loop because it is not possible to have a \\n//   recursive function call in glsl.\\n// - Only one sample per pixel per frame is calculated. Samples of all frames are added \\n//   in Buffer A and averaged in the Image tab.\\n//\\n// Besides that, I also made some other design choices. Most notably:\\n//\\n// - In my code ray.direction is always a unit vector so I could clean up the rest of\\n//   the code by removing some implicit normalizations.\\n// - Cosine weighted hemisphere sampling is used for the Lambertian material.\\n//\\n// You can find the raytracer / pathtracer in Buffer A.\\n//\\n// = Ray tracing in one week =\\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\\n//\\n// = Ray tracing: the next week =\\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Ray tracing: the next week, chapter 8: Volumes. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtycDD\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Ray tracing in one weekend\\" and \\"Ray tracing: the next week\\"[1] by Peter Shirley \\n// (@Peter_shirley). I have tried to follow the code from his book as much as possible.\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\n#define MAX_FLOAT 1e5\\n#define EPSILON 0.01\\n#define MAX_RECURSION (40+min(0,iFrame))\\n\\n#define LAMBERTIAN 0\\n#define METAL 1\\n#define DIELECTRIC 2\\n#define DIFFUSE_LIGHT 3\\n#define ISOTROPIC 4\\n\\n#define SPHERE 0\\n#define MOVING_SPHERE 1\\n#define BOX 2\\n#define CONSTANT_MEDIUM_SPHERE 3\\n#define CONSTANT_MEDIUM_BOX 4\\n\\n#define SOLID 0\\n#define NOISE 1\\n\\n//\\n// Scene defines\\n//\\n\\n#define DENSITY .01\\n#define RENDER_SPHERE (0)\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint base_hash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat g_seed = 0.;\\n\\nfloat hash1(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    return float(n)/float(0xffffffffU);\\n}\\n\\nvec2 hash2(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Noise functions by Inigo Quilez:\\n// https://www.shadertoy.com/view/4sfGzS\\n//\\n\\nfloat hash(vec3 p) {\\n    p  = fract( p*0.3183099+.1 );\\n\\tp *= 17.0;\\n    return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\\n}\\n\\nfloat noise(const in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n\\t\\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \\n                        hash(p+vec3(1,0,0)),f.x),\\n                   mix( hash(p+vec3(0,1,0)), \\n                        hash(p+vec3(1,1,0)),f.x),f.y),\\n               mix(mix( hash(p+vec3(0,0,1)), \\n                        hash(p+vec3(1,0,1)),f.x),\\n                   mix( hash(p+vec3(0,1,1)), \\n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\\n}\\n\\nfloat fbm(const in vec3 p, const in int octaves) {\\n    float accum = 0.;\\n    vec3 temp_p = p;\\n    float weight = 1.;\\n     \\n    for (int i=0; i<octaves; i++) {\\n        accum += weight * noise(temp_p);\\n        weight *= .5;\\n        temp_p *= 2.;\\n    }\\n    return abs(accum);\\n}\\n\\n//\\n// Ray trace helper functions\\n//\\n\\nfloat schlick(float cosine, float ior) {\\n    float r0 = (1.-ior)/(1.+ior);\\n    r0 = r0*r0;\\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\\n}\\n\\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \\n                      out vec3 refracted) {\\n    float dt = dot(v, n);\\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\\n    if (discriminant > 0.) {\\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\\n        return true;\\n    } else { \\n        return false;\\n    }\\n}\\n\\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n\\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\\n\\tvec3  vv = cross(uu, n);\\n\\tfloat ra = sqrt(r.y);\\n\\tfloat rx = ra*cos(6.28318530718*r.x); \\n\\tfloat ry = ra*sin(6.28318530718*r.x);\\n\\tfloat rz = sqrt(1.-r.y);\\n\\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\\n    return normalize(rr);\\n}\\n\\nvec2 random_in_unit_disk(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r * vec2(sin(phi),cos(phi));\\n}\\n\\nvec3 random_in_unit_sphere(inout float seed) {\\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\\n    float phi = h.y;\\n    float r = pow(h.z, 1./3.);\\n\\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\nvec3 rotate_y(const in vec3 p, const in float t) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\\n    return vec3(xz.x, p.y, xz.y);\\n}\\n\\n//\\n// Ray\\n//\\n\\nstruct ray {\\n    vec3 origin, direction;\\n    float time;\\n};\\n\\nray ray_translate(const in ray r, const in vec3 t) {\\n    ray rt = r;\\n    rt.origin -= t;\\n    return rt;\\n}\\n\\nray ray_rotate_y(const in ray r, const in float t) {\\n    ray rt = r;\\n    rt.origin = rotate_y(rt.origin, t);\\n    rt.direction = rotate_y(rt.direction, t);\\n    return rt;\\n}\\n\\n//\\n// Texture\\n//\\n\\nstruct texture_ {\\n    int type;\\n    vec3 v;\\n};\\n\\nvec3 texture_value(const in texture_ t, const in vec3 p) {\\n    if (t.type == SOLID) {\\n\\t    return t.v;\\n    } else if (t.type == NOISE) {\\n        return vec3(.5*(1. + sin(t.v.x*p.z + 5.*fbm((t.v.x*.5)*p, 7))));\\n    }\\n}\\n\\n#define NO_TEX texture_(SOLID,vec3(0))\\n\\n//\\n// Material\\n//\\n\\nstruct material {\\n    int type;\\n    texture_ albedo;\\n    texture_ emit;\\n    float v;\\n};\\n\\n//\\n// Hit record\\n//\\n\\nstruct hit_record {\\n    float t;\\n    vec3 p, normal;\\n    material mat;\\n};\\n\\nhit_record hit_record_translate(const in hit_record h, const in vec3 t) {\\n    hit_record ht = h;\\n    ht.p -= t;\\n    return ht;\\n}\\n   \\nhit_record hit_record_rotate_y(const in hit_record h, const in float t) {\\n    hit_record ht = h;\\n    ht.p = rotate_y(ht.p, t);\\n    ht.normal = rotate_y(ht.normal, t);\\n    return ht;\\n}\\n\\nbool material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \\n                      out ray scattered) {\\n    if(rec.mat.type == LAMBERTIAN) {\\n        scattered = ray(rec.p, random_cos_weighted_hemisphere_direction(rec.normal, g_seed), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n        return true;\\n    } else if(rec.mat.type == METAL) {\\n        vec3 rd = reflect(r_in.direction, rec.normal);\\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n        return true;\\n    } else if(rec.mat.type == DIELECTRIC) {\\n        vec3 outward_normal, refracted, \\n             reflected = reflect(r_in.direction, rec.normal);\\n        float ni_over_nt, reflect_prob, cosine;\\n        \\n        attenuation = vec3(1);\\n        if (dot(r_in.direction, rec.normal) > 0.) {\\n            outward_normal = -rec.normal;\\n            ni_over_nt = rec.mat.v;\\n            cosine = dot(r_in.direction, rec.normal);\\n            cosine = sqrt(1. - rec.mat.v*rec.mat.v*(1.-cosine*cosine));\\n        } else {\\n            outward_normal = rec.normal;\\n            ni_over_nt = 1. / rec.mat.v;\\n            cosine = -dot(r_in.direction, rec.normal);\\n        }\\n        \\n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\\n\\t        reflect_prob = schlick(cosine, rec.mat.v);\\n        } else {\\n            reflect_prob = 1.;\\n        }\\n        \\n        if (hash1(g_seed) < reflect_prob) {\\n            scattered = ray(rec.p, reflected, r_in.time);\\n        } else {\\n            scattered = ray(rec.p, refracted, r_in.time);\\n        }\\n        return true;\\n    } else if(rec.mat.type == ISOTROPIC) {\\n        scattered = ray(rec.p, random_in_unit_sphere(g_seed), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n    \\treturn true;    \\n    }\\n    \\n    return false;\\n}\\n\\nvec3 material_emitted(const in hit_record rec) {\\n    if (rec.mat.type == DIFFUSE_LIGHT) {\\n        return texture_value(rec.mat.emit, rec.p);\\n    } else {\\n        return vec3(0);\\n    }\\n}\\n\\n//\\n// Hitable\\n//\\n\\nstruct hitable {\\n    int type;\\n    vec3 center, v3; // v3 is speed for moving sphere (with center at t=0) \\n                     //    or dimensions for box.\\n    float v;         // Radius for sphere.\\n};\\n    \\n\\nbool sphere_intersect(const in ray r, const in float t_min, const in float t_max,\\n                      const in vec3 center, const in float radius, inout float dist) {\\n\\tvec3 oc = r.origin - center;\\n    float b = dot(oc, r.direction);\\n    float c = dot(oc, oc) - radius * radius;\\n    float discriminant = b * b - c;\\n    if (discriminant < 0.0) return false;\\n\\n\\tfloat s = sqrt(discriminant);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\tfloat t = t1 < t_min ? t2 : t1;\\n    if (t < t_max && t > t_min) {\\n        dist = t;\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nbool box_intersect(const in ray r, const in float t_min, const in float t_max,\\n                   const in vec3 center, const in vec3 rad, out vec3 normal, inout float dist) {\\n    vec3 m = 1./r.direction;\\n    vec3 n = m*(r.origin - center);\\n    vec3 k = abs(m)*rad;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n\\tif( tN > tF || tF < 0.) return false;\\n    \\n    float t = tN < t_min ? tF : tN;\\n    if (t < t_max && t > t_min) {\\n        dist = t;\\n\\t\\tnormal = -sign(r.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \\n                 const in float t_max, inout hit_record rec) {\\n    \\n    if(hb.type == SPHERE || hb.type == MOVING_SPHERE) {\\n        vec3 center = hb.type == SPHERE ? hb.center : hb.center + r.time * hb.v3;\\n        float radius = hb.v;\\n        float dist;\\n        if (sphere_intersect(r, t_min, t_max, center, radius, dist)) {\\n            rec.t = dist;\\n            rec.p = r.origin + dist*r.direction;\\n            rec.normal = (rec.p - center) / radius;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    } else if (hb.type == BOX) { \\n        float dist;\\n        vec3 normal;\\n        if (box_intersect(r, t_min, t_max, hb.center, hb.v3, normal, dist)) {\\n            rec.t = dist;\\n            rec.p = r.origin + dist*r.direction;\\n            rec.normal = normal;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    } else { // constant medium\\n        bool h1, h2;\\n        float t1, t2;\\n    \\thit_record rec1, rec2;\\n        if (hb.type == CONSTANT_MEDIUM_SPHERE) {\\n            h1 = sphere_intersect(r, -MAX_FLOAT, MAX_FLOAT, hb.center, hb.v3.x, t1);\\n            h2 = sphere_intersect(r, t1+EPSILON, MAX_FLOAT, hb.center, hb.v3.x, t2);\\n        } else { // box\\n            vec3 normal;\\n            h1 = box_intersect(r, -MAX_FLOAT, MAX_FLOAT, hb.center, hb.v3, normal, t1);\\n            h2 = box_intersect(r, t1+EPSILON, MAX_FLOAT, hb.center, hb.v3, normal, t2);\\n        }\\n        if(h1 && h2) {\\n            if (t1 < t_min) t1 = t_min;\\n            if (t2 > t_max) t2 = t_max;\\n            if (t1 >= t2) {\\n                return false;\\n            } else {\\n                if (t1 < 0.) t1 = 0.;\\n\\n                float distance_inside_boundary = t2 - t1;\\n                float hit_distance = -(1./hb.v)*log(hash1(g_seed)); \\n\\n                if (hit_distance < distance_inside_boundary) {\\n                    rec.t = t1 + hit_distance; \\n                    rec.p = r.origin + r.direction * rec.t;\\n                    rec.normal = vec3(1,0,0);  // arbitrary\\n                    return true;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        } else {\\n            return false;\\n        }\\n    } \\n}\\n\\n//\\n// Camera\\n//\\n\\nstruct camera {\\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\\n    float time0, time1, lens_radius;\\n};\\n\\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \\n                    const in float vfov, const in float aspect, const in float aperture, \\n                    const in float focus_dist, const in float time0, const in float time1) {\\n    camera cam;    \\n    cam.lens_radius = aperture / 2.;\\n    float theta = vfov*3.14159265359/180.;\\n    float half_height = tan(theta/2.);\\n    float half_width = aspect * half_height;\\n    cam.origin = lookfrom;\\n    cam.w = normalize(lookfrom - lookat);\\n    cam.u = normalize(cross(vup, cam.w));\\n    cam.v = cross(cam.w, cam.u);\\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\\n    cam.time0 = time0;\\n    cam.time1 = time1;\\n    return cam;\\n}\\n    \\nray camera_get_ray(camera c, vec2 uv) {\\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\\n    vec3 offset = c.u * rd.x + c.v * rd.y;\\n    return ray(c.origin + offset, \\n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset),\\n               mix(c.time0, c.time1, hash1(g_seed)));\\n}\\n\\n//\\n// Color & Scene\\n//\\n\\nbool world_hit(const in ray r, const in float t_min, \\n               const in float t_max, out hit_record rec) {\\n    rec.t = t_max;\\n    bool hit = false;\\n\\n    const material red = material(LAMBERTIAN, texture_(SOLID,vec3(.65,.05,.05)), NO_TEX,0.);\\n    const material white = material(LAMBERTIAN, texture_(SOLID,vec3(.73)), NO_TEX,0.);\\n    const material green = material(LAMBERTIAN, texture_(SOLID,vec3(.12,.45,.15)), NO_TEX,0.);\\n\\n    const material light = material(DIFFUSE_LIGHT, NO_TEX, texture_(SOLID,vec3(7)),0.);\\n    \\n    const material smoke_1 = material(ISOTROPIC, texture_(SOLID,vec3(.97)), NO_TEX,0.);\\n    const material smoke_2 = material(ISOTROPIC, texture_(SOLID,vec3(.03)), NO_TEX,0.);\\n        \\n  \\tif (hitable_hit(hitable(BOX, vec3(556,277.5,277.5), vec3(1,277.5,277.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=green;\\n    if (hitable_hit(hitable(BOX, vec3(-1,277.5,277.5), vec3(1,277.5,277.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=red;\\n   \\n    if (hitable_hit(hitable(BOX, vec3(277.5,556,277.5), vec3(277.5,1,277.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=white;\\n    if (hitable_hit(hitable(BOX, vec3(277.5,-1,277.5), vec3(277.5,1,277.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=white;\\n    if (hitable_hit(hitable(BOX, vec3(277.5,277.5,556), vec3(277.5,277.5,1), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=white;\\n    \\n    if (hitable_hit(hitable(BOX, vec3(278,555,279.5), vec3(115,1,157.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=light;   \\n   \\n#if RENDER_SPHERE // blue subsurface scattering sphere\\n    const material glass =  material(DIELECTRIC, NO_TEX, NO_TEX,1.02);\\n    const material blue  =  material(ISOTROPIC, texture_(SOLID,vec3(.2,.4,.9)), NO_TEX,0.);\\n    \\n    if (hitable_hit(hitable(SPHERE, vec3(210,120,180), vec3(0), 120.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=glass;   \\n    \\n    if (hitable_hit(hitable(CONSTANT_MEDIUM_SPHERE, vec3(210,120,180), vec3(120), .04),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=blue; \\n    \\n#else\\n    ray r_ = ray_rotate_y(ray_translate(r, vec3(130,0,65)), -18./180.*3.14159265359);\\n    hit_record rec_ = rec;    \\n    if (hitable_hit(hitable(CONSTANT_MEDIUM_BOX, vec3(82.5), vec3(82.5), DENSITY),r_,t_min,rec.t,rec_)) \\n        hit=true, \\n        rec=hit_record_translate(hit_record_rotate_y(rec_, 18./180.*3.14159265359),-vec3(130,0,65.)), \\n        rec.mat=smoke_1;\\n    \\n\\tr_ = ray_rotate_y(ray_translate(r, vec3(265,0,295)), 15./180.*3.14159265359);\\n    rec_ = rec;    \\n    if (hitable_hit(hitable(CONSTANT_MEDIUM_BOX, vec3(82.5,165,82.5), vec3(82.5,165,82.5), DENSITY),r_,t_min,rec.t,rec_)) \\n        hit=true, \\n        rec=hit_record_translate(hit_record_rotate_y(rec_, -15./180.*3.14159265359),-vec3(265,0,295)), \\n        rec.mat=smoke_2;\\n#endif \\n    \\n    return hit;\\n}\\n\\nvec3 color(in ray r) {\\n    vec3 col = vec3(0);\\n    vec3 emitted = vec3(0);\\n\\thit_record rec;\\n    \\n    for (int i=0; i<MAX_RECURSION; i++) {\\n    \\tif (world_hit(r, EPSILON, MAX_FLOAT, rec)) {\\n            ray scattered;\\n            vec3 attenuation;\\n            vec3 emit = material_emitted(rec);\\n            emitted += i == 0 ? emit : col * emit;\\n            \\n            if (material_scatter(r, rec, attenuation, scattered)) {\\n                col = i == 0 ? attenuation : col * attenuation;\\n                r = scattered;\\n            } else {\\n                return emitted;\\n            }\\n\\t    } else {\\n            return emitted;\\n    \\t}\\n        if(dot(col,col) < 0.0001) return emitted; // optimisation\\n    }\\n    return emitted;\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\\n    if (ivec2(frag_coord) == ivec2(0)) {\\n        frag_color = iResolution.xyxy;\\n    } else {\\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\\n\\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\\n        float aspect = iResolution.x/iResolution.y;\\n        vec3 lookfrom = vec3(278, 278, -800);\\n        vec3 lookat = vec3(278,278,0);\\n        \\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 40., aspect, .0, 10., 0., 1.);\\n        ray r = camera_get_ray(cam, uv);\\n        vec3 col = color(r);\\n        \\n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \\n\\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\\n        } else {        \\n\\t        frag_color = vec4(col,1);\\n        }\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MtycDD","date":"1536332994","viewed":7207,"name":"RIOW 2.09: A Scene Testing All","description":"These shaders are my implementation of the ray/path tracer described in the book \\"Raytracing in one weekend\\" by Peter Shirley. - DOF and motion blur; boxes, spheres and constant mediums; Lambertian, dielectric, isotropic, emissive and metal materials -","likes":76,"published":"Public API","usePreview":0,"tags":["raytracing","ray","tracer","one","in","path","weekend"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray tracing: the next week, chapter 9: A scene testing all new features. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtycDD\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Ray tracing in one weekend\\" and \\"Ray tracing: the next week\\"[1] by Peter Shirley \\n// (@Peter_shirley). I have tried to follow the code from his book as much as possible, but \\n// I had to make some changes to get it running in a fragment shader:\\n//\\n// - There are no classes (and methods) in glsl so I use structs and functions instead. \\n//   Inheritance is implemented by adding a type variable to the struct and adding ugly \\n//   if/else statements to the (not so overloaded) functions.\\n// - The scene description is procedurally implemented in the world_hit function to save\\n//   memory.\\n// - The color function is implemented using a loop because it is not possible to have a \\n//   recursive function call in glsl.\\n// - Only one sample per pixel per frame is calculated. Samples of all frames are added \\n//   in Buffer A and averaged in the Image tab.\\n//\\n// Besides that, I also made some other design choices. Most notably:\\n//\\n// - In my code ray.direction is always a unit vector so I could clean up the rest of\\n//   the code by removing some implicit normalizations.\\n// - Cosine weighted hemisphere sampling is used for the Lambertian material.\\n//\\n// You can find the raytracer / pathtracer in Buffer A.\\n//\\n// = Ray tracing in one week =\\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\\n//\\n// = Ray tracing: the next week =\\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Ray tracing: the next week, chapter 9: A scene testing all new features. Created by Reinder Nijhoff 2018\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/MtycDD\\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Ray tracing in one weekend\\" and \\"Ray tracing: the next week\\"[1] by Peter Shirley \\n// (@Peter_shirley). I have tried to follow the code from his book as much as possible.\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\n#define MAX_FLOAT 1e5\\n#define EPSILON 0.01\\n#define MAX_RECURSION (24+min(0,iFrame))\\n\\n#define LAMBERTIAN 0\\n#define METAL 1\\n#define DIELECTRIC 2\\n#define DIFFUSE_LIGHT 3\\n#define ISOTROPIC 4\\n\\n#define SPHERE 0\\n#define MOVING_SPHERE 1\\n#define BOX 2\\n#define CONSTANT_MEDIUM_SPHERE 3\\n#define CONSTANT_MEDIUM_BOX 4\\n\\n#define SOLID 0\\n#define NOISE 1\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint base_hash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat g_seed = 0.;\\n\\nfloat hash1(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    return float(n)/float(0xffffffffU);\\n}\\n\\nvec2 hash2(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Noise functions by Inigo Quilez:\\n// https://www.shadertoy.com/view/4sfGzS\\n//\\n\\nfloat hash(vec3 p) {\\n    p  = fract( p*0.3183099+.1 );\\n\\tp *= 17.0;\\n    return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\\n}\\n\\nfloat noise(const in vec3 x ) {\\n    vec3 p = floor(x);\\n    vec3 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n\\t\\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \\n                        hash(p+vec3(1,0,0)),f.x),\\n                   mix( hash(p+vec3(0,1,0)), \\n                        hash(p+vec3(1,1,0)),f.x),f.y),\\n               mix(mix( hash(p+vec3(0,0,1)), \\n                        hash(p+vec3(1,0,1)),f.x),\\n                   mix( hash(p+vec3(0,1,1)), \\n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\\n}\\n\\nfloat fbm(const in vec3 p, const in int octaves) {\\n    float accum = 0.;\\n    vec3 temp_p = p;\\n    float weight = 1.;\\n     \\n    for (int i=0; i<octaves; i++) {\\n        accum += weight * noise(temp_p);\\n        weight *= .5;\\n        temp_p *= 2.;\\n    }\\n    return abs(accum);\\n}\\n\\n//\\n// Ray trace helper functions\\n//\\n\\nfloat schlick(float cosine, float ior) {\\n    float r0 = (1.-ior)/(1.+ior);\\n    r0 = r0*r0;\\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\\n}\\n\\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \\n                      out vec3 refracted) {\\n    float dt = dot(v, n);\\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\\n    if (discriminant > 0.) {\\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\\n        return true;\\n    } else { \\n        return false;\\n    }\\n}\\n\\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n\\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\\n\\tvec3  vv = cross(uu, n);\\n\\tfloat ra = sqrt(r.y);\\n\\tfloat rx = ra*cos(6.28318530718*r.x); \\n\\tfloat ry = ra*sin(6.28318530718*r.x);\\n\\tfloat rz = sqrt(1.-r.y);\\n\\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\\n    return normalize(rr);\\n}\\n\\nvec2 random_in_unit_disk(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r * vec2(sin(phi),cos(phi));\\n}\\n\\nvec3 random_in_unit_sphere(inout float seed) {\\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\\n    float phi = h.y;\\n    float r = pow(h.z, 1./3.);\\n\\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\\n}\\n\\nvec3 rotate_y(const in vec3 p, const in float t) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\\n    return vec3(xz.x, p.y, xz.y);\\n}\\n\\n//\\n// Ray\\n//\\n\\nstruct ray {\\n    vec3 origin, direction;\\n    float time;\\n};\\n\\nray ray_translate(const in ray r, const in vec3 t) {\\n    ray rt = r;\\n    rt.origin -= t;\\n    return rt;\\n}\\n\\nray ray_rotate_y(const in ray r, const in float t) {\\n    ray rt = r;\\n    rt.origin = rotate_y(rt.origin, t);\\n    rt.direction = rotate_y(rt.direction, t);\\n    return rt;\\n}\\n\\n//\\n// Texture\\n//\\n\\nstruct texture_ {\\n    int type;\\n    vec3 v;\\n};\\n\\nvec3 texture_value(const in texture_ t, const in vec3 p) {\\n    if (t.type == SOLID) {\\n\\t    return t.v;\\n    } else if (t.type == NOISE) {\\n        return vec3(.5*(1. + sin(t.v.x*p.x + 5.*fbm((t.v.x)*p, 7))));\\n    }\\n}\\n\\n#define NO_TEX texture_(SOLID,vec3(0))\\n\\n//\\n// Material\\n//\\n\\nstruct material {\\n    int type;\\n    texture_ albedo;\\n    texture_ emit;\\n    float v;\\n};\\n\\n//\\n// Hit record\\n//\\n\\nstruct hit_record {\\n    float t;\\n    vec3 p, normal;\\n    material mat;\\n};\\n\\nhit_record hit_record_translate(const in hit_record h, const in vec3 t) {\\n    hit_record ht = h;\\n    ht.p -= t;\\n    return ht;\\n}\\n   \\nhit_record hit_record_rotate_y(const in hit_record h, const in float t) {\\n    hit_record ht = h;\\n    ht.p = rotate_y(ht.p, t);\\n    ht.normal = rotate_y(ht.normal, t);\\n    return ht;\\n}\\n\\nbool material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \\n                      out ray scattered) {\\n    if(rec.mat.type == LAMBERTIAN) {\\n        scattered = ray(rec.p, random_cos_weighted_hemisphere_direction(rec.normal, g_seed), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n        return true;\\n    } else if(rec.mat.type == METAL) {\\n        vec3 rd = reflect(r_in.direction, rec.normal);\\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n        return true;\\n    } else if(rec.mat.type == DIELECTRIC) {\\n        vec3 outward_normal, refracted, \\n             reflected = reflect(r_in.direction, rec.normal);\\n        float ni_over_nt, reflect_prob, cosine;\\n        \\n        attenuation = vec3(1);\\n        if (dot(r_in.direction, rec.normal) > 0.) {\\n            outward_normal = -rec.normal;\\n            ni_over_nt = rec.mat.v;\\n            cosine = dot(r_in.direction, rec.normal);\\n            cosine = sqrt(1. - rec.mat.v*rec.mat.v*(1.-cosine*cosine));\\n        } else {\\n            outward_normal = rec.normal;\\n            ni_over_nt = 1. / rec.mat.v;\\n            cosine = -dot(r_in.direction, rec.normal);\\n        }\\n        \\n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\\n\\t        reflect_prob = schlick(cosine, rec.mat.v);\\n        } else {\\n            reflect_prob = 1.;\\n        }\\n        \\n        if (hash1(g_seed) < reflect_prob) {\\n            scattered = ray(rec.p, reflected, r_in.time);\\n        } else {\\n            scattered = ray(rec.p, refracted, r_in.time);\\n        }\\n        return true;\\n    } else if(rec.mat.type == ISOTROPIC) {\\n        scattered = ray(rec.p, random_in_unit_sphere(g_seed), r_in.time);\\n        attenuation = texture_value(rec.mat.albedo, rec.p);\\n    \\treturn true;    \\n    }\\n    \\n    return false;\\n}\\n\\nvec3 material_emitted(const in hit_record rec) {\\n    if (rec.mat.type == DIFFUSE_LIGHT) {\\n        return texture_value(rec.mat.emit, rec.p);\\n    } else {\\n        return vec3(0);\\n    }\\n}\\n\\n//\\n// Hitable\\n//\\n\\nstruct hitable {\\n    int type;\\n    vec3 center, v3; // v3 is speed for moving sphere (with center at t=0) \\n                     //    or dimensions for box.\\n    float v;         // Radius for sphere.\\n};\\n    \\n\\nbool sphere_intersect(const in ray r, const in float t_min, const in float t_max,\\n                      const in vec3 center, const in float radius, inout float dist) {\\n\\tvec3 oc = r.origin - center;\\n    float b = dot(oc, r.direction);\\n    float c = dot(oc, oc) - radius * radius;\\n    float discriminant = b * b - c;\\n    if (discriminant < 0.0) return false;\\n\\n\\tfloat s = sqrt(discriminant);\\n\\tfloat t1 = -b - s;\\n\\tfloat t2 = -b + s;\\n\\t\\n\\tfloat t = t1 < t_min ? t2 : t1;\\n    if (t < t_max && t > t_min) {\\n        dist = t;\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nbool box_intersect(const in ray r, const in float t_min, const in float t_max,\\n                   const in vec3 center, const in vec3 rad, out vec3 normal, inout float dist) {\\n    vec3 m = 1./r.direction;\\n    vec3 n = m*(r.origin - center);\\n    vec3 k = abs(m)*rad;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n\\tif( tN > tF || tF < 0.) return false;\\n    \\n    float t = tN < t_min ? tF : tN;\\n    if (t < t_max && t > t_min) {\\n        dist = t;\\n\\t\\tnormal = -sign(r.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \\n                 const in float t_max, inout hit_record rec) {\\n    \\n    if(hb.type == SPHERE || hb.type == MOVING_SPHERE) {\\n        vec3 center = hb.type == SPHERE ? hb.center : hb.center + r.time * hb.v3;\\n        float radius = hb.v;\\n        float dist;\\n        if (sphere_intersect(r, t_min, t_max, center, radius, dist)) {\\n            rec.t = dist;\\n            rec.p = r.origin + dist*r.direction;\\n            rec.normal = (rec.p - center) / radius;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    } else if (hb.type == BOX) { \\n        float dist;\\n        vec3 normal;\\n        if (box_intersect(r, t_min, t_max, hb.center, hb.v3, normal, dist)) {\\n            rec.t = dist;\\n            rec.p = r.origin + dist*r.direction;\\n            rec.normal = normal;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    } else { // constant medium\\n        bool h1, h2;\\n        float t1, t2;\\n    \\thit_record rec1, rec2;\\n        if (hb.type == CONSTANT_MEDIUM_SPHERE) {\\n            h1 = sphere_intersect(r, -MAX_FLOAT, MAX_FLOAT, hb.center, hb.v3.x, t1);\\n            h2 = sphere_intersect(r, t1+EPSILON, MAX_FLOAT, hb.center, hb.v3.x, t2);\\n        } else { // box\\n            vec3 normal;\\n            h1 = box_intersect(r, -MAX_FLOAT, MAX_FLOAT, hb.center, hb.v3, normal, t1);\\n            h2 = box_intersect(r, t1+EPSILON, MAX_FLOAT, hb.center, hb.v3, normal, t2);\\n        }\\n        if(h1 && h2) {\\n            if (t1 < t_min) t1 = t_min;\\n            if (t2 > t_max) t2 = t_max;\\n            if (t1 >= t2) {\\n                return false;\\n            } else {\\n                if (t1 < 0.) t1 = 0.;\\n\\n                float distance_inside_boundary = t2 - t1;\\n                float hit_distance = -(1./hb.v)*log(hash1(g_seed)); \\n\\n                if (hit_distance < distance_inside_boundary) {\\n                    rec.t = t1 + hit_distance; \\n                    rec.p = r.origin + r.direction * rec.t;\\n                    rec.normal = vec3(1,0,0);  // arbitrary\\n                    return true;\\n                } else {\\n                    return false;\\n                }\\n            }\\n        } else {\\n            return false;\\n        }\\n    } \\n}\\n\\n//\\n// Camera\\n//\\n\\nstruct camera {\\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\\n    float time0, time1, lens_radius;\\n};\\n\\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \\n                    const in float vfov, const in float aspect, const in float aperture, \\n                    const in float focus_dist, const in float time0, const in float time1) {\\n    camera cam;    \\n    cam.lens_radius = aperture / 2.;\\n    float theta = vfov*3.14159265359/180.;\\n    float half_height = tan(theta/2.);\\n    float half_width = aspect * half_height;\\n    cam.origin = lookfrom;\\n    cam.w = normalize(lookfrom - lookat);\\n    cam.u = normalize(cross(vup, cam.w));\\n    cam.v = cross(cam.w, cam.u);\\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\\n    cam.time0 = time0;\\n    cam.time1 = time1;\\n    return cam;\\n}\\n    \\nray camera_get_ray(camera c, vec2 uv) {\\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\\n    vec3 offset = c.u * rd.x + c.v * rd.y;\\n    return ray(c.origin + offset, \\n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset),\\n               mix(c.time0, c.time1, hash1(g_seed)));\\n}\\n\\n//\\n// Color & Scene\\n//\\n\\nbool world_hit(const in ray r, const in float t_min, \\n               const in float t_max, out hit_record rec) {\\n    rec.t = t_max;\\n    bool hit = false;\\n        \\n    if (hitable_hit(hitable(BOX, vec3(273,555,279.5), vec3(150,.1,132.5), 0.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(DIFFUSE_LIGHT, NO_TEX, texture_(SOLID,vec3(7)),0.);   \\n    \\n    if (hitable_hit(hitable(MOVING_SPHERE, vec3(400,400,200), vec3(30,0,0), 50.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(LAMBERTIAN, texture_(SOLID,vec3(.7,.3,.1)), NO_TEX,0.);\\n    if (hitable_hit(hitable(SPHERE, vec3(260,150,45), vec3(0), 50.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(DIELECTRIC, NO_TEX, NO_TEX,1.5);\\n    if (hitable_hit(hitable(SPHERE, vec3(0,150,145), vec3(0), 50.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(METAL, texture_(SOLID,vec3(.8,.8,.9)), NO_TEX,1.);\\n    if (hitable_hit(hitable(SPHERE, vec3(220,280,300), vec3(0), 80.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(LAMBERTIAN, texture_(NOISE,vec3(.1)), NO_TEX,.1);\\n    \\n    if (hitable_hit(hitable(SPHERE, vec3(360, 150, 145), vec3(0), 70.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(DIELECTRIC, NO_TEX, NO_TEX,1.5);\\n    if (hitable_hit(hitable(CONSTANT_MEDIUM_SPHERE, vec3(360, 150, 145), vec3(70), .2),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(ISOTROPIC, texture_(SOLID,vec3(.2,.4,.9)), NO_TEX,0.);\\n        \\n    if (hitable_hit(hitable(SPHERE, vec3(400,200,400), vec3(0), 100.),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(DIELECTRIC, NO_TEX, NO_TEX, 1.04);\\n    if (hitable_hit(hitable(CONSTANT_MEDIUM_SPHERE, vec3(400,200,400), vec3(100), .1),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(ISOTROPIC, texture_(SOLID,vec3(.4,.5,.7)), NO_TEX,0.);\\n    \\n    if (hitable_hit(hitable(CONSTANT_MEDIUM_SPHERE, vec3(0), vec3(1000), .0001),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=material(ISOTROPIC, texture_(SOLID,vec3(1)), NO_TEX,0.);\\n    \\n// A 2D grid for the ground and a 3D grid for the cube with spheres are implemented as an optimization    \\n    \\n// cube with spheres\\n    ray r_ = ray_rotate_y(ray_translate(r, vec3(-100,270,395)+82.5), 15./180.*3.14159265359);\\n    vec3 normal; float dist;\\n    if (box_intersect(r_,EPSILON,MAX_FLOAT, vec3(0), vec3(100), normal, dist)) {\\n        const float cubeGridScale = 20.;   \\n        vec3 ro = r_.origin/cubeGridScale;\\n        vec3 pos = floor(ro + (all(lessThan(abs(r_.origin),vec3(100)))?EPSILON:dist)*r_.direction/cubeGridScale);\\n        vec3 rdi = 1./r_.direction;\\n        vec3 rda = abs(rdi);\\n        vec3 rds = sign(r.direction);\\n        vec3 dis = (pos-ro+ .5 + rds*.5) * rdi;\\n\\t\\tbool b_hit = false;\\n        \\n        // traverse grid in 3D\\n        vec3 mm = vec3(0);\\n        int steps = 12 + min(0,iFrame);\\n        for (int i=0; i<steps; i++) {\\n            for(float x=-1.;x<=1.;x+=1.) {\\n                for(float y=-1.;y<=1.;y+=1.) {\\n                    for(float z=-1.;z<=1.;z+=1.) {\\n                        vec3 posc = pos + vec3(x,y,z);\\n                        if (all(lessThan(abs(posc),vec3(4.1)))) { \\n                            float seed = dot(posc, vec3(.1,.11,.111));\\n                            vec3 scenter = posc*cubeGridScale + cubeGridScale*((hash3(seed)-.5)*.75);\\n                            hit_record rec_ = rec;\\n                            if (hitable_hit(hitable(SPHERE, scenter, vec3(0),10.),r_,t_min,rec_.t,rec_)) \\n                                b_hit=true, \\n                                rec=hit_record_translate(hit_record_rotate_y(rec_,-15./180.*3.14159265359),-82.5-vec3(-100,270,395)), \\n                                rec.mat=material(LAMBERTIAN, texture_(SOLID,vec3(.73)), NO_TEX,0.);  \\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(b_hit) {\\n                hit=true;\\n                break;\\n            }\\n            \\n            // step to next cell\\t\\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\\n            dis += mm * rda;\\n            pos += mm * rds;\\n        }\\n    }\\n    \\n// floor     \\n    if (r.origin.y < 101. || r.direction.y < 0.) {\\n   \\t\\tconst float floorGridScale = 100.;   \\n        vec3 ro = r.origin/floorGridScale;\\n        vec2 pos = floor(ro.xz);\\n        vec3 rdi = 1./r.direction;\\n        vec3 rda = abs(rdi);\\n        vec2 rds = sign(r.direction.xz);\\n        vec2 dis = (pos-ro.xz+ .5 + rds*.5) * rdi.xz;\\n\\t\\tbool b_hit = false;\\n\\n        // traverse grid in 2D\\n        vec2 mm = vec2(0);\\n        int steps = 26 + min(0,iFrame);\\n        for (int i=0; i<steps; i++) {\\n            float seed = dot(pos, vec2(.7,.17));\\n\\t\\t\\tvec3 bcenter = vec3(pos.x*floorGridScale+floorGridScale*.5,0,pos.y*floorGridScale+.5*floorGridScale);\\n            vec3 bsize = vec3(floorGridScale*.5,100.*(hash1(seed)+0.01),floorGridScale*.5);\\n\\n            if (hitable_hit(hitable(BOX, bcenter, bsize, 0.),r,t_min,rec.t,rec)) \\n                b_hit=true, rec.mat=material(LAMBERTIAN, texture_(SOLID,vec3(.48,.83,.53)), NO_TEX,0.);     \\n            \\n            if(b_hit) {\\n                hit = true;\\n                break;\\n            }\\n            \\n            // step to next cell\\t\\t\\n            mm = step( dis.xy, dis.yx ); \\n            dis += mm*rda.xz;\\n            pos += mm*rds;\\n        }\\n    }\\n   \\n    return hit;\\n}\\n\\nvec3 color(in ray r) {\\n    vec3 col = vec3(0);\\n    vec3 emitted = vec3(0);\\n\\thit_record rec;\\n    \\n    for (int i=0; i<MAX_RECURSION; i++) {\\n    \\tif (world_hit(r, EPSILON, MAX_FLOAT, rec)) {\\n            ray scattered;\\n            vec3 attenuation;\\n            vec3 emit = material_emitted(rec);\\n            emitted += i == 0 ? emit : col * emit;\\n            \\n            if (material_scatter(r, rec, attenuation, scattered)) {\\n                col = i == 0 ? attenuation : col * attenuation;\\n                r = scattered;\\n            } else {\\n                return emitted;\\n            }\\n\\t    } else {\\n            return emitted;\\n    \\t}\\n        if(dot(col,col) < 0.0001) return emitted; // optimisation\\n    }\\n    return emitted;\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\\n    if (ivec2(frag_coord) == ivec2(0)) {\\n        frag_color = iResolution.xyxy;\\n    } else {\\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\\n\\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\\n        float aspect = iResolution.x/iResolution.y;\\n        vec3 lookfrom = vec3(478, 278, -600);\\n        vec3 lookat = vec3(278,278,0);\\n        \\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 40., aspect, 2.0, 800., 0., 1.);\\n        ray r = camera_get_ray(cam, uv);\\n        vec3 col = color(r);\\n        \\n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \\n\\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\\n        } else {        \\n\\t        frag_color = vec4(col,1);\\n        }\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XttfRN","date":"1538844868","viewed":2199,"name":"Menger Sponge - iOS AR","description":"This is an experiment to create an \\"AR shader\\" by implementing the mainVR-function and using the WebCam texture as background. Use the [url=https://itunes.apple.com/us/app/shadertoy/id717961814]Shadertoy iOS app[/url] to view this shader.","likes":5,"published":"Public API","usePreview":0,"tags":["menger","ar","sponge","ios"]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Menger Sponge - iOS AR. Created by Reinder Nijhoff 2018\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/XttfRN\\n//\\n// This is an experiment to create an \\"AR shader\\" by implementing the mainVR-function and \\n// using the WebCam texture as background. If you view this shader with the Shadertoy iOS \\n// app[1], you can walk around the cube to view it from all sides.\\n//\\n// If you don't have an iOS device (or if you don't have the app installed) you can find a\\n// screen capture of the shader in action here: https://youtu.be/7woT6cTx-bo.\\n//\\n// The SDF of this shader is based on the \\"Menger Sponge\\" shader by igo Qulez:\\n// https://www.shadertoy.com/view/4sX3Rn\\n//\\n// [1] https://itunes.apple.com/us/app/shadertoy/id717961814\\n//\\n\\nfloat sdBox( vec3 p, vec3 b ) {\\n  vec3  di = abs(p) - b;\\n  float mc = max(di.x,max(di.y,di.z));\\n  return min(mc,length(max(di,0.0)));\\n}\\n\\nfloat boxIntersect( in vec3 ro, in vec3 rd, in vec3 rad ) {\\n    vec3 m = 1.0/rd;\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*rad;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n\\tif( tN > tF || tF < 0.0) return 1e30;\\n\\treturn tN;\\n}\\n\\nfloat map( in vec3 p ) {\\n    float d = sdBox(p,vec3(1.0));\\n    float s = .5;\\n    for( int m=0; m<4; m++ ) {\\n        vec3 a = fract( p*s )-.5;\\n        s *= 3.;\\n        vec3 r = abs(1.-6.*abs(a));\\n        float da = max(r.x,r.y);\\n        float db = max(r.y,r.z);\\n        float dc = max(r.z,r.x);\\n        float c = (min(da,min(db,dc))-1.0)/(2.*s);\\n\\n        if( c>d ) {\\n          d = c;\\n        }\\n    }\\n    return d;\\n}\\n\\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\\n\\tfloat res = 1.0;\\n    float t = mint;\\n    float ph = 1e10; \\n    for( int i=0; i<32; i++ ) {\\n\\t\\tfloat h = map( ro + rd*t );\\n       \\tfloat y = h*h/(2.0*ph);\\n        float d = sqrt(max(0.,h*h-y*y));\\n        res = min( res, 8.0*d/max(0.0001,t-y) );\\n        ph = h;\\n        t += h;//min(h, .1);// clamp( h, 0.02, 0.10 );\\n        if( res<0.001 || t>tmax ) break;\\n    }\\n    return clamp( res, 0.0, 1.0 );\\n}\\n\\nfloat calcAO( in vec3 pos, in vec3 nor ) {\\n\\tfloat occ = 0.0;\\n    float sca = 1.0;\\n    for( int i=0; i<5; i++ ) {\\n        float hr = 0.01 + 0.5*float(i)/4.0;\\n        vec3 aopos =  nor * hr + pos;\\n        float dd = map( aopos );\\n        occ += -(dd-hr)*sca;\\n        sca *= 0.9;\\n    }\\n    return clamp( 1. - 3.0*occ, 0.0, 1.0 );    \\n}\\n\\nvec3 calcNormal(in vec3 pos) {\\n    vec3  eps = vec3(.001,0.0,0.0);\\n    vec3 nor;\\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\\n    return normalize(nor);\\n}\\n\\nvec4 tex3D( sampler2D sam, in vec3 p, in vec3 n ) {\\n\\tvec4 x = texture( sam, p.yz );\\n\\tvec4 y = texture( sam, p.zx );\\n\\tvec4 z = texture( sam, p.xy );\\n\\n\\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\\n}\\n\\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in sampler2D tex ) {\\n    ro *= 2.; // scale scene\\n    const float tmax = 100.;\\n    vec3 lightDir = normalize(vec3(0.7,1.,.2));\\n    float tmin = boxIntersect(ro, rd, vec3(1.));\\n    if (all(lessThan(abs(ro),vec3(1)))) tmin = 0.01;\\n    \\n    float t = tmin;\\n    for( int i=0; i<64; i++ ) {\\n\\t    float precis = 0.001*t;\\n\\t    float d = map( ro+rd*t );\\n        if( abs(d)<precis || t>tmax ) break;\\n        t += d;\\n    }\\n    \\n    vec3 col = texture(tex, uv).xyz;\\n    // Use mipmap level 9 to get an average environment color from the webcam texture\\n    // used for lighting.\\n    vec3 lightColor = pow(.25 + .75 * texelFetch(tex, ivec2(0), 9).rgb, vec3(2.2)) * 3.;\\n    \\n    if (t < tmax) {\\n        vec3 p = ro + t * rd;\\n  \\t\\tvec3 n = calcNormal(p);\\n        vec3 ref = reflect(rd, n);\\n\\n        float ao = .4 + .6 * calcAO(p, n);\\n        float sh = .4 + .6 * calcSoftshadow(p, lightDir, 0.005, 1.);\\n    \\n        float diff = max(0.,dot(lightDir,n)) * ao * sh;\\n        float amb  = (.4+.2*n.y) * ao * sh;\\n\\t\\tfloat spe = pow(clamp(dot(ref,lightDir), 0., 1.),8.) * sh * .5;\\n           \\n        vec3 mat = tex3D(iChannel2, p, n).rgb;\\n        col = (amb + diff) * mix(vec3(.4,.6,.8),vec3(.1,.2,.3),mat.r) + spe * dot(mat,mat);\\n        col *= lightColor;\\n    }\\n    \\n    // gamma\\n    col = mix(col, sqrt(clamp(col,vec3(0),vec3(1))), .95);\\n    \\n    return clamp(col,vec3(0),vec3(1));\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv = normalize( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\\n   \\n    float a = .3 * iTime;\\n    vec3 ro = 2. * vec3( sin(a), .1, cos(a) );\\n    vec3 ta = vec3( 0.0, 0., 0.0 );\\n    \\n    mat3 ca = setCamera( ro, ta, 0.0 );\\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\\n\\n    vec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, iChannel1 );\\n    fragColor = vec4(col,1.0);\\n}\\n\\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\\n    ro += vec3(0,0.5,1.5);\\n    vec3 col = render( ro, rd, fragCoord.xy/iResolution.xy, iChannel0 );\\n    fragColor = vec4(col,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3dfGR2","date":"1547043986","viewed":6432,"name":"Yet another Cornell Box","description":"Yet another Cornell Box. I have optimised the code of [url=https://www.shadertoy.com/view/XlGcWD]RIOW 2.07: Instances[/url] for the Cornell Box and added direct light sampling to reduce noise. Only Lambertian solid materials and cubes are supported. ","likes":52,"published":"Public API","usePreview":0,"tags":["ray","cornellbox","pathtracer","box","cornell","tracer","path"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Yet another Cornell Box. Created by Reinder Nijhoff 2019\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/3dfGR2\\n// \\n// Yet another Cornell Box. I have optimised the code of my shader \\"RIOW 2.07: Instances\\"\\n// for the Cornell Box and added direct light sampling to reduce noise. Only Lambertian \\n// solid materials and cubes are supported. \\n//\\n// These shaders are my implementation of the raytracer described in the (excellent) \\n// book \\"Ray tracing in one weekend\\" and \\"Ray tracing: the next week\\"[1] by Peter Shirley \\n// (@Peter_shirley).\\n//\\n// = Ray tracing in one week =\\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\\n//\\n// = Ray tracing: the next week =\\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\\n//\\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\\n//\\n\\n#define MOVE_CAMERA\\n\\n#define MAX_FLOAT 1e5\\n#define EPSILON 0.01\\n#define MAX_RECURSION 3\\n#define SAMPLES (12+min(0,iFrame))\\n\\n#define LAMBERTIAN 0\\n#define DIFFUSE_LIGHT 1\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint base_hash(uvec2 p) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat g_seed = 0.;\\n\\nvec2 hash2(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\nvec3 hash3(inout float seed) {\\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Ray trace helper functions\\n//\\n\\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n\\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\\n\\tvec3  vv = cross(uu, n);\\n\\tfloat ra = sqrt(r.y);\\n\\tfloat rx = ra*cos(6.28318530718*r.x); \\n\\tfloat ry = ra*sin(6.28318530718*r.x);\\n\\tfloat rz = sqrt(1.-r.y);\\n\\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\\n    return normalize(rr);\\n}\\n\\nvec2 random_in_unit_disk(inout float seed) {\\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r * vec2(sin(phi),cos(phi));\\n}\\n\\nvec3 rotate_y(const in vec3 p, const in float t) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\\n    return vec3(xz.x, p.y, xz.y);\\n}\\n\\n//\\n// Ray\\n//\\n\\nstruct ray {\\n    vec3 origin, direction;\\n};\\n\\nray ray_translate(const in ray r, const in vec3 t) {\\n    ray rt = r;\\n    rt.origin -= t;\\n    return rt;\\n}\\n\\nray ray_rotate_y(const in ray r, const in float t) {\\n    ray rt = r;\\n    rt.origin = rotate_y(rt.origin, t);\\n    rt.direction = rotate_y(rt.direction, t);\\n    return rt;\\n}\\n\\n//\\n// Material\\n//\\n\\nstruct material {\\n    int type;\\n    vec3 color;\\n};\\n\\n//\\n// Hit record\\n//\\n\\nstruct hit_record {\\n    float t;\\n    vec3 p, normal;\\n    material mat;\\n};\\n\\nhit_record hit_record_translate(const in hit_record h, const in vec3 t) {\\n    hit_record ht = h;\\n    ht.p -= t;\\n    return ht;\\n}\\n   \\nhit_record hit_record_rotate_y(const in hit_record h, const in float t) {\\n    hit_record ht = h;\\n    ht.p = rotate_y(ht.p, t);\\n    ht.normal = rotate_y(ht.normal, t);\\n    return ht;\\n}\\n\\nvoid material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \\n                      out ray scattered) {\\n    scattered = ray(rec.p, random_cos_weighted_hemisphere_direction(rec.normal, g_seed));\\n    attenuation = rec.mat.color;\\n}\\n\\nvec3 material_emitted(const in hit_record rec) {\\n    if (rec.mat.type == DIFFUSE_LIGHT) {\\n        return rec.mat.color;\\n    } else {\\n        return vec3(0);\\n    }\\n}\\n\\n//\\n// Hitable\\n//\\n\\nstruct hitable { // always a box\\n    vec3 center, dimension; \\n};\\n    \\nbool box_intersect(const in ray r, const in float t_min, const in float t_max,\\n                   const in vec3 center, const in vec3 rad, out vec3 normal, inout float dist) {\\n    vec3 m = 1./r.direction;\\n    vec3 n = m*(r.origin - center);\\n    vec3 k = abs(m)*rad;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n\\tif( tN > tF || tF < 0.) return false;\\n    \\n    float t = tN < t_min ? tF : tN;\\n    if (t < t_max && t > t_min) {\\n        dist = t;\\n\\t\\tnormal = -sign(r.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n\\t    return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \\n                 const in float t_max, inout hit_record rec) {\\n    float dist;\\n    vec3 normal;\\n    if (box_intersect(r, t_min, t_max, hb.center, hb.dimension, normal, dist)) {\\n        rec.t = dist;\\n        rec.p = r.origin + dist*r.direction;\\n        rec.normal = normal;\\n        return true;\\n    } else {\\n        return false;\\n    }\\n}\\n\\n//\\n// Camera\\n//\\n\\nstruct camera {\\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\\n    float lens_radius;\\n};\\n\\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \\n                    const in float vfov, const in float aspect, const in float aperture, \\n                    const in float focus_dist) {\\n    camera cam;    \\n    cam.lens_radius = aperture / 2.;\\n    float theta = vfov*3.14159265359/180.;\\n    float half_height = tan(theta/2.);\\n    float half_width = aspect * half_height;\\n    cam.origin = lookfrom;\\n    cam.w = normalize(lookfrom - lookat);\\n    cam.u = normalize(cross(vup, cam.w));\\n    cam.v = cross(cam.w, cam.u);\\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\\n    return cam;\\n}\\n    \\nray camera_get_ray(camera c, vec2 uv) {\\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\\n    vec3 offset = c.u * rd.x + c.v * rd.y;\\n    return ray(c.origin + offset, \\n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset));\\n}\\n\\n//\\n// Color & Scene\\n//\\n\\nbool world_hit(const in ray r, const in float t_min, \\n               const in float t_max, out hit_record rec) {\\n    rec.t = t_max;\\n    bool hit = false;\\n\\n    const material red = material(LAMBERTIAN, vec3(.65,.05,.05));\\n    const material white = material(LAMBERTIAN, vec3(.73));\\n    const material green = material(LAMBERTIAN, vec3(.12,.45,.15));\\n\\n    const material light = material(DIFFUSE_LIGHT, vec3(15));\\n    \\n    if (hitable_hit(hitable(vec3(278,555,279.5), vec3(65,1,52.5)),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=light;   \\n   \\n    ray r_ = ray_rotate_y(ray_translate(r, vec3(130,0,65)), -18./180.*3.14159265359);\\n    hit_record rec_ = rec;    \\n    if (hitable_hit(hitable(vec3(82.5), vec3(82.5)),r_,t_min,rec.t,rec_)) \\n        hit=true, \\n        rec=hit_record_translate(hit_record_rotate_y(rec_, 18./180.*3.14159265359),-vec3(130,0,65.)), \\n        rec.mat=white;\\n    \\n\\tr_ = ray_rotate_y(ray_translate(r, vec3(265,0,295)), 15./180.*3.14159265359);\\n    rec_ = rec;    \\n    if (hitable_hit(hitable(vec3(82.5,165,82.5), vec3(82.5,165,82.5)),r_,t_min,rec.t,rec_)) \\n        hit=true, \\n        rec=hit_record_translate(hit_record_rotate_y(rec_, -15./180.*3.14159265359),-vec3(265,0,295)), \\n        rec.mat=white;\\n\\n  \\tif (hitable_hit(hitable(vec3(556,277.5,277.5), vec3(1,277.5,277.5)),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=red;\\n    if (hitable_hit(hitable(vec3(-1,277.5,277.5), vec3(1,277.5,277.5)),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=green;\\n   \\n    if (hitable_hit(hitable(vec3(277.5,556,277.5), vec3(277.5,1,277.5)),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=white;\\n    if (hitable_hit(hitable(vec3(277.5,-1,277.5), vec3(277.5,1,277.5)),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=white;\\n    if (hitable_hit(hitable(vec3(277.5,277.5,556), vec3(277.5,277.5,1)),r,t_min,rec.t,rec)) \\n        hit=true, rec.mat=white;\\n    \\n    return hit;\\n}\\n\\n\\nbool shadow_hit(const in ray r, const in float t_min, const in float t_max) {\\n    hit_record rec;\\n    rec.t = t_max;\\n   \\n    ray r_ = ray_rotate_y(ray_translate(r, vec3(130,0,65)), -18./180.*3.14159265359);  \\n    if (hitable_hit(hitable(vec3(82.5), vec3(82.5)),r_,t_min,rec.t,rec)) \\n        return true;\\n    \\n\\tr_ = ray_rotate_y(ray_translate(r, vec3(265,0,295)), 15./180.*3.14159265359);  \\n    if (hitable_hit(hitable(vec3(82.5,165,82.5), vec3(82.5,165,82.5)),r_,t_min,rec.t,rec)) \\n        return true;\\n  \\n    return false;\\n}\\n\\nvec3 color(in ray r) {\\n    vec3 col = vec3(0);\\n    vec3 emitted = vec3(0);\\n\\thit_record rec;\\n    \\n    for (int i=0; i<MAX_RECURSION && world_hit(r, EPSILON, MAX_FLOAT, rec); i++) {\\n        if (rec.mat.type == DIFFUSE_LIGHT) { // direct light sampling code\\n            return i == 0 ? rec.mat.color : emitted;\\n        }\\n\\n        vec3 attenuation;\\n        material_scatter(r, rec, attenuation, r);\\n        col = i == 0 ? attenuation : col * attenuation;\\n\\n        // direct light sampling\\n        vec3 pointInSource = (2.*hash3(g_seed)-1.) * vec3(65,1,52.5) + vec3(278,555,279.5);\\n        vec3 L = pointInSource - rec.p;\\n        float rr = dot(L, L);\\n        L = normalize(L);\\n\\n        ray shadowRay = ray(rec.p, L);\\n        if (L.y > 0.01 && dot(rec.normal, L) > 0. && !shadow_hit(shadowRay, .01, 1000.)) {\\n\\t        const float area = (65.*52.5*4.);\\n            float weight = area * L.y * dot(rec.normal, L) / (3.14 * rr);\\n            emitted += col * 15. * weight;\\n        }\\n    }\\n    return emitted;\\n}\\n\\n//\\n// Main\\n//\\n\\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\\n    float aspect = iResolution.x/iResolution.y;\\n#ifdef MOVE_CAMERA\\n    vec3 lookfrom = vec3(278. + sin(iTime * .7)*200., 278, -800. + sin(iTime)*100.);\\n#else\\n    vec3 lookfrom = vec3(278. , 278, -800.);\\n#endif\\n    vec3 lookat = vec3(278,278,0);\\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\\n\\n    vec3 tcol = vec3(0);\\n    \\n    for (int i=0, l = SAMPLES; i<l; i++) {\\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\\n\\n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 40., aspect, .0, 10.);\\n        ray r = camera_get_ray(cam, uv);\\n        tcol += color(r);\\n    }\\n    \\n    frag_color = vec4(sqrt(tcol / float(SAMPLES)), 1.);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tl23Rm","date":"1559573266","viewed":19614,"name":"Ray Tracing - Primitives","description":"This is a collection of ray-primitive intersection routines ([url=http://iquilezles.org/articles/intersectors/intersectors.htm]by igo Qulez[/url]).\\n\\nUse your mouse to change the camera viewpoint.","likes":216,"published":"Public API","usePreview":0,"tags":["3d","raytracer","ray","intersection","dof","primitives","field","tracing","depth","path","of"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\\n// The MIT License\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/tl23Rm\\n//\\n// I wanted to create a reference shader similar to \\"Raymarching - Primitives\\" \\n// (https://www.shadertoy.com/view/Xds3zN), but with ray-primitive intersection \\n// routines instead of sdf routines.\\n// \\n// As usual, I ended up mostly just copy-pasting code from igo Qulez: \\n// \\n// https://iquilezles.org/articles/intersectors\\n// \\n// Please let me know if there are other routines that I should add to this shader.\\n// \\n// You can find all intersection routines in the Common tab. The routines have a similar \\n// signature: a routine returns the distance to the first hit inside the \\n// [distBound.x, distBound.y] interval and will set the normal if an intersection is found.\\n// If no intersection is found, the routine will return MAX_DIST.\\n//\\n// I made a simple ray tracer (Buffer A) to visualize a scene with all primitives.\\n//\\n// Use your mouse to change the camera viewpoint.\\n//\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\\n    vec3 col = data.rgb / data.w;\\n    \\n    // gamma correction\\n    col = max( vec3(0), col - 0.004);\\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\\n    \\n    // Output to screen\\n    fragColor = vec4(col,1.0);\\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\\n// The MIT License\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/tl23Rm\\n//\\n// I wanted to create a reference shader similar to \\"Raymarching - Primitives\\" \\n// (https://www.shadertoy.com/view/Xds3zN), but with ray-primitive intersection \\n// routines instead of sdf routines.\\n// \\n// As usual, I ended up mostly just copy-pasting code from igo Qulez: \\n// \\n// https://iquilezles.org/articles/intersectors\\n// \\n// Please let me know if there are other routines that I should add to this shader.\\n// \\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\\n// Box:             https://www.shadertoy.com/view/ld23DV\\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\\n// Torus:           https://www.shadertoy.com/view/4sBGDy\\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\\n//\\n// Disk:            https://www.shadertoy.com/view/lsfGDB\\n//\\n\\n#define MAX_DIST 1e10\\nfloat dot2( in vec3 v ) { return dot(v,v); }\\n\\n// Plane \\nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n              in vec3 planeNormal, in float planeDist) {\\n    float a = dot(rd, planeNormal);\\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\\n    if (a > 0. || d < distBound.x || d > distBound.y) {\\n        return MAX_DIST;\\n    } else {\\n        normal = planeNormal;\\n    \\treturn d;\\n    }\\n}\\n\\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n               float sphereRadius ) {\\n    float b = dot(ro, rd);\\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\\n    float h = b*b - c;\\n    if (h < 0.) {\\n        return MAX_DIST;\\n    } else {\\n\\t    h = sqrt(h);\\n        float d1 = -b-h;\\n        float d2 = -b+h;\\n        if (d1 >= distBound.x && d1 <= distBound.y) {\\n            normal = normalize(ro + rd*d1);\\n            return d1;\\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \\n            normal = normalize(ro + rd*d2);            \\n            return d2;\\n        } else {\\n            return MAX_DIST;\\n        }\\n    }\\n}\\n\\n// Box:             https://www.shadertoy.com/view/ld23DV\\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \\n            in vec3 boxSize ) {\\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*boxSize;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n    if (tN > tF || tF <= 0.) {\\n        return MAX_DIST;\\n    } else {\\n        if (tN >= distBound.x && tN <= distBound.y) {\\n        \\tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n            return tN;\\n        } else if (tF >= distBound.x && tF <= distBound.y) { \\n        \\tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n            return tF;\\n        } else {\\n            return MAX_DIST;\\n        }\\n    }\\n}\\n\\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n                 in vec3 pa, in vec3 pb, float ra ) {\\n    vec3 ca = pb-pa;\\n    vec3 oc = ro-pa;\\n\\n    float caca = dot(ca,ca);\\n    float card = dot(ca,rd);\\n    float caoc = dot(ca,oc);\\n    \\n    float a = caca - card*card;\\n    float b = caca*dot( oc, rd) - caoc*card;\\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\\n    float h = b*b - a*c;\\n    \\n    if (h < 0.) return MAX_DIST;\\n    \\n    h = sqrt(h);\\n    float d = (-b-h)/a;\\n\\n    float y = caoc + d*card;\\n    if (y > 0. && y < caca && d >= distBound.x && d <= distBound.y) {\\n        normal = (oc+d*rd-ca*y/caca)/ra;\\n        return d;\\n    }\\n\\n    d = ((y < 0. ? 0. : caca) - caoc)/card;\\n    \\n    if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\\n        normal = normalize(ca*sign(y)/caca);\\n        return d;\\n    } else {\\n        return MAX_DIST;\\n    }\\n}\\n\\n// Torus:           https://www.shadertoy.com/view/4sBGDy\\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n              in vec2 torus ) {\\n    // bounding sphere\\n    vec3 tmpnormal;\\n    if (iSphere(ro, rd, distBound, tmpnormal, torus.y+torus.x) > distBound.y) {\\n        return MAX_DIST;\\n    }\\n    \\n    float po = 1.0;\\n    \\n\\tfloat Ra2 = torus.x*torus.x;\\n\\tfloat ra2 = torus.y*torus.y;\\n\\t\\n\\tfloat m = dot(ro,ro);\\n\\tfloat n = dot(ro,rd);\\n\\n#if 1\\n\\tfloat k = (m + Ra2 - ra2)/2.0;\\n    float k3 = n;\\n\\tfloat k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\\n#else\\n\\tfloat k = (m - Ra2 - ra2)/2.0;\\n\\tfloat k3 = n;\\n\\tfloat k2 = n*n + Ra2*rd.z*rd.z + k;\\n\\tfloat k1 = k*n + Ra2*ro.z*rd.z;\\n\\tfloat k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\\n#endif\\n    \\n#if 1\\n    // prevent |c1| from being too close to zero\\n    if (abs(k3*(k3*k3-k2)+k1) < 0.01) {\\n        po = -1.0;\\n        float tmp=k1; k1=k3; k3=tmp;\\n        k0 = 1.0/k0;\\n        k1 = k1*k0;\\n        k2 = k2*k0;\\n        k3 = k3*k0;\\n    }\\n#endif\\n    \\n    // reduced cubic\\n    float c2 = k2*2.0 - 3.0*k3*k3;\\n    float c1 = k3*(k3*k3-k2)+k1;\\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\\n    \\n    c2 /= 3.0;\\n    c1 *= 2.0;\\n    c0 /= 3.0;\\n\\n    float Q = c2*c2 + c0;\\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\\n    \\n    float h = R*R - Q*Q*Q;\\n    float t = MAX_DIST;\\n    \\n    if (h>=0.0) {\\n        // 2 intersections\\n        h = sqrt(h);\\n        \\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\\n\\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\\n    \\n        float y = sqrt(0.5*(length(s)+s.x));\\n        float x = 0.5*s.y/y;\\n        float r = 2.0*c1/(x*x+y*y);\\n\\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\\n\\n        if (t1 >= distBound.x) t=t1;\\n        if (t2 >= distBound.x) t=min(t,t2);\\n\\t} else {\\n        // 4 intersections\\n        float sQ = sqrt(Q);\\n        float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\\n\\n        float d2 = -(w+c2); if( d2<0.0 ) return MAX_DIST;\\n        float d1 = sqrt(d2);\\n\\n        float h1 = sqrt(w - 2.0*c2 + c1/d1);\\n        float h2 = sqrt(w - 2.0*c2 - c1/d1);\\n        float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\\n        float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\\n        float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\\n        float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\\n\\n        if (t1 >= distBound.x) t=t1;\\n        if (t2 >= distBound.x) t=min(t,t2);\\n        if (t3 >= distBound.x) t=min(t,t3);\\n        if (t4 >= distBound.x) t=min(t,t4);\\n    }\\n    \\n\\tif (t >= distBound.x && t <= distBound.y) {\\n        vec3 pos = ro + rd*t;\\n        normal = normalize( pos*(dot(pos,pos) - torus.y*torus.y - torus.x*torus.x*vec3(1,1,-1)));\\n        return t;\\n    } else {\\n        return MAX_DIST;\\n    }\\n}\\n\\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n                in vec3 pa, in vec3 pb, in float r ) {\\n    vec3  ba = pb - pa;\\n    vec3  oa = ro - pa;\\n\\n    float baba = dot(ba,ba);\\n    float bard = dot(ba,rd);\\n    float baoa = dot(ba,oa);\\n    float rdoa = dot(rd,oa);\\n    float oaoa = dot(oa,oa);\\n\\n    float a = baba      - bard*bard;\\n    float b = baba*rdoa - baoa*bard;\\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\\n    float h = b*b - a*c;\\n    if (h >= 0.) {\\n        float t = (-b-sqrt(h))/a;\\n        float d = MAX_DIST;\\n        \\n        float y = baoa + t*bard;\\n        \\n        // body\\n        if (y > 0. && y < baba) {\\n            d = t;\\n        } else {\\n            // caps\\n            vec3 oc = (y <= 0.) ? oa : ro - pb;\\n            b = dot(rd,oc);\\n            c = dot(oc,oc) - r*r;\\n            h = b*b - c;\\n            if( h>0.0 ) {\\n                d = -b - sqrt(h);\\n            }\\n        }\\n        if (d >= distBound.x && d <= distBound.y) {\\n            vec3  pa = ro + rd * d - pa;\\n            float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\\n            normal = (pa - h*ba)/r;\\n            return d;\\n        }\\n    }\\n    return MAX_DIST;\\n}\\n\\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\\nfloat iCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n             in vec3  pa, in vec3  pb, in float ra, in float rb ) {\\n    vec3  ba = pb - pa;\\n    vec3  oa = ro - pa;\\n    vec3  ob = ro - pb;\\n    \\n    float m0 = dot(ba,ba);\\n    float m1 = dot(oa,ba);\\n    float m2 = dot(ob,ba); \\n    float m3 = dot(rd,ba);\\n\\n    //caps\\n    if (m1 < 0.) { \\n        if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) {\\n            float d = -m1/m3;\\n            if (d >= distBound.x && d <= distBound.y) {\\n                normal = -ba*inversesqrt(m0);\\n                return d;\\n            }\\n        }\\n    }\\n    else if (m2 > 0.) { \\n        if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) {\\n            float d = -m2/m3;\\n            if (d >= distBound.x && d <= distBound.y) {\\n                normal = ba*inversesqrt(m0);\\n                return d;\\n            }\\n        }\\n    }\\n                       \\n    // body\\n    float m4 = dot(rd,oa);\\n    float m5 = dot(oa,oa);\\n    float rr = ra - rb;\\n    float hy = m0 + rr*rr;\\n    \\n    float k2 = m0*m0    - m3*m3*hy;\\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\\n    \\n    float h = k1*k1 - k2*k0;\\n    if( h < 0. ) return MAX_DIST;\\n\\n    float t = (-k1-sqrt(h))/k2;\\n\\n    float y = m1 + t*m3;\\n    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {\\n        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);\\n        return t;\\n    } else {   \\n\\t    return MAX_DIST;\\n    }\\n}\\n\\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\\nfloat iEllipsoid( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n                  in vec3 rad ) {\\n    vec3 ocn = ro / rad;\\n    vec3 rdn = rd / rad;\\n    \\n    float a = dot( rdn, rdn );\\n\\tfloat b = dot( ocn, rdn );\\n\\tfloat c = dot( ocn, ocn );\\n\\tfloat h = b*b - a*(c-1.);\\n    \\n    if (h < 0.) {\\n        return MAX_DIST;\\n    }\\n    \\n\\tfloat d = (-b - sqrt(h))/a;\\n    \\n    if (d < distBound.x || d > distBound.y) {\\n        return MAX_DIST;\\n    } else {\\n        normal = normalize((ro + d*rd)/rad);\\n    \\treturn d;\\n    }\\n}\\n\\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\\nfloat iRoundedCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n                    in vec3  pa, in vec3  pb, in float ra, in float rb ) {\\n    vec3  ba = pb - pa;\\n\\tvec3  oa = ro - pa;\\n\\tvec3  ob = ro - pb;\\n    float rr = ra - rb;\\n    float m0 = dot(ba,ba);\\n    float m1 = dot(ba,oa);\\n    float m2 = dot(ba,rd);\\n    float m3 = dot(rd,oa);\\n    float m5 = dot(oa,oa);\\n\\tfloat m6 = dot(ob,rd);\\n    float m7 = dot(ob,ob);\\n    \\n    float d2 = m0-rr*rr;\\n    \\n\\tfloat k2 = d2    - m2*m2;\\n    float k1 = d2*m3 - m1*m2 + m2*rr*ra;\\n    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2. - m0*ra*ra;\\n    \\n\\tfloat h = k1*k1 - k0*k2;\\n    if (h < 0.0) {\\n        return MAX_DIST;\\n    }\\n    \\n    float t = (-sqrt(h)-k1)/k2;\\n    \\n    float y = m1 - ra*rr + t*m2;\\n    if (y>0.0 && y<d2) {\\n        if (t >= distBound.x && t <= distBound.y) {\\n        \\tnormal = normalize( d2*(oa + t*rd)-ba*y );\\n            return t;\\n        } else {\\n            return MAX_DIST;\\n        }\\n    } else {\\n        float h1 = m3*m3 - m5 + ra*ra;\\n        float h2 = m6*m6 - m7 + rb*rb;\\n\\n        if (max(h1,h2)<0.0) {\\n            return MAX_DIST;\\n        }\\n\\n        vec3 n = vec3(0);\\n        float r = MAX_DIST;\\n\\n        if (h1 > 0.) {        \\n            r = -m3 - sqrt( h1 );\\n            n = (oa+r*rd)/ra;\\n        }\\n        if (h2 > 0.) {\\n            t = -m6 - sqrt( h2 );\\n            if( t<r ) {\\n                n = (ob+t*rd)/rb;\\n                r = t;\\n            }\\n        }\\n        if (r >= distBound.x && r <= distBound.y) {\\n            normal = n;\\n            return r;\\n        } else {\\n            return MAX_DIST;\\n        }\\n    }\\n}\\n\\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n                 in vec3 v0, in vec3 v1, in vec3 v2 ) {\\n    vec3 v1v0 = v1 - v0;\\n    vec3 v2v0 = v2 - v0;\\n    vec3 rov0 = ro - v0;\\n\\n    vec3  n = cross( v1v0, v2v0 );\\n    vec3  q = cross( rov0, rd );\\n    float d = 1.0/dot( rd, n );\\n    float u = d*dot( -q, v2v0 );\\n    float v = d*dot(  q, v1v0 );\\n    float t = d*dot( -n, rov0 );\\n\\n    if( u<0. || v<0. || (u+v)>1. || t<distBound.x || t>distBound.y) {\\n        return MAX_DIST;\\n    } else {\\n        normal = normalize(-n);\\n        return t;\\n    }\\n}\\n\\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\\nfloat iSphere4( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n                in float ra ) {\\n    // -----------------------------\\n    // solve quartic equation\\n    // -----------------------------\\n    \\n    float r2 = ra*ra;\\n    \\n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\\n\\n    float ka = 1.0/dot(d2,d2);\\n\\n    float k0 = ka* dot(ro,d3);\\n    float k1 = ka* dot(o2,d2);\\n    float k2 = ka* dot(o3,rd);\\n    float k3 = ka*(dot(o2,o2) - r2*r2);\\n\\n    // -----------------------------\\n    // solve cubic\\n    // -----------------------------\\n\\n    float c0 = k1 - k0*k0;\\n    float c1 = k2 + 2.0*k0*(k0*k0 - (3.0/2.0)*k1);\\n    float c2 = k3 - 3.0*k0*(k0*(k0*k0 - 2.0*k1) + (4.0/3.0)*k2);\\n\\n    float p = c0*c0*3.0 + c2;\\n    float q = c0*c0*c0 - c0*c2 + c1*c1;\\n    float h = q*q - p*p*p*(1.0/27.0);\\n\\n    // -----------------------------\\n    // skip the case of 3 real solutions for the cubic, which involves \\n    // 4 complex solutions for the quartic, since we know this objcet is \\n    // convex\\n    // -----------------------------\\n    if (h<0.0) {\\n        return MAX_DIST;\\n    }\\n    \\n    // one real solution, two complex (conjugated)\\n    h = sqrt(h);\\n\\n    float s = sign(q+h)*pow(abs(q+h),1.0/3.0); // cuberoot\\n    float t = sign(q-h)*pow(abs(q-h),1.0/3.0); // cuberoot\\n\\n    vec2 v = vec2( (s+t)+c0*4.0, (s-t)*sqrt(3.0) )*0.5;\\n    \\n    // -----------------------------\\n    // the quartic will have two real solutions and two complex solutions.\\n    // we only want the real ones\\n    // -----------------------------\\n    \\n    float r = length(v);\\n\\tfloat d = -abs(v.y)/sqrt(r+v.x) - c1/r - k0;\\n\\n    if (d >= distBound.x && d <= distBound.y) {\\n\\t    vec3 pos = ro + rd * d;\\n\\t    normal = normalize( pos*pos*pos );\\n\\t    return d;\\n    } else {\\n        return MAX_DIST;\\n    }\\n}\\n\\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\\nfloat cuberoot( float x ) { return sign(x)*pow(abs(x),1.0/3.0); }\\n\\nfloat iGoursat( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n                in float ra, float rb ) {\\n// hole: x4 + y4 + z4 - (r2^2)(x2 + y2 + z2) + r1^4 = 0;\\n    float ra2 = ra*ra;\\n    float rb2 = rb*rb;\\n    \\n    vec3 rd2 = rd*rd; vec3 rd3 = rd2*rd;\\n    vec3 ro2 = ro*ro; vec3 ro3 = ro2*ro;\\n\\n    float ka = 1.0/dot(rd2,rd2);\\n\\n    float k3 = ka*(dot(ro ,rd3));\\n    float k2 = ka*(dot(ro2,rd2) - rb2/6.0);\\n    float k1 = ka*(dot(ro3,rd ) - rb2*dot(rd,ro)/2.0  );\\n    float k0 = ka*(dot(ro2,ro2) + ra2*ra2 - rb2*dot(ro,ro) );\\n\\n    float c2 = k2 - k3*(k3);\\n    float c1 = k1 + k3*(2.0*k3*k3-3.0*k2);\\n    float c0 = k0 + k3*(k3*(c2+k2)*3.0-4.0*k1);\\n\\n    c0 /= 3.0;\\n\\n    float Q = c2*c2 + c0;\\n    float R = c2*c2*c2 - 3.0*c0*c2 + c1*c1;\\n    float h = R*R - Q*Q*Q;\\n    \\n    \\n    // 2 intersections\\n    if (h>0.0) {\\n        h = sqrt(h);\\n\\n        float s = cuberoot( R + h );\\n        float u = cuberoot( R - h );\\n        \\n        float x = s+u+4.0*c2;\\n        float y = s-u;\\n        \\n        float k2 = x*x + y*y*3.0;\\n  \\n        float k = sqrt(k2);\\n\\n\\t\\tfloat d = -0.5*abs(y)*sqrt(6.0/(k+x)) \\n                  -2.0*c1*(k+x)/(k2+x*k) \\n                  -k3;\\n        \\n        if (d >= distBound.x && d <= distBound.y) {\\n            vec3 pos = ro + rd * d;\\n            normal = normalize( 4.0*pos*pos*pos - 2.0*pos*rb*rb );\\n            return d;\\n        } else {\\n            return MAX_DIST;\\n        }\\n    } else {\\t\\n        // 4 intersections\\n        float sQ = sqrt(Q);\\n        float z = c2 - 2.0*sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\\n\\n        float d1 = z   - 3.0*c2;\\n        float d2 = z*z - 3.0*c0;\\n\\n        if (abs(d1)<1.0e-4) {  \\n            if( d2<0.0) return MAX_DIST;\\n            d2 = sqrt(d2);\\n        } else {\\n            if (d1<0.0) return MAX_DIST;\\n            d1 = sqrt( d1/2.0 );\\n            d2 = c1/d1;\\n        }\\n\\n        //----------------------------------\\n\\n        float h1 = sqrt(d1*d1 - z + d2);\\n        float h2 = sqrt(d1*d1 - z - d2);\\n        float t1 = -d1 - h1 - k3;\\n        float t2 = -d1 + h1 - k3;\\n        float t3 =  d1 - h2 - k3;\\n        float t4 =  d1 + h2 - k3;\\n\\n        if (t2<0.0 && t4<0.0) return MAX_DIST;\\n\\n        float result = 1e20;\\n             if (t1>0.0) result=t1;\\n        else if (t2>0.0) result=t2;\\n             if (t3>0.0) result=min(result,t3);\\n        else if (t4>0.0) result=min(result,t4);\\n\\n        if (result >= distBound.x && result <= distBound.y) {\\n            vec3 pos = ro + rd * result;\\n            normal = normalize( 4.0*pos*pos*pos - 2.0*pos*rb*rb );\\n            return result;\\n        } else {\\n            return MAX_DIST;\\n        }\\n    }\\n}\\n\\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\\nfloat iRoundedBox(in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\\n   \\t\\t\\t\\t  in vec3 size, in float rad ) {\\n\\t// bounding box\\n    vec3 m = 1.0/rd;\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*(size+rad);\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n    if (tN > tF || tF < 0.0) {\\n    \\treturn MAX_DIST;\\n    }\\n    float t = (tN>=distBound.x&&tN<=distBound.y)?tN:\\n    \\t\\t  (tF>=distBound.x&&tF<=distBound.y)?tF:MAX_DIST;\\n\\n    // convert to first octant\\n    vec3 pos = ro+t*rd;\\n    vec3 s = sign(pos);\\n    vec3 ros = ro*s;\\n    vec3 rds = rd*s;\\n    pos *= s;\\n        \\n    // faces\\n    pos -= size;\\n    pos = max( pos.xyz, pos.yzx );\\n    if (min(min(pos.x,pos.y),pos.z)<0.0) {\\n        if (t >= distBound.x && t <= distBound.y) {\\n            vec3 p = ro + rd * t;\\n            normal = sign(p)*normalize(max(abs(p)-size,0.0));\\n            return t;\\n        }\\n    }\\n    \\n    // some precomputation\\n    vec3 oc = ros - size;\\n    vec3 dd = rds*rds;\\n\\tvec3 oo = oc*oc;\\n    vec3 od = oc*rds;\\n    float ra2 = rad*rad;\\n\\n    t = MAX_DIST;        \\n\\n    // corner\\n    {\\n    float b = od.x + od.y + od.z;\\n\\tfloat c = oo.x + oo.y + oo.z - ra2;\\n\\tfloat h = b*b - c;\\n\\tif (h > 0.0) t = -b-sqrt(h);\\n    }\\n\\n    // edge X\\n    {\\n\\tfloat a = dd.y + dd.z;\\n\\tfloat b = od.y + od.z;\\n\\tfloat c = oo.y + oo.z - ra2;\\n\\tfloat h = b*b - a*c;\\n\\tif (h>0.0) {\\n\\t  h = (-b-sqrt(h))/a;\\n      if (h>=distBound.x && h<t && abs(ros.x+rds.x*h)<size.x ) t = h;\\n    }\\n\\t}\\n    // edge Y\\n    {\\n\\tfloat a = dd.z + dd.x;\\n\\tfloat b = od.z + od.x;\\n\\tfloat c = oo.z + oo.x - ra2;\\n\\tfloat h = b*b - a*c;\\n\\tif (h>0.0) {\\n\\t  h = (-b-sqrt(h))/a;\\n      if (h>=distBound.x && h<t && abs(ros.y+rds.y*h)<size.y) t = h;\\n    }\\n\\t}\\n    // edge Z\\n    {\\n\\tfloat a = dd.x + dd.y;\\n\\tfloat b = od.x + od.y;\\n\\tfloat c = oo.x + oo.y - ra2;\\n\\tfloat h = b*b - a*c;\\n\\tif (h>0.0) {\\n\\t  h = (-b-sqrt(h))/a;\\n      if (h>=distBound.x && h<t && abs(ros.z+rds.z*h)<size.z) t = h;\\n    }\\n\\t}\\n    \\n\\tif (t >= distBound.x && t <= distBound.y) {\\n        vec3 p = ro + rd * t;\\n        normal = sign(p)*normalize(max(abs(p)-size,1e-16));\\n        return t;\\n    } else {\\n        return MAX_DIST;\\n    };\\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Ray Tracing - Primitives. Created by Reinder Nijhoff 2019\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/tl23Rm\\n//\\n// I have combined different intersection routines in one shader (similar \\n// to \\"Raymarching - Primitives\\": https://www.shadertoy.com/view/Xds3zN) and\\n// added a simple ray tracer to visualize a scene with all primitives.\\n//\\n\\n#define PATH_LENGTH 12\\n\\n//\\n// Hash functions by Nimitz:\\n// https://www.shadertoy.com/view/Xt3cDn\\n//\\n\\nuint baseHash( uvec2 p ) {\\n    p = 1103515245U*((p >> 1U)^(p.yx));\\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\\n    return h32^(h32 >> 16);\\n}\\n\\nfloat hash1( inout float seed ) {\\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    return float(n)/float(0xffffffffU);\\n}\\n\\nvec2 hash2( inout float seed ) {\\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\\n    uvec2 rz = uvec2(n, n*48271U);\\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\\n}\\n\\n//\\n// Ray tracer helper functions\\n//\\n\\nfloat FresnelSchlickRoughness( float cosTheta, float F0, float roughness ) {\\n    return F0 + (max((1. - roughness), F0) - F0) * pow(abs(1. - cosTheta), 5.0);\\n}\\n\\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\\n  \\tvec2 r = hash2(seed);\\n\\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\\n\\tvec3  vv = cross(uu, n);\\n\\tfloat ra = sqrt(r.y);\\n\\tfloat rx = ra*cos(6.28318530718*r.x); \\n\\tfloat ry = ra*sin(6.28318530718*r.x);\\n\\tfloat rz = sqrt(1.-r.y);\\n\\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\\n    return normalize(rr);\\n}\\n\\nvec3 modifyDirectionWithRoughness( const vec3 normal, const vec3 n, const float roughness, inout float seed ) {\\n    vec2 r = hash2(seed);\\n    \\n\\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\\n\\tvec3  vv = cross(uu, n);\\n\\t\\n    float a = roughness*roughness;\\n    \\n\\tfloat rz = sqrt(abs((1.0-r.y) / clamp(1.+(a - 1.)*r.y,.00001,1.)));\\n\\tfloat ra = sqrt(abs(1.-rz*rz));\\n\\tfloat rx = ra*cos(6.28318530718*r.x); \\n\\tfloat ry = ra*sin(6.28318530718*r.x);\\n\\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\\n    \\n    vec3 ret = normalize(rr);\\n    return dot(ret,normal) > 0. ? ret : n;\\n}\\n\\nvec2 randomInUnitDisk( inout float seed ) {\\n    vec2 h = hash2(seed) * vec2(1,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r*vec2(sin(phi),cos(phi));\\n}\\n\\n//\\n// Scene description\\n//\\n\\nvec3 rotateY( const in vec3 p, const in float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\\n    return vec3(xz.x, p.y, xz.y);\\n}\\n\\nvec3 opU( vec3 d, float iResult, float mat ) {\\n\\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\\n}\\n\\nfloat iMesh( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal) {\\n\\tconst vec3 tri0 = vec3(-2./3. * 0.43301270189, 0, 0);\\n\\tconst vec3 tri1 = vec3( 1./3. * 0.43301270189, 0, .25);\\n\\tconst vec3 tri2 = vec3( 1./3. * 0.43301270189, 0,-.25);\\n\\tconst vec3 tri3 = vec3( 0, 0.41079191812, 0);\\n    \\n    vec2 d = distBound;\\n\\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri0, tri1, tri2));   \\n\\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri0, tri3, tri1));  \\n\\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri2, tri3, tri0));   \\n\\td.y = min(d.y, iTriangle(ro, rd, d, normal, tri1, tri3, tri2));\\n    \\n    return d.y < distBound.y ? d.y : MAX_DIST;\\n}\\n         \\nvec3 worldhit( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal ) {\\n    vec3 tmp0, tmp1, d = vec3(dist, 0.);\\n    \\n    d = opU(d, iPlane      (ro,                  rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\\n    d = opU(d, iBox        (ro-vec3( 1,.250, 0), rd, d.xy, normal, vec3(.25)), 2.);\\n    d = opU(d, iSphere     (ro-vec3( 0,.250, 0), rd, d.xy, normal, .25), 3.);\\n    d = opU(d, iCylinder   (ro,                  rd, d.xy, normal, vec3(2.1,.1,-2), vec3(1.9,.5,-1.9), .08 ), 4.);\\n    d = opU(d, iCylinder   (ro-vec3( 1,.100,-2), rd, d.xy, normal, vec3(0,0,0), vec3(0,.4,0), .1 ), 5.);\\n    d = opU(d, iTorus      (ro-vec3( 0,.250, 1), rd, d.xy, normal, vec2(.2,.05)), 6.);\\n    d = opU(d, iCapsule    (ro-vec3( 1,.000,-1), rd, d.xy, normal, vec3(-.1,.1,-.1), vec3(.2,.4,.2), .1), 7.);\\n    d = opU(d, iCone       (ro-vec3( 2,.200, 0), rd, d.xy, normal, vec3(.1,0,0), vec3(-.1,.3,.1), .15, .05), 8.);\\n    d = opU(d, iRoundedBox (ro-vec3( 0,.250,-2), rd, d.xy, normal, vec3(.15,.125,.15), .045), 9.);\\n    d = opU(d, iGoursat    (ro-vec3( 1,.275, 1), rd, d.xy, normal, .16, .2), 10.);\\n    d = opU(d, iEllipsoid  (ro-vec3(-1,.300, 0), rd, d.xy, normal, vec3(.2,.25, .05)), 11.);\\n    d = opU(d, iRoundedCone(ro-vec3( 2,.200,-1), rd, d.xy, normal, vec3(.1,0,0), vec3(-.1,.3,.1), 0.15, 0.05), 12.);\\n    d = opU(d, iRoundedCone(ro-vec3(-1,.200,-2), rd, d.xy, normal, vec3(0,.3,0), vec3(0,0,0), .1, .2), 13.);\\n    d = opU(d, iMesh       (ro-vec3( 2,.090, 1), rd, d.xy, normal), 14.);\\n    d = opU(d, iSphere4    (ro-vec3(-1,.275,-1), rd, d.xy, normal, .225), 15.);\\n    \\n    tmp1 = opU(d, iBox     (rotateY(ro-vec3(0,.25,-1), 0.78539816339), rotateY(rd, 0.78539816339), d.xy, tmp0, vec3(.1,.2,.1)), 16.);\\n    if (tmp1.y < d.y) {\\n        d = tmp1;\\n        normal = rotateY(tmp0, -0.78539816339);\\n    }\\n    \\n    return d;\\n}\\n\\n//\\n// Palette by igo Qulez: \\n// https://www.shadertoy.com/view/ll2GD3\\n//\\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\\n    return a + b*cos(6.28318530718*(c*t+d));\\n}\\n\\nfloat checkerBoard( vec2 p ) {\\n   return mod(floor(p.x) + floor(p.y), 2.);\\n}\\n\\nvec3 getSkyColor( vec3 rd ) {\\n    vec3 col = mix(vec3(1),vec3(.5,.7,1), .5+.5*rd.y);\\n    float sun = clamp(dot(normalize(vec3(-.4,.7,-.6)),rd), 0., 1.);\\n    col += vec3(1,.6,.1)*(pow(sun,4.) + 10.*pow(sun,32.));\\n    return col;\\n}\\n\\n#define LAMBERTIAN 0.\\n#define METAL 1.\\n#define DIELECTRIC 2.\\n\\nfloat gpuIndepentHash(float p) {\\n    p = fract(p * .1031);\\n    p *= p + 19.19;\\n    p *= p + p;\\n    return fract(p);\\n}\\n\\nvoid getMaterialProperties(in vec3 pos, in float mat, \\n                           out vec3 albedo, out float type, out float roughness) {\\n    albedo = pal(mat*.59996323+.5, vec3(.5),vec3(.5),vec3(1),vec3(0,.1,.2));\\n\\n    if( mat < 1.5 ) {            \\n        albedo = vec3(.25 + .25*checkerBoard(pos.xz * 5.));\\n        roughness = .75 * albedo.x - .15;\\n        type = METAL;\\n    } else {\\n        type = floor(gpuIndepentHash(mat+.3) * 3.);\\n        roughness = (1.-type*.475) * gpuIndepentHash(mat);\\n    }\\n}\\n\\n//\\n// Simple ray tracer\\n//\\n\\nfloat schlick(float cosine, float r0) {\\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\\n}\\nvec3 render( in vec3 ro, in vec3 rd, inout float seed ) {\\n    vec3 albedo, normal, col = vec3(1.); \\n    float roughness, type;\\n    \\n    for (int i=0; i<PATH_LENGTH; ++i) {    \\n    \\tvec3 res = worldhit( ro, rd, vec2(.0001, 100), normal );\\n\\t\\tif (res.z > 0.) {\\n\\t\\t\\tro += rd * res.y;\\n       \\t\\t\\n            getMaterialProperties(ro, res.z, albedo, type, roughness);\\n            \\n            if (type < LAMBERTIAN+.5) { // Added/hacked a reflection term\\n                float F = FresnelSchlickRoughness(max(0.,-dot(normal, rd)), .04, roughness);\\n                if (F > hash1(seed)) {\\n                    rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);\\n                } else {\\n                    col *= albedo;\\n\\t\\t\\t        rd = cosWeightedRandomHemisphereDirection(normal, seed);\\n                }\\n            } else if (type < METAL+.5) {\\n                col *= albedo;\\n                rd = modifyDirectionWithRoughness(normal, reflect(rd,normal), roughness, seed);            \\n            } else { // DIELECTRIC\\n                vec3 normalOut, refracted;\\n                float ni_over_nt, cosine, reflectProb = 1.;\\n                if (dot(rd, normal) > 0.) {\\n                    normalOut = -normal;\\n            \\t\\tni_over_nt = 1.4;\\n                    cosine = dot(rd, normal);\\n                    cosine = sqrt(1.-(1.4*1.4)-(1.4*1.4)*cosine*cosine);\\n                } else {\\n                    normalOut = normal;\\n                    ni_over_nt = 1./1.4;\\n                    cosine = -dot(rd, normal);\\n                }\\n            \\n\\t            // Refract the ray.\\n\\t            refracted = refract(normalize(rd), normalOut, ni_over_nt);\\n    \\t        \\n        \\t    // Handle total internal reflection.\\n                if(refracted != vec3(0)) {\\n                \\tfloat r0 = (1.-ni_over_nt)/(1.+ni_over_nt);\\n\\t        \\t\\treflectProb = FresnelSchlickRoughness(cosine, r0*r0, roughness);\\n                }\\n                \\n                rd = hash1(seed) <= reflectProb ? reflect(rd,normalOut) : refracted;\\n                rd = modifyDirectionWithRoughness(-normalOut, rd, roughness, seed);            \\n            }\\n        } else {\\n            col *= getSkyColor(rd);\\n\\t\\t\\treturn col;\\n        }\\n    }  \\n    return vec3(0);\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv =          ( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    bool reset = iFrame == 0;\\n            \\n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \\n              abs(iMouse.xy)/iResolution.xy - .5;\\n        \\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\\n    if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\\n        reset = true;\\n    }\\n    \\n    vec3 ro = vec3(.5+2.5*cos(1.5+6.*mo.x), 1.+2.*mo.y, -.5+2.5*sin(1.5+6.*mo.x));\\n    vec3 ta = vec3(.5, -.4, -.5);\\n    mat3 ca = setCamera(ro, ta, 0.);    \\n    vec3 normal;\\n    \\n    float fpd = data.x;\\n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\\n        // Calculate focus plane.\\n        float nfpd = worldhit(ro, normalize(vec3(.5,0,-.5)-ro), vec2(0, 100), normal).y;\\n\\t\\tfragColor = vec4(nfpd, mo*iResolution.xy, iResolution.x);\\n    } else { \\n        vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\\n        float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\\n\\n        // AA\\n        p += 2.*hash2(seed)/iResolution.y;\\n        vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \\n\\n        // DOF\\n        vec3 fp = ro + rd * fpd;\\n        ro = ro + ca * vec3(randomInUnitDisk(seed), 0.)*.02;\\n        rd = normalize(fp - ro);\\n\\n        vec3 col = render(ro, rd, seed);\\n\\n        if (reset) {\\n           fragColor = vec4(col, 1);\\n        } else {\\n           fragColor = vec4(col, 1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\\n        }\\n    }\\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Wtj3Wc","date":"1561384782","viewed":2667,"name":"Gaussian Weights and Fake AO","description":"A shader about Gaussian weights and fake AO. (Set AA to 1. if the shader is running <60fps - line 27)","likes":55,"published":"Public API","usePreview":0,"tags":["blur","fake","ao","occlusion","ambient","gaussian","error","weights"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gaussian Weights and Fake AO. Created by Reinder Nijhoff 2019\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/Wtj3Wc\\n//\\n// Sometimes you need to calculate the weights of a Gaussian blur kernel \\n// yourself. For example if you want to calculate weights for a kernel where\\n// the center of the Gaussian curve is not exactly in the \\"center of the\\n// kernel\\" but has a sub-pixel offset. These \\"shifted\\" Gaussian kernels can be\\n// used if you want to blur-and-upscale an image in a single pass, e.g. if you\\n// are adding a low-res raytraced reflection buffer to your high-res\\n// rasterized scene. It is also needed for the fake ambient occlusion (AO)\\n// term as used in this shader.\\n//\\n// The Gaussian weights for a blur kernel can be calculated, either by\\n// numerical integration, or by directly calculating the value of the Gauss\\n// error funtion, as shown below.\\n//\\n// In this shader I calculate a fake ambient occlusion (AO) term for each\\n// sample point. The AO-term is based on the weighted average of fake AO-terms\\n// for all cells in a 7x7 grid around the sample point, corresponding with a\\n// 7x7 Gaussian kernel with the sample point as its center. The AO-term for\\n// a single cell in this weighted average is simply given by the difference in\\n// height of the cell and that of the sample point.\\n//\\n\\n#define AA 2.\\n#define MAX_DIST 10000.\\n\\n//\\n// Approximation of the Gauss error function (https://en.wikipedia.org/wiki/Error_function)\\n// http://people.math.sfu.ca/~cbm/aands/page_299.htm\\n//\\nfloat erf(float x) {\\n    const float p  =  .47047;\\n    const float a1 =  .3480242;\\n    const float a2 = -.0958798;  \\n    const float a3 =  .7478556;\\n\\n    float t = 1. / (1. + p * x);\\n    return 1. - t * (a1 + t * (a2 + t * a3)) * exp(-x*x);\\n}\\n    \\nfloat gaussianWeight(int cell, float center, const float sigma) {\\n    float x0 = float(cell) - center;\\n    float x1 = abs(x0+1.);\\n    x0 = abs(x0);\\n    \\n    float erfx0 = erf(x0 / sigma);\\n    float erfx1 = erf(x1 / sigma);\\n    \\n    return x0 < 1. && x1 < 1. ? abs(erfx0 + erfx1) : abs(erfx0 - erfx1);\\n}\\n\\nfloat gaussianWeight(ivec2 cell, vec2 center, const float sigma) {\\n\\tfloat ix = gaussianWeight(cell.x, center.x, sigma);\\n\\tfloat iy = gaussianWeight(cell.y, center.y, sigma);\\n    \\n    return ix * iy;\\n}\\n\\n// Hash by Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\\nfloat hash12(vec2 p) {\\n\\tvec3 p3  = fract(vec3(p.xyx) * .1031);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\nfloat curveXOffset(vec2 pos) {\\n    return 15.*cos(pos.y*.1);;\\n}\\n\\n// camera path\\nvec3 curve(float time) {\\n\\tvec3 p = vec3(0., 3.5+.8*cos(.95*time), 8.5*sin(.1+.37*time)+12.*time);\\n    p.x = curveXOffset(p.xz);\\n    return p;\\n}\\n\\nfloat map(vec2 pos) {\\n    float x = pos.x - curveXOffset(pos);\\n    return (2.*hash12(pos) + 5.) * (.3+min(3.,.002*(x*x)));\\n}\\n\\nfloat fakeAO(vec3 p) {\\n    const int gridOffset = 3;\\n    float sum =0., accum = 0.;\\n    \\n    for (int x = -gridOffset; x <= gridOffset; x++) {\\n        for (int y = -gridOffset; y <= gridOffset; y++) {\\n            ivec2 s = ivec2(x,y) + ivec2(p.xz);\\n            float weight = gaussianWeight(s, p.xz, 1.5);\\n            \\n            sum += max(map(vec2(s))-p.y, 0.) * weight;\\n            accum += weight;\\n        }\\n    }\\n    return sum / accum;\\n}\\n\\n// trace cubes in grid\\nvec3 trace( in vec3 ro, in vec3 rd, const int steps, inout vec3 normal ) {\\n\\tvec2 pos = floor(ro.xz);\\n    vec3 rdi = 1./rd;\\n    vec3 rda = abs(rdi);\\n\\tvec3 rds = sign(rd);\\n\\tvec2 dis = (pos - ro.xz + .5 + rds.xz*.5) * rdi.xz;\\n\\tvec3 roi = rdi*(ro-vec3(.5,0,.5));\\n    \\n\\tvec2 mm = vec2(0.0);\\n\\tfor( int i=0; i<steps; i++ ) {        \\n        vec3 n = roi - rdi * vec3(pos.x, 0, pos.y);\\n        vec3 k = rda*vec3(.5, map(pos), .5);\\n\\n        vec3 t1 = -n - k;\\n        vec3 t2 = -n + k;\\n\\n        float tN = max( max( t1.x, t1.y ), t1.z );\\n        float tF = min( min( t2.x, t2.y ), t2.z );\\n\\n        if (tN < tF && tN >= 0.) {\\n            normal = -rds*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n            return vec3(tN, pos);\\n        }\\n        \\n\\t\\tmm = step( dis.xy, dis.yx ); \\n\\t\\tdis += mm*rda.xz;\\n        pos += mm*rds.xz;\\n\\t}\\n\\n\\treturn vec3(MAX_DIST);\\n}\\n\\nvec3 render( in vec3 ro, in vec3 rd, bool full ) {\\n    vec3 normal, col = vec3(0);\\n\\tfloat ref = 1.;\\n    \\n    for (int i=1; i>=0; i--) {\\n        vec3 d = trace(ro, rd, i*64+64, normal);\\n        if (d.x < MAX_DIST) { // cube hit\\n            ro += d.x * rd;\\n            \\n            float fresnel = full ? pow(1.-max(0.,-dot(normal,rd)),5.) : 0.;\\n            float mat = full ? hash12(d.zy) : 1.;\\n            mat *= exp(-1.5*fakeAO(ro)) * ref * (1.-fresnel) \\n                * (.8 + .2 * dot(normal, vec3(-.25916,.8639,-.4319)));\\n\\t       \\tcol += mat;\\n            \\n            ref *= fresnel;\\n            rd = reflect(rd, normal);\\n        } else { // background \\n            col +=vec3(.5,.8,1) * (ref*(5.-2.5*rd.y));\\n            return col;\\n        }\\n        if (ref <= .001) return col;\\n    }    \\n    return col;\\n}\\n\\nmat3 setLookAt( in vec3 ro, in vec3 ta, float cr ) {\\n\\tvec3  cw = normalize(ta-ro);\\n\\tvec3  cp = vec3(sin(cr), cos(cr), 0.);\\n\\tvec3  cu = normalize(cross(cw,cp));\\n\\tvec3  cv = normalize(cross(cu,cw));\\n    return mat3(cu, cv, cw);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    float time = .2*iTime + 20.*iMouse.x/iResolution.x;    \\n    vec2 p = (-iResolution.xy+2.*(fragCoord)) / iResolution.y;\\n\\tbool full = fract(.5*time + .015*(p.x + p.y)) < .5;\\n    \\n    vec3 ro = curve(time);\\n    vec3 ta = curve(time+.1);\\n    ta.y -= .3 + .1*sin(time);\\n    float roll = .2*sin(.1*ro.z-1.6);\\n\\n    mat3 ca = setLookAt( ro, ta, roll );\\n    \\n    vec3 tot = vec3(0);    \\n    for (float x=0.; x<AA; x+=1.) {     \\n        for (float y=0.; y<AA; y+=1.) {\\n            vec3 rd = normalize(ca * vec3(p + vec2(x,y)*(2./(AA*iResolution.y)), 2.));\\n            vec3 col = render(ro, rd, full);\\n            col = pow(col, vec3(.4545));\\n            tot += min(col, vec3(1));\\n        }\\n\\t}\\n    tot /= (AA*AA);\\n    \\n    fragColor = vec4(tot, 1);\\n}\\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tlSSDV","date":"1567106604","viewed":5935,"name":"Robotic Arm Hunting Lights","description":"This shader is a proof of concept to find out if I could create a \\"typical\\" Shadertoy shader, i.e. a shader that renders a non-trivial animated 3D scene, by using a ray tracer instead of the commonly used raymarching techniques. ","likes":130,"published":"Public API","usePreview":0,"tags":["raytracer","ray","tracer","inverse","kinematics","inversekinematics"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Robotic Arm. Created by Reinder Nijhoff 2019\\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/tlSSDV\\n//\\n// This shader is a proof of concept to find out if I could \\n// create a typical Shadertoy shader, i.e. a shader that renders \\n// a non-trivial animated 3D scene, by using a ray tracer instead \\n// of the commonly used raymarching techniques. \\n//\\n// Some first conclusions:\\n// \\n// - It is possible to visualize an animated 3D scene in a single \\n//   shader using ray tracing.\\n// - The compile-time of this shader is quite long.\\n// - The ray tracer is not super fast, so it was not possible to cast\\n//   enough rays per pixel to support global illumination or soft\\n//   shadows. Here I miss the cheap AO and soft shadow algorithms that\\n//   are available when raymarching an SDF.\\n// - Modelling a 3D scene for a ray tracer in code is verbose. It was\\n//   not possible to exploit the symmetries in the arm and the domain\\n//   repetition of the sphere-grid that would have simplified the\\n//   description of an SDF.\\n// - I ran in GPU-dependent unpredictable precision problems. Hopefully,\\n//   most problems are solved now. Im not sure if they are inherent\\n//   to ray tracing, but I didnt have these kinds of problems using\\n//   raymarching before.\\n//\\n\\n#define AA 1 // Set AA to 1 if you have a slow GPU\\n#define PATH_LENGTH 3\\n#define MAX_DIST 60.\\n#define MIN_DIST .001\\n#define ZERO (min(iFrame,0))\\n\\n// Global variables\\nfloat time;\\nvec2[2] activeSpheres;\\nvec2[3] joints;\\nfloat joint0Rot;\\nfloat jointYRot;\\n\\n//\\n// Hash by Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\\n//\\nvec2 hash22(vec2 p) {\\n\\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\\n    p3 += dot(p3, p3.yzx+33.33);\\n    return fract((p3.xx+p3.yz)*p3.zy);\\n}\\n\\n//\\n// Ray-primitive intersection routines: https://www.shadertoy.com/view/tl23Rm\\n//\\nfloat dot2( in vec3 v ) { return dot(v,v); }\\n\\n// Plane \\nfloat iPlane( const in vec3 ro, const in vec3 rd, in vec2 distBound, inout vec3 normal,\\n              const in vec3 planeNormal, const in float planeDist) {\\n    float a = dot(rd, planeNormal);\\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\\n    if (a > 0. || d < distBound.x || d > distBound.y) {\\n        return MAX_DIST;\\n    } else {\\n        normal = planeNormal;\\n    \\treturn d;\\n    }\\n}\\n\\n// Sphere: https://www.shadertoy.com/view/4d2XWV\\nfloat iSphere( const in vec3 ro, const in vec3 rd, const in vec2 distBound, inout vec3 normal,\\n               const float sphereRadius ) {\\n    float b = dot(ro, rd);\\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\\n    float h = b*b - c;\\n    if (h < 0.) {\\n        return MAX_DIST;\\n    } else {\\n\\t    h = sqrt(h);\\n        float d1 = -b-h;\\n        float d2 = -b+h;\\n        if (d1 >= distBound.x && d1 <= distBound.y) {\\n            normal = normalize(ro + rd*d1);\\n            return d1;\\n        } else {\\n            return MAX_DIST;\\n        }\\n    }\\n}\\n\\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\\nfloat iCylinder( const in vec3 oc, const in vec3 rd, const in vec2 distBound, inout vec3 normal,\\n                 const in vec3 ca, const float ra, const bool traceCaps ) {\\n    float caca = dot(ca,ca);\\n    float card = dot(ca,rd);\\n    float caoc = dot(ca,oc);\\n    \\n    float a = caca - card*card;\\n    float b = caca*dot( oc, rd) - caoc*card;\\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\\n    float h = b*b - a*c;\\n    \\n    if (h < 0.) return MAX_DIST;\\n    \\n    h = sqrt(h);\\n    float d = (-b-h)/a;\\n\\n    float y = caoc + d*card;\\n    if (y >= 0. && y <= caca && d >= distBound.x && d <= distBound.y) {\\n        normal = (oc+d*rd-ca*y/caca)/ra;\\n        return d;\\n    } else if(!traceCaps) {\\n        return MAX_DIST;\\n    } else {\\n        d = ((y < 0. ? 0. : caca) - caoc)/card;\\n\\n        if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\\n            normal = normalize(ca*sign(y)/caca);\\n            return d;\\n        } else {\\n            return MAX_DIST;\\n        }\\n    }\\n}\\n\\n// Capped Cone: https://www.shadertoy.com/view/llcfRf\\nfloat iCone( const in vec3 oa, const in vec3 rd, const in vec2 distBound, inout vec3 normal,\\n             const in vec3 pb, const in float ra, const in float rb ) {\\n    vec3  ba = pb;\\n    vec3  ob = oa - pb;\\n    \\n    float m0 = dot(ba,ba);\\n    float m1 = dot(oa,ba);\\n    float m2 = dot(ob,ba); \\n    float m3 = dot(rd,ba);\\n\\n    //caps - only top cap needed for scene\\n    if (m2 > 0. && dot2(ob*m3-rd*m2) < (rb*rb*m3*m3) ) {\\n        float d = -m2 / m3;\\n        if (d > distBound.x && d < distBound.y) {\\n            normal = ba*inversesqrt(m0);\\n            return d;\\n        }\\n    }\\n    \\n    // body\\n    float m4 = dot(rd,oa);\\n    float m5 = dot(oa,oa);\\n    float rr = ra - rb;\\n    float hy = m0 + rr*rr;\\n\\n    float k2 = m0*m0    - m3*m3*hy;\\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\\n\\n    float h = k1*k1 - k2*k0;\\n    if( h < 0. ) return MAX_DIST;\\n\\n    float t = (-k1-sqrt(h))/k2;\\n\\n    float y = m1 + t*m3;\\n    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {\\n        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);\\n        return t;\\n    } else {   \\n        return MAX_DIST;\\n    }\\n}\\n\\n// Box: https://www.shadertoy.com/view/ld23DV\\nfloat iBox( const in vec3 ro, const in vec3 rd, const in vec2 distBound, inout vec3 normal, \\n            const in vec3 boxSize ) {\\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\\n    vec3 n = m*ro;\\n    vec3 k = abs(m)*boxSize;\\n\\t\\n    vec3 t1 = -n - k;\\n    vec3 t2 = -n + k;\\n\\n\\tfloat tN = max( max( t1.x, t1.y ), t1.z );\\n\\tfloat tF = min( min( t2.x, t2.y ), t2.z );\\n\\t\\n    if (tN > tF || tF <= 0.) {\\n        return MAX_DIST;\\n    } else {\\n        if (tN >= distBound.x && tN <= distBound.y) {\\n        \\tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n            return tN;\\n        } else if (tF >= distBound.x && tF <= distBound.y) {\\n        //\\tnormal = sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\\n            return tF;\\n        } else {\\n            return MAX_DIST;\\n        }\\n    }\\n}\\n\\n//\\n// Ray tracer helper functions\\n//\\nvec3 FresnelSchlick(vec3 SpecularColor, vec3 E, vec3 H) {\\n    return SpecularColor + (1. - SpecularColor) * pow(1.0 - max(0., dot(E, H)), 5.);\\n}\\n\\nvec2 randomInUnitDisk(const vec2 seed) {\\n    vec2 h = hash22(seed) * vec2(1.,6.28318530718);\\n    float phi = h.y;\\n    float r = sqrt(h.x);\\n\\treturn r*vec2(sin(phi),cos(phi));\\n}\\n\\n//\\n// Sphere functions\\n//\\nvec2 activeSphereGrid(float t) {\\n  vec2 p = randomInUnitDisk(vec2(floor(t),.5));\\n  return floor(p * 8.5 + 1.75*normalize(p));\\n}\\n\\nvec3 sphereCenter(vec2 pos) {\\n    vec3 c = vec3(pos.x, 0., pos.y)+vec3(.25,.25,.25);\\n    c.xz += .5*hash22(pos);\\n\\treturn c;\\n}\\n\\nvec3 sphereCol(in float t) {\\n    return normalize(.5 + .5*cos(6.28318530718*(1.61803398875*floor(t)+vec3(0,.1,.2))));\\n}\\n\\n//\\n// Inverse Kinematics\\n//\\n// Very hacky, analytical,  inverse kinematics. I came up with the algorithm myself;\\n// igo Qulez can probably implement it without using trigonometry:\\n// https://iquilezles.org/articles/noacos\\n//\\nvoid initDynamics() {\\n    time = iTime * .25;\\n\\n    activeSpheres[0] = activeSphereGrid(time);\\n    activeSpheres[1] = activeSphereGrid(time+1.);\\n\\n    vec3 ta0 = sphereCenter(activeSpheres[0]);\\n    vec3 ta1 = sphereCenter(activeSpheres[1]);\\n\\n    float taa0 = atan(-ta0.z, ta0.x);  \\n    float taa1 = atan(-ta1.z, ta1.x);\\n\\n    if (abs(taa0-taa1) > 3.14159265359) {\\n        taa1 += taa1 < taa0 ? 2. * 3.14159265359 : -2. * 3.14159265359;  \\n    }\\n    jointYRot = mix(taa0, taa1, clamp(fract(time)*2.-.5,0.,1.));    \\n\\n    float tal = mix(length(ta0), length(ta1), clamp(fract(time)*2.5-1.,0.,1.));\\n\\n    vec2 target = vec2(tal,.5-.5*smoothstep(.35,.4,abs(fract(time)-.5)));  \\n\\n    float c0 = length(target);\\n    float b0 = min(11., 4. + 2. * c0 / 11.);\\n\\n    vec2 sd = normalize(target);\\n    float t0 = asin(sd.y)+acos(-(b0*b0-25.-c0*c0)/(10.*c0));\\n\\n    joints[0] = vec2(5. * cos(t0), 5.* sin(t0));\\n    joint0Rot = t0;\\n\\n    sd = normalize(target-joints[0]);  \\n    float c1 = min(6., distance(joints[0], target));\\n    const float b1 = 2.;  \\n\\n    float t1 = asin(sd.y) * sign(sd.x) + acos(-(b1*b1-16.-c1*c1)/(8.*c1));\\n    t1 += sd.x < 0. ? 3.1415 : 0.;\\n    joints[1] = joints[0] + 4. * vec2(cos(t1),sin(t1));\\n    joints[2] = target;\\n}\\n\\n//\\n// Scene description\\n//\\nvec3 opU( const in vec3 d, const in float iResult, const in float mat ) {\\n\\treturn (iResult < d.y) ? vec3(d.x, iResult, mat) : d;\\n}\\n      \\nvec3 iPlaneInt(vec3 ro, vec3 rd, float d) {\\n    d = -(ro.y - d) / rd.y;\\n    return ro + d * rd;\\n}\\n\\nvec3 traceSphereGrid( in vec3 ro, in vec3 rd, in vec2 dist, out vec3 normal, const int maxsteps ) {  \\n\\tfloat m = 0.;\\n    if (ro.y < .5 || rd.y < 0.) {\\n        vec3 ros = ro.y < .5 ? ro : iPlaneInt(ro, rd, .5);\\n        if (length(ros.xz) < 11.) {\\n            vec3 roe = iPlaneInt(ro, rd,rd.y < 0. ?0.:.5);\\n            vec3 pos = floor(ros);\\n            vec3 rdi = 1./rd;\\n            vec3 rda = abs(rdi);\\n            vec3 rds = sign(rd);\\n            vec3 dis = (pos-ros+ .5 + rds*.5) * rdi;\\n            bool b_hit = false;\\n\\n            // traverse grid in 2D\\n            vec2 mm = vec2(0);\\n            for (int i = ZERO; i<maxsteps; i++) {\\n                float l = length(pos.xz+.5);\\n                if (pos.y > .5 || pos.y < -1.5 || l > 11.) {\\n                    break;\\n                }\\n                else if ( l > 2. && pos.y > -.5 && pos.y < 1.5 ) {\\n                    float d = iSphere(ro-sphereCenter(pos.xz), rd, dist, normal, .25);\\n                    if (d < dist.y) {\\n                        m = 2.;\\n                        dist.y = d;\\n                        break;\\n                    }\\n                }\\t\\n                vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\\n                dis += mm*rda;\\n                pos += mm*rds;\\n            }\\n        }\\n    }\\n\\treturn vec3(dist, m);\\n}\\n\\nvec3 rotateY( const in vec3 p, const in float t ) {\\n    float co = cos(t);\\n    float si = sin(t);\\n    vec2 xz = mat2(co,si,-si,co)*p.xz;\\n    return vec3(xz.x, p.y, xz.y);\\n}\\n\\nvec3 worldhit( const in vec3 ro, const in vec3 rd, const in vec2 dist, out vec3 normal ) {\\n    vec3 d = vec3(dist, 0.);\\n    \\n    d = traceSphereGrid(ro, rd, d.xy, normal, 10);\\n    \\n    d = opU(d, iPlane   (ro, rd, d.xy, normal, vec3(0,1,0), 0.), 1.);\\n    d = opU(d, iCone    (ro-vec3(0,.2,0), rd, d.xy, normal, vec3(0,.2,0), 1.5, 1.4), 4.);\\n    d = opU(d, iCylinder(ro, rd, d.xy, normal, vec3(0,.2,0), 1.5, false), 4.);\\n    \\n    float dmax = d.y;\\n    vec3 roa = rotateY(vec3(ro.x, ro.y-1., ro.z), jointYRot);    \\n    vec3 rda = rotateY(rd, jointYRot); \\n    \\n    vec3 bb = vec3(.5*max(joints[1].x,joints[2].x), joints[0].y*.5, .0);\\n    vec3 bbn;\\n    \\n    if (iBox(roa-bb, rda, vec2(0,100), bbn, bb+vec3(.75,.75,.8)) < 100.) {\\n\\t    vec3 dr = vec3(-sin(joint0Rot), cos(joint0Rot), 0);\\n        vec2 j21 = joints[2]-joints[1];\\n        \\n        for (int axis=0; axis<=1; axis++) {\\n            float a = axis == 0 ? -1. : 1.;\\n            d = opU(d, iCylinder(roa-vec3(0,0,a*.67), rda, d.xy, normal, vec3(0,0,-a*.2),.55, true), 3.);\\n            d = opU(d, iCylinder(roa-vec3(0,0,a*.58)-.4*dr, rda, d.xy, normal, vec3(joints[0],-a*.24)-.24*dr,.07, false), 4.);\\n            d = opU(d, iCylinder(roa-vec3(0,0,a*.58)+.4*dr, rda, d.xy, normal, vec3(joints[0],-a*.24)+.24*dr,.07, false), 4.);\\n            d = opU(d, iCylinder(roa-vec3(joints[0],a*.45), rda, d.xy, normal, vec3(0,0,-a*.2),.35, true), 3.);\\n            d = opU(d, iCylinder(roa-vec3(joints[1],a*.29), rda, d.xy, normal, vec3(0,0,-a*.08),.25, true), 3.);\\n            d = opU(d, iCylinder(roa-vec3(joints[1],a*.24), rda, d.xy, normal, vec3(j21,a*.08),.03, false), 4.);\\n        }\\n\\n        vec2 j10 = joints[1]-joints[0];\\n        d = opU(d, iCylinder(roa-vec3(0,0,-.72), rda, d.xy, normal, vec3(0,0,1.44),.5, true), 5.);\\n        d = opU(d, iBox     (roa+vec3(0,.5,0), rda, d.xy, normal, vec3(.5,.5,.47)), 5.);\\n        d = opU(d, iCone    (roa-vec3(joints[0],0), rda, d.xy, normal, vec3(j10,0),.25, .15), 5.);\\n        d = opU(d, iCylinder(roa-vec3(joints[0],-.5), rda, d.xy, normal, vec3(0,0,1.),.3, true), 5.);\\n        d = opU(d, iCylinder(roa-vec3(joints[1],-.35), rda, d.xy, normal, vec3(0,0,.7),.2, true), 5.);\\n        d = opU(d, iCylinder(roa-vec3(joints[2],-.4), rda, d.xy, normal, vec3(0,0,.8),.2, true), 3.);\\n        d = opU(d, iSphere  (roa-vec3(joints[2],0), rda, d.xy, normal, .32), 5.);\\n        d = opU(d, iCylinder(roa-vec3(joints[2],0), rda, d.xy, normal, vec3(0,-.5,0),.06, true), 3.);\\n\\n        if (d.y < dmax) {\\n            normal = rotateY(normal, -jointYRot);\\n        }\\n    }    \\n    return d;\\n}\\n\\nfloat shadowhit( const vec3 ro, const vec3 rd, const float dist) {\\n    vec3 normal;\\n    float d = traceSphereGrid( ro, rd, vec2(.3, dist), normal, 4).y;\\n    d = min(d, iCylinder(ro, rd, vec2(.3, dist), normal, vec3(0,.2,0), 1.5, false));\\n    return d < dist-0.001 ? 0. : 1.;\\n}\\n\\n//\\n// Simple ray tracer\\n//\\nfloat getSphereLightIntensity(float num) {\\n    return num > .5 ?\\n        clamp(fract(time)*10.-1., 0., 1.) :\\n\\t\\tmax(0., 1.-fract(time)*10.); \\n}\\n\\nfloat getLightIntensity( const vec3 pos, const vec3 normal, const vec3 light, const float intensity) {\\n    vec3 rd = pos - light;\\n    float i = max(0., dot(normal, -normalize(rd)) / dot(rd,rd));\\n    i = i > 0.0001 ? i * intensity * shadowhit(light, normalize(rd), length(rd)) : 0.;\\n    return max(0., i-0.0001);              \\n}\\n\\nvec3 getLighting( vec3 p, vec3 normal ) {\\n    vec3 l = vec3(0.);\\n    \\n    float i = getSphereLightIntensity(0.);\\n    if (i > 0.) {\\n\\t    l += sphereCol(time) * (i * getLightIntensity(p, normal, sphereCenter(activeSpheres[0]), .375));\\n    } else {    \\n        i = getSphereLightIntensity(1.);\\n        if (i > 0.) {\\n            l += sphereCol(time+1.) * (i * getLightIntensity(p, normal, sphereCenter(activeSpheres[1]), .25));\\n        }\\n    }\\n    \\n    vec3 robot = mix(sphereCol(time), sphereCol(time-1.), getSphereLightIntensity(0.));\\n    vec3 lp = rotateY(vec3(joints[2].x, joints[2].y+1.,0), -jointYRot);\\n    i = getLightIntensity(p, normal, lp, .5);\\n    i += getLightIntensity(p, normal, vec3(0,2,0), .25);\\n    l += i * robot;\\n    \\n    return l;\\n}\\n\\nvec3 getEmissive( in vec2 pos, in float mat ) {\\n    if (mat > 2.5 ) {\\n\\t   return mix(sphereCol(time), sphereCol(time-1.), getSphereLightIntensity(0.));\\n    } else if (mat > 1.5 ) {\\n        float li0 = getSphereLightIntensity(0.);\\n        float li1 = getSphereLightIntensity(1.);\\n        if (li0 > 0. && pos == activeSpheres[0]) {\\n            return sphereCol(time) * li0 * 1.25;\\n        } else if (li1 > 0. && pos == activeSpheres[1]) {\\n            return sphereCol(time+1.) * li1;\\n        } else {\\n            return vec3(0);\\n        }\\n    } else {\\n        return vec3(0);\\n    }\\n}\\n\\nvec3 render( in vec3 ro, in vec3 rd) {\\n    vec3 col = vec3(1);\\n    vec3 emitted = vec3(0);\\n    vec3 normal;\\n        \\n    for (int i=ZERO; i<PATH_LENGTH; ++i) {\\n    \\tvec3 res = worldhit( ro, rd, vec2(MIN_DIST, MAX_DIST-1.), normal );\\n\\t\\tif (res.z > 0.) {\\n\\t\\t\\tro += rd * res.y;\\n\\n            if (res.z < 3.5) { \\n               \\tvec3 F = FresnelSchlick(vec3(0.4), normal, -rd);\\n                emitted += (col * (getEmissive(floor(ro.xz), res.z) + .5 * getLighting(ro, normal))) * (1.-F);\\n                col *= .5 * F;\\n            } else {\\n                col *= .15;   \\n            } \\n            \\n            rd = normalize(reflect(rd,normal));\\n        } else {\\n\\t\\t\\treturn emitted;\\n        }\\n    }  \\n    return emitted;\\n}\\n\\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\\n\\tvec3 cw = normalize(ta-ro);\\n\\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\\n\\tvec3 cu = normalize( cross(cw,cp) );\\n\\tvec3 cv =          ( cross(cu,cw) );\\n    return mat3( cu, cv, cw );\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    initDynamics();\\n\\n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.4,-.1) : abs(iMouse.xy)/iResolution.xy - .5;\\n\\n    vec3 ro = vec3(10.5*cos(1.5+6.*mo.x), 6.+10.*mo.y, 8.5*sin(1.5+6.*mo.x));\\n    vec3 ta = vec3(ro.x*ro.y*.02, .8, 0);\\n    mat3 ca = setCamera(ro, ta, 0.);    \\n    \\n    vec3 col = vec3(0);\\n    \\n#if AA>1\\n    for( int m=ZERO; m<AA; m++ )\\n    for( int n=ZERO; n<AA; n++ ) {\\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\\n#else    \\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\\n#endif\\n        vec3 rd = ca * normalize( vec3(p.xy,1.6) );  \\n        col += pow(8. * render(ro, rd), vec3(1./2.2));\\n#if AA>1\\n    }\\n    col /= float(AA*AA);\\n#endif\\n    \\n    col = clamp(col + ((hash22(fragCoord).x-.5)/64.), vec3(0), vec3(1));\\n    \\n\\tfragColor = vec4(col , 1);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Wd3XDr","date":"1571755007","viewed":1709,"name":"Inverse Barrel Distortion","description":"The inverse of a Barrel Distortion.\\n\\nI couldn't find this function online, so I derived it myself. A surprisingly complex formula ;-)","likes":6,"published":"Public API","usePreview":0,"tags":["distortion","barrel","inverse"]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inverse Barrel Distortion. Created by Reinder Nijhoff 2019\\n// The MIT License\\n// @reindernijhoff\\n//\\n// https://www.shadertoy.com/view/Wd3XDr\\n//\\n// The inverse of a Barrel Distortion. \\n//\\n// I couldn't find this function online, so I derived it myself. \\n// A surprisingly complex formula ;-).\\n//\\n// \`\`\`\\n// uv -= .5;\\n//    \\n// float b = distortion;\\n// float l = length(uv);\\n//    \\n// float x0 = pow(9.*b*b*l + sqrt(3.) * sqrt(27.*b*b*b*b*l*l + 4.*b*b*b), 1./3.);\\n// float x = x0 / (pow(2., 1./3.) * pow(3., 2./3.) * b) - pow(2./3., 1./3.) / x0;\\n//    \\n// return uv * (x / l) + .5;\\n// \`\`\`\\n//\\n\\n#define BARREL_DISTORTION 1.5\\n\\nvec2 barrelDistortion(vec2 uv, float distortion) {    \\n    uv -= .5;\\n    uv *= 1. + dot(uv, uv) * distortion;\\n    return uv + .5;\\n}\\n\\nvec2 inverseBarrelDistortion(vec2 uv, float distortion) {    \\n    uv -= .5;\\n    \\n    float b = distortion;\\n    float l = length(uv);\\n    \\n    float x0 = pow(9.*b*b*l + sqrt(3.) * sqrt(27.*b*b*b*b*l*l + 4.*b*b*b), 1./3.);\\n    float x = x0 / (pow(2., 1./3.) * pow(3., 2./3.) * b) - pow(2./3., 1./3.) / x0;\\n       \\n    return uv * (x / l) + .5;\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    vec2 uv = fragCoord/iResolution.xy;\\n    \\n    vec2 uvDist = barrelDistortion(uv, BARREL_DISTORTION);\\n    vec2 uvInv  = inverseBarrelDistortion(uvDist, BARREL_DISTORTION);\\n        \\n    vec3 col = texture(iChannel0, fract(iTime*.5) > .5 ? uvDist : uvInv).rgb;\\n    \\n    fragColor = vec4(col,1.0);\\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wdyBRV","date":"1607508890","viewed":2185,"name":"Cameras and Lenses","description":"Based on the shaders of the excellent article 'Cameras and Lenses' by @BCiechanowski: [URL]https://ciechanow.ski/cameras-and-lenses[/URL]. Use your mouse to focus.","likes":67,"published":"Public API","usePreview":0,"tags":["dof","aperture","cameras","lenses"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cameras and Lenses. Created by Reinder Nijhoff 2020\\n// https://www.shadertoy.com/view/wdyBRV\\n//\\n// Based on the shaders of the excellent article 'Cameras and Lenses' by \\n// @BCiechanowski: https://ciechanow.ski/cameras-and-lenses/\\n//\\n\\nconst float aperture = 0.15;\\n\\nvec2 hash2(float n) {\\n\\treturn fract(n * vec2(0.754878, 0.56984));\\n}\\n\\nvec2 random_in_unit_disk(float seed) {\\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\\n\\treturn sqrt(h.x) * vec2(sin(h.y),cos(h.y));\\n}\\n\\n// https://www.shadertoy.com/view/4d2XWV by Inigo Quilez\\nfloat sphere_intersect(vec3 ro, vec3 rd, vec4 sph) {\\n\\tvec3 oc = ro - sph.xyz;\\n\\tfloat b = dot( oc, rd );\\n\\tfloat c = dot( oc, oc ) - sph.w*sph.w;\\n\\tfloat h = b*b - c;\\n\\tif( h<0.0 ) return -1.0;\\n\\treturn -b - sqrt( h );\\n}\\n\\nvec4 render(vec3 ro, vec3 rd) {\\n    vec3 color = vec3(0.94);\\n\\n    // sphere positions and sphere colors\\n    const vec4 s0 = vec4(0.7, 0.7, 0.3, 0.3);\\n    const vec4 s1 = vec4(-0.7, -0.7, 0.5, 0.5);\\n    const vec3 c0 = vec3(1.0, 0.1, 0.05);\\n    const vec3 c1 = vec3(0.1, 0.8, 0.05);\\n\\n    vec4 sphere = rd.y > 0.0 ? s0 : s1;\\n\\n    float dist = sphere_intersect(ro, rd, sphere);\\n    if (dist > 0.0) { // spheres\\n        float diff = 0.5 + 0.5 * normalize(ro + rd * dist - sphere.xyz).z;\\n        color = ( rd.y > 0.0 ? c0 : c1) * sqrt(diff);\\n    }\\n    else if (rd.z < 0.0) { // plane\\n        dist = -ro.z / rd.z;\\n        vec2 pos = ro.xy + rd.xy * dist;\\n\\n        if (abs(pos.x) < 2. && abs(pos.y) < 2.) {\\n            // checker pattern\\n            vec2  fpos = floor(pos * 2.0);\\n            float s = mod(fpos.x + fpos.y, 2.0) > 0.5 ? 0.54 : 0.66;\\n            \\n            // fake ambient occlusion\\n            vec2  d0 = pos - s0.xy;\\n            float f0 = 12.0 * dot(d0, d0);\\n            vec2  d1 = pos - s1.xy;\\n            float f1 = 5.0 * dot(d1, d1);\\n            float f = (f0*f1 - 1.0) / ((f0 + 1.0)*(f1 + 1.0));\\n\\n            color = vec3(f * s);\\n        }\\n    }\\n    return vec4(color, clamp(dist, 1.5, 3.7));\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\\n    float seed = fract(sin(dot(fragCoord.xy, vec2(1234.0, 5134.0))));\\n    \\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\\n    \\n    vec3 ro = vec3(2.7, 0, 0.7);\\n    vec3 color = vec3(0.0);\\n\\n\\tvec3  focusrd = normalize(vec3(-1., 0.6 * (iMouse.xy*2.-iResolution.xy)/iResolution.y));\\n\\tfloat focusingDistance = iMouse.x > 0. ? abs((ro + focusrd * render(ro, focusrd).w).x - ro.x) : 2.;\\n      \\n    for (float x = 0.0; x <= 6.0; x += 1.) {\\n        for (float y = 0.0; y <= 6.0; y += 1.) {\\n            vec2 offset = random_in_unit_disk(seed + x + 5.0 * y) * aperture;\\n            vec2 aa     = vec2(x - 2.5, y - 2.5) * (0.4 / iResolution.y);\\n            \\n            vec3 rd = normalize(vec3(-focusingDistance, (uv + aa) * focusingDistance * 0.6 + offset));\\n    \\n            color += render(ro - vec3(0.0, offset), rd).rgb;\\n        }\\n    }\\n \\n    color *= (1.0/36.);\\n    \\n    fragColor = vec4(pow(color.rgb, vec3(0.45454)), 1.0);\\n}","name":"Image","description":"","type":"image"}]}]`),dn={shaders:ln},fn={"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png":"./media/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg":"./media/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png":"./media/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png":"./media/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg":"./media/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png":"./media/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg":"./media/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg":"./media/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg":"./media/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg":"./media/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg":"./media/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png":"./media/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg":"./media/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg":"./media/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg":"./media/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg":"./media/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"},vn=dn.shaders,m=[...vn].sort((s,e)=>s.info.name.localeCompare(e.info.name));let u=null;const pn=document.getElementById("canvas-container"),g=document.getElementById("shader-select"),P=document.getElementById("shader-info");m.forEach((s,e)=>{const n=document.createElement("option");n.value=e.toString(),n.textContent=s.info.name,g.appendChild(n)});function Y(s){u&&(u.destruct(),u=null);try{u=new sn(pn,s,{loop:!0,pixelRatio:Math.min(window.devicePixelRatio,2),mediaMapping:n=>fn[n]});const e=`https://www.shadertoy.com/view/${s.info.id}`;P.innerHTML=`
      <strong>${s.info.name}</strong><br>
      <a href="${e}" target="_blank">${e}</a>
    `}catch(e){P.innerHTML=`<span style="color: #f88;">Failed to load shader: ${e.message}</span>`}}g.addEventListener("change",()=>{const s=parseInt(g.value,10);!isNaN(s)&&m[s]&&Y(m[s])});m.length>0&&(g.value="0",Y(m[0]));
